{"ast":null,"code":"// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n// This file implements notes for standard notation. This consists of one or\n// more `NoteHeads`, an optional stem, and an optional flag.\n//\n// *Throughout these comments, a \"note\" refers to the entire `StaveNote`,\n// and a \"key\" refers to a specific pitch/notehead within a note.*\n//\n// See `tests/stavenote_tests.js` for usage examples.\nimport { Vex } from './vex';\nimport { Flow } from './tables';\nimport { BoundingBox } from './boundingbox';\nimport { Stem } from './stem';\nimport { NoteHead } from './notehead';\nimport { StemmableNote } from './stemmablenote';\nimport { Modifier } from './modifier';\nimport { Dot } from './dot'; // To enable logging for this class. Set `Vex.Flow.StaveNote.DEBUG` to `true`.\n\nfunction L(...args) {\n  if (StaveNote.DEBUG) Vex.L('Vex.Flow.StaveNote', args);\n}\n\nconst getStemAdjustment = note => Stem.WIDTH / (2 * -note.getStemDirection());\n\nconst isInnerNoteIndex = (note, index) => index === (note.getStemDirection() === Stem.UP ? note.keyProps.length - 1 : 0); // Helper methods for rest positioning in ModifierContext.\n\n\nfunction shiftRestVertical(rest, note, dir) {\n  const delta = (note.isrest ? 0.0 : 1.0) * dir;\n  rest.line += delta;\n  rest.maxLine += delta;\n  rest.minLine += delta;\n  rest.note.setKeyLine(0, rest.note.getKeyLine(0) + delta);\n} // Called from formatNotes :: center a rest between two notes\n\n\nfunction centerRest(rest, noteU, noteL) {\n  const delta = rest.line - Vex.MidLine(noteU.minLine, noteL.maxLine);\n  rest.note.setKeyLine(0, rest.note.getKeyLine(0) - delta);\n  rest.line -= delta;\n  rest.maxLine -= delta;\n  rest.minLine -= delta;\n}\n\nexport class StaveNote extends StemmableNote {\n  static get CATEGORY() {\n    return 'stavenotes';\n  }\n\n  static get STEM_UP() {\n    return Stem.UP;\n  }\n\n  static get STEM_DOWN() {\n    return Stem.DOWN;\n  }\n\n  static get DEFAULT_LEDGER_LINE_OFFSET() {\n    return 3;\n  } // ## Static Methods\n  //\n  // Format notes inside a ModifierContext.\n\n\n  static format(notes, state) {\n    if (!notes || notes.length < 2) return false; // FIXME: VexFlow will soon require that a stave be set before formatting.\n    // Which, according to the below condition, means that following branch will\n    // always be taken and the rest of this function is dead code.\n    //\n    // Problematically, `Formatter#formatByY` was not designed to work for more\n    // than 2 voices (although, doesn't throw on this condition, just tries\n    // to power through).\n    //\n    // Based on the above:\n    //   * 2 voices can be formatted *with or without* a stave being set but\n    //     the output will be different\n    //   * 3 voices can only be formatted *without* a stave\n\n    if (notes[0].getStave()) {\n      return StaveNote.formatByY(notes, state);\n    }\n\n    const notesList = [];\n\n    for (let i = 0; i < notes.length; i++) {\n      const props = notes[i].getKeyProps();\n      const line = props[0].line;\n      let minL = props[props.length - 1].line;\n      const stemDirection = notes[i].getStemDirection();\n      const stemMax = notes[i].getStemLength() / 10;\n      const stemMin = notes[i].getStemMinumumLength() / 10;\n      let maxL;\n\n      if (notes[i].isRest()) {\n        maxL = line + notes[i].glyph.line_above;\n        minL = line - notes[i].glyph.line_below;\n      } else {\n        maxL = stemDirection === 1 ? props[props.length - 1].line + stemMax : props[props.length - 1].line;\n        minL = stemDirection === 1 ? props[0].line : props[0].line - stemMax;\n      }\n\n      notesList.push({\n        line: props[0].line,\n        // note/rest base line\n        maxLine: maxL,\n        // note/rest upper bounds line\n        minLine: minL,\n        // note/rest lower bounds line\n        isrest: notes[i].isRest(),\n        stemDirection,\n        stemMax,\n        // Maximum (default) note stem length;\n        stemMin,\n        // minimum note stem length\n        voice_shift: notes[i].getVoiceShiftWidth(),\n        is_displaced: notes[i].isDisplaced(),\n        // note manually displaced\n        note: notes[i]\n      });\n    }\n\n    const voices = notesList.length;\n    let noteU = notesList[0];\n    const noteM = voices > 2 ? notesList[1] : null;\n    let noteL = voices > 2 ? notesList[2] : notesList[1]; // for two voice backward compatibility, ensure upper voice is stems up\n    // for three voices, the voices must be in order (upper, middle, lower)\n\n    if (voices === 2 && noteU.stemDirection === -1 && noteL.stemDirection === 1) {\n      noteU = notesList[1];\n      noteL = notesList[0];\n    }\n\n    const voiceXShift = Math.max(noteU.voice_shift, noteL.voice_shift);\n    let xShift = 0;\n    let stemDelta; // Test for two voice note intersection\n\n    if (voices === 2) {\n      const lineSpacing = noteU.stemDirection === noteL.stemDirection ? 0.0 : 0.5; // if top voice is a middle voice, check stem intersection with lower voice\n\n      if (noteU.stemDirection === noteL.stemDirection && noteU.minLine <= noteL.maxLine) {\n        if (!noteU.isrest) {\n          stemDelta = Math.abs(noteU.line - (noteL.maxLine + 0.5));\n          stemDelta = Math.max(stemDelta, noteU.stemMin);\n          noteU.minLine = noteU.line - stemDelta;\n          noteU.note.setStemLength(stemDelta * 10);\n        }\n      }\n\n      if (noteU.minLine <= noteL.maxLine + lineSpacing) {\n        if (noteU.isrest) {\n          // shift rest up\n          shiftRestVertical(noteU, noteL, 1);\n        } else if (noteL.isrest) {\n          // shift rest down\n          shiftRestVertical(noteL, noteU, -1);\n        } else {\n          xShift = voiceXShift;\n\n          if (noteU.stemDirection === noteL.stemDirection) {\n            // upper voice is middle voice, so shift it right\n            noteU.note.setXShift(xShift + 3);\n          } else {\n            // shift lower voice right\n            noteL.note.setXShift(xShift);\n          }\n        }\n      } // format complete\n\n\n      return true;\n    } // Check middle voice stem intersection with lower voice\n\n\n    if (noteM !== null && noteM.minLine < noteL.maxLine + 0.5) {\n      if (!noteM.isrest) {\n        stemDelta = Math.abs(noteM.line - (noteL.maxLine + 0.5));\n        stemDelta = Math.max(stemDelta, noteM.stemMin);\n        noteM.minLine = noteM.line - stemDelta;\n        noteM.note.setStemLength(stemDelta * 10);\n      }\n    } // For three voices, test if rests can be repositioned\n    //\n    // Special case 1 :: middle voice rest between two notes\n    //\n\n\n    if (noteM.isrest && !noteU.isrest && !noteL.isrest) {\n      if (noteU.minLine <= noteM.maxLine || noteM.minLine <= noteL.maxLine) {\n        const restHeight = noteM.maxLine - noteM.minLine;\n        const space = noteU.minLine - noteL.maxLine;\n\n        if (restHeight < space) {\n          // center middle voice rest between the upper and lower voices\n          centerRest(noteM, noteU, noteL);\n        } else {\n          xShift = voiceXShift + 3; // shift middle rest right\n\n          noteM.note.setXShift(xShift);\n        } // format complete\n\n\n        return true;\n      }\n    } // Special case 2 :: all voices are rests\n\n\n    if (noteU.isrest && noteM.isrest && noteL.isrest) {\n      // Shift upper voice rest up\n      shiftRestVertical(noteU, noteM, 1); // Shift lower voice rest down\n\n      shiftRestVertical(noteL, noteM, -1); // format complete\n\n      return true;\n    } // Test if any other rests can be repositioned\n\n\n    if (noteM.isrest && noteU.isrest && noteM.minLine <= noteL.maxLine) {\n      // Shift middle voice rest up\n      shiftRestVertical(noteM, noteL, 1);\n    }\n\n    if (noteM.isrest && noteL.isrest && noteU.minLine <= noteM.maxLine) {\n      // Shift middle voice rest down\n      shiftRestVertical(noteM, noteU, -1);\n    }\n\n    if (noteU.isrest && noteU.minLine <= noteM.maxLine) {\n      // shift upper voice rest up;\n      shiftRestVertical(noteU, noteM, 1);\n    }\n\n    if (noteL.isrest && noteM.minLine <= noteL.maxLine) {\n      // shift lower voice rest down\n      shiftRestVertical(noteL, noteM, -1);\n    } // If middle voice intersects upper or lower voice\n\n\n    if (!noteU.isrest && !noteM.isrest && noteU.minLine <= noteM.maxLine + 0.5 || !noteM.isrest && !noteL.isrest && noteM.minLine <= noteL.maxLine) {\n      xShift = voiceXShift + 3; // shift middle note right\n\n      noteM.note.setXShift(xShift);\n    }\n\n    return true;\n  }\n\n  static formatByY(notes, state) {\n    // NOTE: this function does not support more than two voices per stave\n    // use with care.\n    let hasStave = true;\n\n    for (let i = 0; i < notes.length; i++) {\n      hasStave = hasStave && notes[i].getStave() != null;\n    }\n\n    if (!hasStave) {\n      throw new Vex.RERR('Stave Missing', 'All notes must have a stave - Vex.Flow.ModifierContext.formatMultiVoice!');\n    }\n\n    let xShift = 0;\n\n    for (let i = 0; i < notes.length - 1; i++) {\n      let topNote = notes[i];\n      let bottomNote = notes[i + 1];\n\n      if (topNote.getStemDirection() === Stem.DOWN) {\n        topNote = notes[i + 1];\n        bottomNote = notes[i];\n      }\n\n      const topKeys = topNote.getKeyProps();\n      const bottomKeys = bottomNote.getKeyProps();\n      const HALF_NOTEHEAD_HEIGHT = 0.5; // `keyProps` and `stave.getYForLine` have different notions of a `line`\n      // so we have to convert the keyProps value by subtracting 5.\n      // See https://github.com/0xfe/vexflow/wiki/Development-Gotchas\n      //\n      // We also extend the y for each note by a half notehead because the\n      // notehead's origin is centered\n\n      const topNoteBottomY = topNote.getStave().getYForLine(5 - topKeys[0].line + HALF_NOTEHEAD_HEIGHT);\n      const bottomNoteTopY = bottomNote.getStave().getYForLine(5 - bottomKeys[bottomKeys.length - 1].line - HALF_NOTEHEAD_HEIGHT);\n      const areNotesColliding = bottomNoteTopY - topNoteBottomY < 0;\n\n      if (areNotesColliding) {\n        xShift = topNote.getVoiceShiftWidth() + 2;\n        bottomNote.setXShift(xShift);\n      }\n    }\n\n    state.right_shift += xShift;\n  }\n\n  static postFormat(notes) {\n    if (!notes) return false;\n    notes.forEach(note => note.postFormat());\n    return true;\n  }\n\n  constructor(noteStruct) {\n    super(noteStruct);\n    this.setAttribute('type', 'StaveNote');\n    this.keys = noteStruct.keys;\n    this.clef = noteStruct.clef;\n    this.octave_shift = noteStruct.octave_shift;\n    this.beam = null; // Pull note rendering properties\n\n    this.glyph = Flow.getGlyphProps(this.duration, this.noteType);\n\n    if (!this.glyph) {\n      throw new Vex.RuntimeError('BadArguments', `Invalid note initialization data (No glyph found): ${JSON.stringify(noteStruct)}`);\n    } // if true, displace note to right\n\n\n    this.displaced = false;\n    this.dot_shiftY = 0; // per-pitch properties\n\n    this.keyProps = []; // for displaced ledger lines\n\n    this.use_default_head_x = false; // Drawing\n\n    this.note_heads = [];\n    this.modifiers = [];\n    Vex.Merge(this.render_options, {\n      // font size for note heads and rests\n      glyph_font_scale: noteStruct.glyph_font_scale || Flow.DEFAULT_NOTATION_FONT_SCALE,\n      // number of stroke px to the left and right of head\n      stroke_px: noteStruct.stroke_px || StaveNote.DEFAULT_LEDGER_LINE_OFFSET\n    });\n    this.calculateKeyProps();\n    this.buildStem(); // Set the stem direction\n\n    if (noteStruct.auto_stem) {\n      this.autoStem();\n    } else {\n      this.setStemDirection(noteStruct.stem_direction);\n    }\n\n    this.reset();\n    this.buildFlag();\n  }\n\n  reset() {\n    super.reset(); // Save prior noteHead styles & reapply them after making new noteheads.\n\n    const noteHeadStyles = this.note_heads.map(noteHead => noteHead.getStyle());\n    this.buildNoteHeads();\n    this.note_heads.forEach((noteHead, index) => noteHead.setStyle(noteHeadStyles[index]));\n\n    if (this.stave) {\n      this.note_heads.forEach(head => head.setStave(this.stave));\n    }\n\n    this.calcNoteDisplacements();\n  }\n\n  setBeam(beam) {\n    this.beam = beam;\n    this.calcNoteDisplacements();\n    return this;\n  }\n\n  getCategory() {\n    return StaveNote.CATEGORY;\n  } // Builds a `Stem` for the note\n\n\n  buildStem() {\n    this.setStem(new Stem({\n      hide: !!this.isRest()\n    }));\n  } // Builds a `NoteHead` for each key in the note\n\n\n  buildNoteHeads() {\n    this.note_heads = [];\n    const stemDirection = this.getStemDirection();\n    const keys = this.getKeys();\n    let lastLine = null;\n    let lineDiff = null;\n    let displaced = false; // Draw notes from bottom to top.\n    // For down-stem notes, we draw from top to bottom.\n\n    let start;\n    let end;\n    let step;\n\n    if (stemDirection === Stem.UP) {\n      start = 0;\n      end = keys.length;\n      step = 1;\n    } else if (stemDirection === Stem.DOWN) {\n      start = keys.length - 1;\n      end = -1;\n      step = -1;\n    }\n\n    for (let i = start; i !== end; i += step) {\n      const noteProps = this.keyProps[i];\n      const line = noteProps.line; // Keep track of last line with a note head, so that consecutive heads\n      // are correctly displaced.\n\n      if (lastLine === null) {\n        lastLine = line;\n      } else {\n        lineDiff = Math.abs(lastLine - line);\n\n        if (lineDiff === 0 || lineDiff === 0.5) {\n          displaced = !displaced;\n        } else {\n          displaced = false;\n          this.use_default_head_x = true;\n        }\n      }\n\n      lastLine = line;\n      const notehead = new NoteHead({\n        duration: this.duration,\n        note_type: this.noteType,\n        displaced,\n        stem_direction: stemDirection,\n        custom_glyph_code: noteProps.code,\n        glyph_font_scale: this.render_options.glyph_font_scale,\n        x_shift: noteProps.shift_right,\n        stem_up_x_offset: noteProps.stem_up_x_offset,\n        stem_down_x_offset: noteProps.stem_down_x_offset,\n        line: noteProps.line\n      });\n      this.note_heads[i] = notehead;\n    }\n  } // Automatically sets the stem direction based on the keys in the note\n\n\n  autoStem() {\n    // Figure out optimal stem direction based on given notes\n    this.minLine = this.keyProps[0].line;\n    this.maxLine = this.keyProps[this.keyProps.length - 1].line;\n    const MIDDLE_LINE = 3;\n    const decider = (this.minLine + this.maxLine) / 2;\n    const stemDirection = decider < MIDDLE_LINE ? Stem.UP : Stem.DOWN;\n    this.setStemDirection(stemDirection);\n  } // Calculates and stores the properties for each key in the note\n\n\n  calculateKeyProps() {\n    let lastLine = null;\n\n    for (let i = 0; i < this.keys.length; ++i) {\n      const key = this.keys[i]; // All rests use the same position on the line.\n      // if (this.glyph.rest) key = this.glyph.position;\n\n      if (this.glyph.rest) this.glyph.position = key;\n      const options = {\n        octave_shift: this.octave_shift || 0\n      };\n      const props = Flow.keyProperties(key, this.clef, options);\n\n      if (!props) {\n        throw new Vex.RuntimeError('BadArguments', `Invalid key for note properties: ${key}`);\n      } // Override line placement for default rests\n\n\n      if (props.key === 'R') {\n        if (this.duration === '1' || this.duration === 'w') {\n          props.line = 4;\n        } else {\n          props.line = 3;\n        }\n      } // Calculate displacement of this note\n\n\n      const line = props.line;\n\n      if (lastLine === null) {\n        lastLine = line;\n      } else {\n        if (Math.abs(lastLine - line) === 0.5) {\n          this.displaced = true;\n          props.displaced = true; // Have to mark the previous note as\n          // displaced as well, for modifier placement\n\n          if (this.keyProps.length > 0) {\n            this.keyProps[i - 1].displaced = true;\n          }\n        }\n      }\n\n      lastLine = line;\n      this.keyProps.push(props);\n    } // Sort the notes from lowest line to highest line\n\n\n    lastLine = -Infinity;\n    this.keyProps.forEach(key => {\n      if (key.line < lastLine) {\n        Vex.W('Unsorted keys in note will be sorted. ' + 'See https://github.com/0xfe/vexflow/issues/104 for details.');\n      }\n\n      lastLine = key.line;\n    });\n    this.keyProps.sort((a, b) => a.line - b.line);\n  } // Get the `BoundingBox` for the entire note\n\n\n  getBoundingBox() {\n    if (!this.preFormatted) {\n      throw new Vex.RERR('UnformattedNote', \"Can't call getBoundingBox on an unformatted note.\");\n    }\n\n    const {\n      width: w,\n      modLeftPx,\n      leftDisplacedHeadPx\n    } = this.getMetrics();\n    const x = this.getAbsoluteX() - modLeftPx - leftDisplacedHeadPx;\n    let minY = 0;\n    let maxY = 0;\n    const halfLineSpacing = this.getStave().getSpacingBetweenLines() / 2;\n    const lineSpacing = halfLineSpacing * 2;\n\n    if (this.isRest()) {\n      const y = this.ys[0];\n      const frac = Flow.durationToFraction(this.duration);\n\n      if (frac.equals(1) || frac.equals(2)) {\n        minY = y - halfLineSpacing;\n        maxY = y + halfLineSpacing;\n      } else {\n        minY = y - this.glyph.line_above * lineSpacing;\n        maxY = y + this.glyph.line_below * lineSpacing;\n      }\n    } else if (this.glyph.stem) {\n      const ys = this.getStemExtents();\n      ys.baseY += halfLineSpacing * this.stem_direction;\n      minY = Math.min(ys.topY, ys.baseY);\n      maxY = Math.max(ys.topY, ys.baseY);\n    } else {\n      minY = null;\n      maxY = null;\n\n      for (let i = 0; i < this.ys.length; ++i) {\n        const yy = this.ys[i];\n\n        if (i === 0) {\n          minY = yy;\n          maxY = yy;\n        } else {\n          minY = Math.min(yy, minY);\n          maxY = Math.max(yy, maxY);\n        }\n      }\n\n      minY -= halfLineSpacing;\n      maxY += halfLineSpacing;\n    }\n\n    return new BoundingBox(x, minY, w, maxY - minY);\n  } // Gets the line number of the top or bottom note in the chord.\n  // If `isTopNote` is `true` then get the top note\n\n\n  getLineNumber(isTopNote) {\n    if (!this.keyProps.length) {\n      throw new Vex.RERR('NoKeyProps', \"Can't get bottom note line, because note is not initialized properly.\");\n    }\n\n    let resultLine = this.keyProps[0].line; // No precondition assumed for sortedness of keyProps array\n\n    for (let i = 0; i < this.keyProps.length; i++) {\n      const thisLine = this.keyProps[i].line;\n\n      if (isTopNote) {\n        if (thisLine > resultLine) resultLine = thisLine;\n      } else {\n        if (thisLine < resultLine) resultLine = thisLine;\n      }\n    }\n\n    return resultLine;\n  } // Determine if current note is a rest\n\n\n  isRest() {\n    return this.glyph.rest;\n  } // Determine if the current note is a chord\n\n\n  isChord() {\n    return !this.isRest() && this.keys.length > 1;\n  } // Determine if the `StaveNote` has a stem\n\n\n  hasStem() {\n    return this.glyph.stem;\n  }\n\n  hasFlag() {\n    return super.hasFlag() && !this.isRest();\n  }\n\n  getStemX() {\n    if (this.noteType === 'r') {\n      return this.getCenterGlyphX();\n    } else {\n      // We adjust the origin of the stem because we want the stem left-aligned\n      // with the notehead if stemmed-down, and right-aligned if stemmed-up\n      return super.getStemX() + getStemAdjustment(this);\n    }\n  } // Get the `y` coordinate for text placed on the top/bottom of a\n  // note at a desired `text_line`\n\n\n  getYForTopText(textLine) {\n    const extents = this.getStemExtents();\n    return Math.min(this.stave.getYForTopText(textLine), extents.topY - this.render_options.annotation_spacing * (textLine + 1));\n  }\n\n  getYForBottomText(textLine) {\n    const extents = this.getStemExtents();\n    return Math.max(this.stave.getYForTopText(textLine), extents.baseY + this.render_options.annotation_spacing * textLine);\n  } // Sets the current note to the provided `stave`. This applies\n  // `y` values to the `NoteHeads`.\n\n\n  setStave(stave) {\n    super.setStave(stave);\n    const ys = this.note_heads.map(notehead => {\n      notehead.setStave(stave);\n      return notehead.getY();\n    });\n    this.setYs(ys);\n\n    if (this.stem) {\n      const {\n        y_top,\n        y_bottom\n      } = this.getNoteHeadBounds();\n      this.stem.setYBounds(y_top, y_bottom);\n    }\n\n    return this;\n  } // Get the pitches in the note\n\n\n  getKeys() {\n    return this.keys;\n  } // Get the properties for all the keys in the note\n\n\n  getKeyProps() {\n    return this.keyProps;\n  } // Check if note is shifted to the right\n\n\n  isDisplaced() {\n    return this.displaced;\n  } // Sets whether shift note to the right. `displaced` is a `boolean`\n\n\n  setNoteDisplaced(displaced) {\n    this.displaced = displaced;\n    return this;\n  } // Get the starting `x` coordinate for a `StaveTie`\n\n\n  getTieRightX() {\n    let tieStartX = this.getAbsoluteX();\n    tieStartX += this.getGlyphWidth() + this.x_shift + this.rightDisplacedHeadPx;\n    if (this.modifierContext) tieStartX += this.modifierContext.getRightShift();\n    return tieStartX;\n  } // Get the ending `x` coordinate for a `StaveTie`\n\n\n  getTieLeftX() {\n    let tieEndX = this.getAbsoluteX();\n    tieEndX += this.x_shift - this.leftDisplacedHeadPx;\n    return tieEndX;\n  } // Get the stave line on which to place a rest\n\n\n  getLineForRest() {\n    let restLine = this.keyProps[0].line;\n\n    if (this.keyProps.length > 1) {\n      const lastLine = this.keyProps[this.keyProps.length - 1].line;\n      const top = Math.max(restLine, lastLine);\n      const bot = Math.min(restLine, lastLine);\n      restLine = Vex.MidLine(top, bot);\n    }\n\n    return restLine;\n  } // Get the default `x` and `y` coordinates for the provided `position`\n  // and key `index`\n\n\n  getModifierStartXY(position, index, options) {\n    options = options || {};\n\n    if (!this.preFormatted) {\n      throw new Vex.RERR('UnformattedNote', \"Can't call GetModifierStartXY on an unformatted note\");\n    }\n\n    if (this.ys.length === 0) {\n      throw new Vex.RERR('NoYValues', 'No Y-Values calculated for this note.');\n    }\n\n    const {\n      ABOVE,\n      BELOW,\n      LEFT,\n      RIGHT\n    } = Modifier.Position;\n    let x = 0;\n\n    if (position === LEFT) {\n      // FIXME: Left modifier padding, move to font file\n      x = -1 * 2;\n    } else if (position === RIGHT) {\n      // FIXME: Right modifier padding, move to font file\n      x = this.getGlyphWidth() + this.x_shift + 2;\n\n      if (this.stem_direction === Stem.UP && this.hasFlag() && (options.forceFlagRight || isInnerNoteIndex(this, index))) {\n        x += this.flag.getMetrics().width;\n      }\n    } else if (position === BELOW || position === ABOVE) {\n      x = this.getGlyphWidth() / 2;\n    }\n\n    return {\n      x: this.getAbsoluteX() + x,\n      y: this.ys[index]\n    };\n  } // Sets the style of the complete StaveNote, including all keys\n  // and the stem.\n\n\n  setStyle(style) {\n    super.setStyle(style);\n    this.note_heads.forEach(notehead => notehead.setStyle(style));\n    this.stem.setStyle(style);\n  }\n\n  setStemStyle(style) {\n    const stem = this.getStem();\n    stem.setStyle(style);\n  }\n\n  getStemStyle() {\n    return this.stem.getStyle();\n  }\n\n  setLedgerLineStyle(style) {\n    this.ledgerLineStyle = style;\n  }\n\n  getLedgerLineStyle() {\n    return this.ledgerLineStyle;\n  }\n\n  setFlagStyle(style) {\n    this.flagStyle = style;\n  }\n\n  getFlagStyle() {\n    return this.flagStyle;\n  } // Sets the notehead at `index` to the provided coloring `style`.\n  //\n  // `style` is an `object` with the following properties: `shadowColor`,\n  // `shadowBlur`, `fillStyle`, `strokeStyle`\n\n\n  setKeyStyle(index, style) {\n    this.note_heads[index].setStyle(style);\n    return this;\n  }\n\n  setKeyLine(index, line) {\n    this.keyProps[index].line = line;\n    this.reset();\n    return this;\n  }\n\n  getKeyLine(index) {\n    return this.keyProps[index].line;\n  } // Add self to modifier context. `mContext` is the `ModifierContext`\n  // to be added to.\n\n\n  addToModifierContext(mContext) {\n    this.setModifierContext(mContext);\n\n    for (let i = 0; i < this.modifiers.length; ++i) {\n      this.modifierContext.addModifier(this.modifiers[i]);\n    }\n\n    this.modifierContext.addModifier(this);\n    this.setPreFormatted(false);\n    return this;\n  } // Generic function to add modifiers to a note\n  //\n  // Parameters:\n  // * `index`: The index of the key that we're modifying\n  // * `modifier`: The modifier to add\n\n\n  addModifier(index, modifier) {\n    modifier.setNote(this);\n    modifier.setIndex(index);\n    this.modifiers.push(modifier);\n    this.setPreFormatted(false);\n    return this;\n  } // Helper function to add an accidental to a key\n\n\n  addAccidental(index, accidental) {\n    return this.addModifier(index, accidental);\n  } // Helper function to add an articulation to a key\n\n\n  addArticulation(index, articulation) {\n    return this.addModifier(index, articulation);\n  } // Helper function to add an annotation to a key\n\n\n  addAnnotation(index, annotation) {\n    return this.addModifier(index, annotation);\n  } // Helper function to add a dot on a specific key\n\n\n  addDot(index) {\n    const dot = new Dot();\n    dot.setDotShiftY(this.glyph.dot_shiftY);\n    this.dots++;\n    return this.addModifier(index, dot);\n  } // Convenience method to add dot to all keys in note\n\n\n  addDotToAll() {\n    for (let i = 0; i < this.keys.length; ++i) {\n      this.addDot(i);\n    }\n\n    return this;\n  } // Get all accidentals in the `ModifierContext`\n\n\n  getAccidentals() {\n    return this.modifierContext.getModifiers('accidentals');\n  } // Get all dots in the `ModifierContext`\n\n\n  getDots() {\n    return this.modifierContext.getModifiers('dots');\n  } // Get the width of the note if it is displaced. Used for `Voice`\n  // formatting\n\n\n  getVoiceShiftWidth() {\n    // TODO: may need to accomodate for dot here.\n    return this.getGlyphWidth() * (this.displaced ? 2 : 1);\n  } // Calculates and sets the extra pixels to the left or right\n  // if the note is displaced.\n\n\n  calcNoteDisplacements() {\n    this.setLeftDisplacedHeadPx(this.displaced && this.stem_direction === Stem.DOWN ? this.getGlyphWidth() : 0); // For upstems with flags, the extra space is unnecessary, since it's taken\n    // up by the flag.\n\n    this.setRightDisplacedHeadPx(!this.hasFlag() && this.displaced && this.stem_direction === Stem.UP ? this.getGlyphWidth() : 0);\n  } // Pre-render formatting\n\n\n  preFormat() {\n    if (this.preFormatted) return;\n    if (this.modifierContext) this.modifierContext.preFormat();\n    let width = this.getGlyphWidth() + this.leftDisplacedHeadPx + this.rightDisplacedHeadPx; // For upward flagged notes, the width of the flag needs to be added\n\n    if (this.glyph.flag && this.beam === null && this.stem_direction === Stem.UP) {\n      width += this.getGlyphWidth(); // TODO: Add flag width as a separate metric\n    }\n\n    this.setWidth(width);\n    this.setPreFormatted(true);\n  }\n  /**\n   * @typedef {Object} noteHeadBounds\n   * @property {number} y_top the highest notehead bound\n   * @property {number} y_bottom the lowest notehead bound\n   * @property {number|Null} displaced_x the starting x for displaced noteheads\n   * @property {number|Null} non_displaced_x the starting x for non-displaced noteheads\n   * @property {number} highest_line the highest notehead line in traditional music line\n   *  numbering (bottom line = 1, top line = 5)\n   * @property {number} lowest_line the lowest notehead line\n   * @property {number|false} highest_displaced_line the highest staff line number\n   *   for a displaced notehead\n   * @property {number|false} lowest_displaced_line\n   * @property {number} highest_non_displaced_line\n   * @property {number} lowest_non_displaced_line\n   */\n\n  /**\n   * Get the staff line and y value for the highest & lowest noteheads\n   * @returns {noteHeadBounds}\n   */\n\n\n  getNoteHeadBounds() {\n    // Top and bottom Y values for stem.\n    let yTop = null;\n    let yBottom = null;\n    let nonDisplacedX = null;\n    let displacedX = null;\n    let highestLine = this.stave.getNumLines();\n    let lowestLine = 1;\n    let highestDisplacedLine = false;\n    let lowestDisplacedLine = false;\n    let highestNonDisplacedLine = highestLine;\n    let lowestNonDisplacedLine = lowestLine;\n    this.note_heads.forEach(notehead => {\n      const line = notehead.getLine();\n      const y = notehead.getY();\n\n      if (yTop === null || y < yTop) {\n        yTop = y;\n      }\n\n      if (yBottom === null || y > yBottom) {\n        yBottom = y;\n      }\n\n      if (displacedX === null && notehead.isDisplaced()) {\n        displacedX = notehead.getAbsoluteX();\n      }\n\n      if (nonDisplacedX === null && !notehead.isDisplaced()) {\n        nonDisplacedX = notehead.getAbsoluteX();\n      }\n\n      highestLine = line > highestLine ? line : highestLine;\n      lowestLine = line < lowestLine ? line : lowestLine;\n\n      if (notehead.isDisplaced()) {\n        highestDisplacedLine = highestDisplacedLine === false ? line : Math.max(line, highestDisplacedLine);\n        lowestDisplacedLine = lowestDisplacedLine === false ? line : Math.min(line, lowestDisplacedLine);\n      } else {\n        highestNonDisplacedLine = Math.max(line, highestNonDisplacedLine);\n        lowestNonDisplacedLine = Math.min(line, lowestNonDisplacedLine);\n      }\n    }, this);\n    return {\n      y_top: yTop,\n      y_bottom: yBottom,\n      displaced_x: displacedX,\n      non_displaced_x: nonDisplacedX,\n      highest_line: highestLine,\n      lowest_line: lowestLine,\n      highest_displaced_line: highestDisplacedLine,\n      lowest_displaced_line: lowestDisplacedLine,\n      highest_non_displaced_line: highestNonDisplacedLine,\n      lowest_non_displaced_line: lowestNonDisplacedLine\n    };\n  } // Get the starting `x` coordinate for the noteheads\n\n\n  getNoteHeadBeginX() {\n    return this.getAbsoluteX() + this.x_shift;\n  } // Get the ending `x` coordinate for the noteheads\n\n\n  getNoteHeadEndX() {\n    const xBegin = this.getNoteHeadBeginX();\n    return xBegin + this.getGlyphWidth();\n  } // Draw the ledger lines between the stave and the highest/lowest keys\n\n\n  drawLedgerLines() {\n    const {\n      stave,\n      glyph,\n      render_options: {\n        stroke_px\n      },\n      context: ctx\n    } = this;\n    const width = glyph.getWidth() + stroke_px * 2;\n    const doubleWidth = 2 * (glyph.getWidth() + stroke_px) - Stem.WIDTH / 2;\n    if (this.isRest()) return;\n\n    if (!ctx) {\n      throw new Vex.RERR('NoCanvasContext', \"Can't draw without a canvas context.\");\n    }\n\n    const {\n      highest_line,\n      lowest_line,\n      highest_displaced_line,\n      highest_non_displaced_line,\n      lowest_displaced_line,\n      lowest_non_displaced_line,\n      displaced_x,\n      non_displaced_x\n    } = this.getNoteHeadBounds();\n    const min_x = Math.min(displaced_x, non_displaced_x);\n\n    const drawLedgerLine = (y, normal, displaced) => {\n      let x;\n      if (displaced && normal) x = min_x - stroke_px;else if (normal) x = non_displaced_x - stroke_px;else x = displaced_x - stroke_px;\n      const ledgerWidth = normal && displaced ? doubleWidth : width;\n      ctx.beginPath();\n      ctx.moveTo(x, y);\n      ctx.lineTo(x + ledgerWidth, y);\n      ctx.stroke();\n    };\n\n    const style = { ...(stave.getStyle() || {}),\n      ...(this.getLedgerLineStyle() || {})\n    };\n    this.applyStyle(ctx, style); // Draw ledger lines below the staff:\n\n    for (let line = 6; line <= highest_line; ++line) {\n      const normal = non_displaced_x !== null && line <= highest_non_displaced_line;\n      const displaced = displaced_x !== null && line <= highest_displaced_line;\n      drawLedgerLine(stave.getYForNote(line), normal, displaced);\n    } // Draw ledger lines above the staff:\n\n\n    for (let line = 0; line >= lowest_line; --line) {\n      const normal = non_displaced_x !== null && line >= lowest_non_displaced_line;\n      const displaced = displaced_x !== null && line >= lowest_displaced_line;\n      drawLedgerLine(stave.getYForNote(line), normal, displaced);\n    }\n\n    this.restoreStyle(ctx, style);\n  } // Draw all key modifiers\n\n\n  drawModifiers() {\n    if (!this.context) {\n      throw new Vex.RERR('NoCanvasContext', \"Can't draw without a canvas context.\");\n    }\n\n    const ctx = this.context;\n    ctx.openGroup('modifiers');\n\n    for (let i = 0; i < this.modifiers.length; i++) {\n      const modifier = this.modifiers[i];\n      const notehead = this.note_heads[modifier.getIndex()];\n      const noteheadStyle = notehead.getStyle();\n      notehead.applyStyle(ctx, noteheadStyle);\n      modifier.setContext(ctx);\n      modifier.drawWithStyle();\n      notehead.restoreStyle(ctx, noteheadStyle);\n    }\n\n    ctx.closeGroup();\n  } // Draw the flag for the note\n\n\n  drawFlag() {\n    const {\n      stem,\n      beam,\n      context: ctx\n    } = this;\n\n    if (!ctx) {\n      throw new Vex.RERR('NoCanvasContext', \"Can't draw without a canvas context.\");\n    }\n\n    const shouldRenderFlag = beam === null;\n    const glyph = this.getGlyph();\n\n    if (glyph.flag && shouldRenderFlag) {\n      const {\n        y_top,\n        y_bottom\n      } = this.getNoteHeadBounds();\n      const noteStemHeight = stem.getHeight();\n      const flagX = this.getStemX(); // FIXME: What's with the magic +/- 2\n\n      const flagY = this.getStemDirection() === Stem.DOWN // Down stems have flags on the left\n      ? y_top - noteStemHeight + 2 // Up stems have flags on the eft.\n      : y_bottom - noteStemHeight - 2; // Draw the Flag\n\n      ctx.openGroup('flag', null, {\n        pointerBBox: true\n      });\n      this.applyStyle(ctx, this.getFlagStyle() || false);\n      this.flag.render(ctx, flagX, flagY);\n      this.restoreStyle(ctx, this.getFlagStyle() || false);\n      ctx.closeGroup();\n    }\n  } // Draw the NoteHeads\n\n\n  drawNoteHeads() {\n    this.note_heads.forEach(notehead => {\n      this.context.openGroup('notehead', null, {\n        pointerBBox: true\n      });\n      notehead.setContext(this.context).draw();\n      this.context.closeGroup();\n    });\n  }\n\n  drawStem(stemStruct) {\n    // GCR TODO: I can't find any context in which this is called with the stemStruct\n    // argument in the codebase or tests. Nor can I find a case where super.drawStem\n    // is called at all. Perhaps these should be removed?\n    if (!this.context) {\n      throw new Vex.RERR('NoCanvasContext', \"Can't draw without a canvas context.\");\n    }\n\n    if (stemStruct) {\n      this.setStem(new Stem(stemStruct));\n    }\n\n    this.context.openGroup('stem', null, {\n      pointerBBox: true\n    });\n    this.stem.setContext(this.context).draw();\n    this.context.closeGroup();\n  } // Draws all the `StaveNote` parts. This is the main drawing method.\n\n\n  draw() {\n    if (!this.context) {\n      throw new Vex.RERR('NoCanvasContext', \"Can't draw without a canvas context.\");\n    }\n\n    if (!this.stave) {\n      throw new Vex.RERR('NoStave', \"Can't draw without a stave.\");\n    }\n\n    if (this.ys.length === 0) {\n      throw new Vex.RERR('NoYValues', \"Can't draw note without Y values.\");\n    }\n\n    const xBegin = this.getNoteHeadBeginX();\n    const shouldRenderStem = this.hasStem() && !this.beam; // Format note head x positions\n\n    this.note_heads.forEach(notehead => notehead.setX(xBegin)); // Format stem x positions\n\n    const stemX = this.getStemX();\n    this.stem.setNoteHeadXBounds(stemX, stemX);\n    L('Rendering ', this.isChord() ? 'chord :' : 'note :', this.keys); // Draw each part of the note\n\n    this.drawLedgerLines(); // Apply the overall style -- may be contradicted by local settings:\n\n    this.applyStyle();\n    this.setAttribute('el', this.context.openGroup('stavenote', this.getAttribute('id')));\n    this.context.openGroup('note', null, {\n      pointerBBox: true\n    });\n    if (shouldRenderStem) this.drawStem();\n    this.drawNoteHeads();\n    this.drawFlag();\n    this.context.closeGroup();\n    this.drawModifiers();\n    this.context.closeGroup();\n    this.restoreStyle();\n    this.setRendered();\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/stavenote.js"],"names":["Vex","Flow","BoundingBox","Stem","NoteHead","StemmableNote","Modifier","Dot","L","args","StaveNote","DEBUG","getStemAdjustment","note","WIDTH","getStemDirection","isInnerNoteIndex","index","UP","keyProps","length","shiftRestVertical","rest","dir","delta","isrest","line","maxLine","minLine","setKeyLine","getKeyLine","centerRest","noteU","noteL","MidLine","CATEGORY","STEM_UP","STEM_DOWN","DOWN","DEFAULT_LEDGER_LINE_OFFSET","format","notes","state","getStave","formatByY","notesList","i","props","getKeyProps","minL","stemDirection","stemMax","getStemLength","stemMin","getStemMinumumLength","maxL","isRest","glyph","line_above","line_below","push","voice_shift","getVoiceShiftWidth","is_displaced","isDisplaced","voices","noteM","voiceXShift","Math","max","xShift","stemDelta","lineSpacing","abs","setStemLength","setXShift","restHeight","space","hasStave","RERR","topNote","bottomNote","topKeys","bottomKeys","HALF_NOTEHEAD_HEIGHT","topNoteBottomY","getYForLine","bottomNoteTopY","areNotesColliding","right_shift","postFormat","forEach","constructor","noteStruct","setAttribute","keys","clef","octave_shift","beam","getGlyphProps","duration","noteType","RuntimeError","JSON","stringify","displaced","dot_shiftY","use_default_head_x","note_heads","modifiers","Merge","render_options","glyph_font_scale","DEFAULT_NOTATION_FONT_SCALE","stroke_px","calculateKeyProps","buildStem","auto_stem","autoStem","setStemDirection","stem_direction","reset","buildFlag","noteHeadStyles","map","noteHead","getStyle","buildNoteHeads","setStyle","stave","head","setStave","calcNoteDisplacements","setBeam","getCategory","setStem","hide","getKeys","lastLine","lineDiff","start","end","step","noteProps","notehead","note_type","custom_glyph_code","code","x_shift","shift_right","stem_up_x_offset","stem_down_x_offset","MIDDLE_LINE","decider","key","position","options","keyProperties","Infinity","W","sort","a","b","getBoundingBox","preFormatted","width","w","modLeftPx","leftDisplacedHeadPx","getMetrics","x","getAbsoluteX","minY","maxY","halfLineSpacing","getSpacingBetweenLines","y","ys","frac","durationToFraction","equals","stem","getStemExtents","baseY","min","topY","yy","getLineNumber","isTopNote","resultLine","thisLine","isChord","hasStem","hasFlag","getStemX","getCenterGlyphX","getYForTopText","textLine","extents","annotation_spacing","getYForBottomText","getY","setYs","y_top","y_bottom","getNoteHeadBounds","setYBounds","setNoteDisplaced","getTieRightX","tieStartX","getGlyphWidth","rightDisplacedHeadPx","modifierContext","getRightShift","getTieLeftX","tieEndX","getLineForRest","restLine","top","bot","getModifierStartXY","ABOVE","BELOW","LEFT","RIGHT","Position","forceFlagRight","flag","style","setStemStyle","getStem","getStemStyle","setLedgerLineStyle","ledgerLineStyle","getLedgerLineStyle","setFlagStyle","flagStyle","getFlagStyle","setKeyStyle","addToModifierContext","mContext","setModifierContext","addModifier","setPreFormatted","modifier","setNote","setIndex","addAccidental","accidental","addArticulation","articulation","addAnnotation","annotation","addDot","dot","setDotShiftY","dots","addDotToAll","getAccidentals","getModifiers","getDots","setLeftDisplacedHeadPx","setRightDisplacedHeadPx","preFormat","setWidth","yTop","yBottom","nonDisplacedX","displacedX","highestLine","getNumLines","lowestLine","highestDisplacedLine","lowestDisplacedLine","highestNonDisplacedLine","lowestNonDisplacedLine","getLine","displaced_x","non_displaced_x","highest_line","lowest_line","highest_displaced_line","lowest_displaced_line","highest_non_displaced_line","lowest_non_displaced_line","getNoteHeadBeginX","getNoteHeadEndX","xBegin","drawLedgerLines","context","ctx","getWidth","doubleWidth","min_x","drawLedgerLine","normal","ledgerWidth","beginPath","moveTo","lineTo","stroke","applyStyle","getYForNote","restoreStyle","drawModifiers","openGroup","getIndex","noteheadStyle","setContext","drawWithStyle","closeGroup","drawFlag","shouldRenderFlag","getGlyph","noteStemHeight","getHeight","flagX","flagY","pointerBBox","render","drawNoteHeads","draw","drawStem","stemStruct","shouldRenderStem","setX","stemX","setNoteHeadXBounds","getAttribute","setRendered"],"mappings":"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","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n// This file implements notes for standard notation. This consists of one or\n// more `NoteHeads`, an optional stem, and an optional flag.\n//\n// *Throughout these comments, a \"note\" refers to the entire `StaveNote`,\n// and a \"key\" refers to a specific pitch/notehead within a note.*\n//\n// See `tests/stavenote_tests.js` for usage examples.\n\nimport { Vex } from './vex';\nimport { Flow } from './tables';\nimport { BoundingBox } from './boundingbox';\nimport { Stem } from './stem';\nimport { NoteHead } from './notehead';\nimport { StemmableNote } from './stemmablenote';\nimport { Modifier } from './modifier';\nimport { Dot } from './dot';\n\n// To enable logging for this class. Set `Vex.Flow.StaveNote.DEBUG` to `true`.\nfunction L(...args) { if (StaveNote.DEBUG) Vex.L('Vex.Flow.StaveNote', args); }\n\nconst getStemAdjustment = (note) => Stem.WIDTH / (2 * -note.getStemDirection());\n\nconst isInnerNoteIndex = (note, index) =>\n  index === (note.getStemDirection() === Stem.UP ? note.keyProps.length - 1 : 0);\n\n// Helper methods for rest positioning in ModifierContext.\nfunction shiftRestVertical(rest, note, dir) {\n  const delta = (note.isrest ? 0.0 : 1.0) * dir;\n\n  rest.line += delta;\n  rest.maxLine += delta;\n  rest.minLine += delta;\n  rest.note.setKeyLine(0, rest.note.getKeyLine(0) + (delta));\n}\n\n// Called from formatNotes :: center a rest between two notes\nfunction centerRest(rest, noteU, noteL) {\n  const delta = rest.line - Vex.MidLine(noteU.minLine, noteL.maxLine);\n  rest.note.setKeyLine(0, rest.note.getKeyLine(0) - delta);\n  rest.line -= delta;\n  rest.maxLine -= delta;\n  rest.minLine -= delta;\n}\n\nexport class StaveNote extends StemmableNote {\n  static get CATEGORY() { return 'stavenotes'; }\n  static get STEM_UP() { return Stem.UP; }\n  static get STEM_DOWN() { return Stem.DOWN; }\n  static get DEFAULT_LEDGER_LINE_OFFSET() { return 3; }\n\n  // ## Static Methods\n  //\n  // Format notes inside a ModifierContext.\n  static format(notes, state) {\n    if (!notes || notes.length < 2) return false;\n\n    // FIXME: VexFlow will soon require that a stave be set before formatting.\n    // Which, according to the below condition, means that following branch will\n    // always be taken and the rest of this function is dead code.\n    //\n    // Problematically, `Formatter#formatByY` was not designed to work for more\n    // than 2 voices (although, doesn't throw on this condition, just tries\n    // to power through).\n    //\n    // Based on the above:\n    //   * 2 voices can be formatted *with or without* a stave being set but\n    //     the output will be different\n    //   * 3 voices can only be formatted *without* a stave\n    if (notes[0].getStave()) {\n      return StaveNote.formatByY(notes, state);\n    }\n\n    const notesList = [];\n\n    for (let i = 0; i < notes.length; i++) {\n      const props = notes[i].getKeyProps();\n      const line = props[0].line;\n      let minL = props[props.length - 1].line;\n      const stemDirection = notes[i].getStemDirection();\n      const stemMax = notes[i].getStemLength() / 10;\n      const stemMin = notes[i].getStemMinumumLength() / 10;\n\n      let maxL;\n      if (notes[i].isRest()) {\n        maxL = line + notes[i].glyph.line_above;\n        minL = line - notes[i].glyph.line_below;\n      } else {\n        maxL = stemDirection === 1\n          ? props[props.length - 1].line + stemMax\n          : props[props.length - 1].line;\n\n        minL = stemDirection === 1\n          ? props[0].line\n          : props[0].line - stemMax;\n      }\n\n      notesList.push({\n        line: props[0].line, // note/rest base line\n        maxLine: maxL, // note/rest upper bounds line\n        minLine: minL, // note/rest lower bounds line\n        isrest: notes[i].isRest(),\n        stemDirection,\n        stemMax, // Maximum (default) note stem length;\n        stemMin, // minimum note stem length\n        voice_shift: notes[i].getVoiceShiftWidth(),\n        is_displaced: notes[i].isDisplaced(), // note manually displaced\n        note: notes[i],\n      });\n    }\n\n    const voices = notesList.length;\n\n    let noteU = notesList[0];\n    const noteM = voices > 2 ? notesList[1] : null;\n    let noteL = voices > 2 ? notesList[2] : notesList[1];\n\n    // for two voice backward compatibility, ensure upper voice is stems up\n    // for three voices, the voices must be in order (upper, middle, lower)\n    if (voices === 2 && noteU.stemDirection === -1 && noteL.stemDirection === 1) {\n      noteU = notesList[1];\n      noteL = notesList[0];\n    }\n\n    const voiceXShift = Math.max(noteU.voice_shift, noteL.voice_shift);\n    let xShift = 0;\n    let stemDelta;\n\n    // Test for two voice note intersection\n    if (voices === 2) {\n      const lineSpacing = noteU.stemDirection === noteL.stemDirection ? 0.0 : 0.5;\n      // if top voice is a middle voice, check stem intersection with lower voice\n      if (noteU.stemDirection === noteL.stemDirection &&\n        noteU.minLine <= noteL.maxLine) {\n        if (!noteU.isrest) {\n          stemDelta = Math.abs(noteU.line - (noteL.maxLine + 0.5));\n          stemDelta = Math.max(stemDelta, noteU.stemMin);\n          noteU.minLine = noteU.line - stemDelta;\n          noteU.note.setStemLength(stemDelta * 10);\n        }\n      }\n      if (noteU.minLine <= noteL.maxLine + lineSpacing) {\n        if (noteU.isrest) {\n          // shift rest up\n          shiftRestVertical(noteU, noteL, 1);\n        } else if (noteL.isrest) {\n          // shift rest down\n          shiftRestVertical(noteL, noteU, -1);\n        } else {\n          xShift = voiceXShift;\n          if (noteU.stemDirection === noteL.stemDirection) {\n            // upper voice is middle voice, so shift it right\n            noteU.note.setXShift(xShift + 3);\n          } else {\n            // shift lower voice right\n            noteL.note.setXShift(xShift);\n          }\n        }\n      }\n\n      // format complete\n      return true;\n    }\n\n    // Check middle voice stem intersection with lower voice\n    if (noteM !== null && noteM.minLine < noteL.maxLine + 0.5) {\n      if (!noteM.isrest) {\n        stemDelta = Math.abs(noteM.line - (noteL.maxLine + 0.5));\n        stemDelta = Math.max(stemDelta, noteM.stemMin);\n        noteM.minLine = noteM.line - stemDelta;\n        noteM.note.setStemLength(stemDelta * 10);\n      }\n    }\n\n    // For three voices, test if rests can be repositioned\n    //\n    // Special case 1 :: middle voice rest between two notes\n    //\n    if (noteM.isrest && !noteU.isrest && !noteL.isrest) {\n      if (noteU.minLine <= noteM.maxLine || noteM.minLine <= noteL.maxLine) {\n        const restHeight = noteM.maxLine - noteM.minLine;\n        const space = noteU.minLine - noteL.maxLine;\n        if (restHeight < space) {\n          // center middle voice rest between the upper and lower voices\n          centerRest(noteM, noteU, noteL);\n        } else {\n          xShift = voiceXShift + 3;    // shift middle rest right\n          noteM.note.setXShift(xShift);\n        }\n        // format complete\n        return true;\n      }\n    }\n\n    // Special case 2 :: all voices are rests\n    if (noteU.isrest && noteM.isrest && noteL.isrest) {\n      // Shift upper voice rest up\n      shiftRestVertical(noteU, noteM, 1);\n      // Shift lower voice rest down\n      shiftRestVertical(noteL, noteM, -1);\n      // format complete\n      return true;\n    }\n\n    // Test if any other rests can be repositioned\n    if (noteM.isrest && noteU.isrest && noteM.minLine <= noteL.maxLine) {\n      // Shift middle voice rest up\n      shiftRestVertical(noteM, noteL, 1);\n    }\n    if (noteM.isrest && noteL.isrest && noteU.minLine <= noteM.maxLine) {\n      // Shift middle voice rest down\n      shiftRestVertical(noteM, noteU, -1);\n    }\n    if (noteU.isrest && noteU.minLine <= noteM.maxLine) {\n      // shift upper voice rest up;\n      shiftRestVertical(noteU, noteM, 1);\n    }\n    if (noteL.isrest && noteM.minLine <= noteL.maxLine) {\n      // shift lower voice rest down\n      shiftRestVertical(noteL, noteM, -1);\n    }\n\n    // If middle voice intersects upper or lower voice\n    if ((!noteU.isrest && !noteM.isrest && noteU.minLine <= noteM.maxLine + 0.5) ||\n      (!noteM.isrest && !noteL.isrest && noteM.minLine <= noteL.maxLine)) {\n      xShift = voiceXShift + 3;      // shift middle note right\n      noteM.note.setXShift(xShift);\n    }\n\n    return true;\n  }\n\n  static formatByY(notes, state) {\n    // NOTE: this function does not support more than two voices per stave\n    // use with care.\n    let hasStave = true;\n\n    for (let i = 0; i < notes.length; i++) {\n      hasStave = hasStave && notes[i].getStave() != null;\n    }\n\n    if (!hasStave) {\n      throw new Vex.RERR(\n        'Stave Missing',\n        'All notes must have a stave - Vex.Flow.ModifierContext.formatMultiVoice!'\n      );\n    }\n\n    let xShift = 0;\n\n    for (let i = 0; i < notes.length - 1; i++) {\n      let topNote = notes[i];\n      let bottomNote = notes[i + 1];\n\n      if (topNote.getStemDirection() === Stem.DOWN) {\n        topNote = notes[i + 1];\n        bottomNote = notes[i];\n      }\n\n      const topKeys = topNote.getKeyProps();\n      const bottomKeys = bottomNote.getKeyProps();\n\n      const HALF_NOTEHEAD_HEIGHT = 0.5;\n\n      // `keyProps` and `stave.getYForLine` have different notions of a `line`\n      // so we have to convert the keyProps value by subtracting 5.\n      // See https://github.com/0xfe/vexflow/wiki/Development-Gotchas\n      //\n      // We also extend the y for each note by a half notehead because the\n      // notehead's origin is centered\n      const topNoteBottomY = topNote\n        .getStave()\n        .getYForLine(5 - topKeys[0].line + HALF_NOTEHEAD_HEIGHT);\n\n      const bottomNoteTopY = bottomNote\n        .getStave()\n        .getYForLine(5 - bottomKeys[bottomKeys.length - 1].line - HALF_NOTEHEAD_HEIGHT);\n\n      const areNotesColliding = bottomNoteTopY - topNoteBottomY < 0;\n\n      if (areNotesColliding) {\n        xShift = topNote.getVoiceShiftWidth() + 2;\n        bottomNote.setXShift(xShift);\n      }\n    }\n\n    state.right_shift += xShift;\n  }\n\n  static postFormat(notes) {\n    if (!notes) return false;\n\n    notes.forEach(note => note.postFormat());\n\n    return true;\n  }\n\n  constructor(noteStruct) {\n    super(noteStruct);\n    this.setAttribute('type', 'StaveNote');\n\n    this.keys = noteStruct.keys;\n    this.clef = noteStruct.clef;\n    this.octave_shift = noteStruct.octave_shift;\n    this.beam = null;\n\n    // Pull note rendering properties\n    this.glyph = Flow.getGlyphProps(this.duration, this.noteType);\n\n    if (!this.glyph) {\n      throw new Vex.RuntimeError(\n        'BadArguments',\n        `Invalid note initialization data (No glyph found): ${JSON.stringify(noteStruct)}`\n      );\n    }\n\n    // if true, displace note to right\n    this.displaced = false;\n    this.dot_shiftY = 0;\n    // per-pitch properties\n    this.keyProps = [];\n    // for displaced ledger lines\n    this.use_default_head_x = false;\n\n    // Drawing\n    this.note_heads = [];\n    this.modifiers = [];\n\n    Vex.Merge(this.render_options, {\n      // font size for note heads and rests\n      glyph_font_scale: noteStruct.glyph_font_scale || Flow.DEFAULT_NOTATION_FONT_SCALE,\n      // number of stroke px to the left and right of head\n      stroke_px: noteStruct.stroke_px || StaveNote.DEFAULT_LEDGER_LINE_OFFSET,\n    });\n\n    this.calculateKeyProps();\n    this.buildStem();\n\n    // Set the stem direction\n    if (noteStruct.auto_stem) {\n      this.autoStem();\n    } else {\n      this.setStemDirection(noteStruct.stem_direction);\n    }\n    this.reset();\n    this.buildFlag();\n  }\n\n  reset() {\n    super.reset();\n\n    // Save prior noteHead styles & reapply them after making new noteheads.\n    const noteHeadStyles = this.note_heads.map(noteHead => noteHead.getStyle());\n    this.buildNoteHeads();\n    this.note_heads.forEach((noteHead, index) => noteHead.setStyle(noteHeadStyles[index]));\n\n    if (this.stave) {\n      this.note_heads.forEach(head => head.setStave(this.stave));\n    }\n    this.calcNoteDisplacements();\n  }\n\n  setBeam(beam) {\n    this.beam = beam;\n    this.calcNoteDisplacements();\n    return this;\n  }\n\n  getCategory() { return StaveNote.CATEGORY; }\n\n  // Builds a `Stem` for the note\n  buildStem() {\n    this.setStem(new Stem({ hide: !!this.isRest(), }));\n  }\n\n  // Builds a `NoteHead` for each key in the note\n  buildNoteHeads() {\n    this.note_heads = [];\n    const stemDirection = this.getStemDirection();\n    const keys = this.getKeys();\n\n    let lastLine = null;\n    let lineDiff = null;\n    let displaced = false;\n\n    // Draw notes from bottom to top.\n\n    // For down-stem notes, we draw from top to bottom.\n    let start;\n    let end;\n    let step;\n    if (stemDirection === Stem.UP) {\n      start = 0;\n      end = keys.length;\n      step = 1;\n    } else if (stemDirection === Stem.DOWN) {\n      start = keys.length - 1;\n      end = -1;\n      step = -1;\n    }\n\n    for (let i = start; i !== end; i += step) {\n      const noteProps = this.keyProps[i];\n      const line = noteProps.line;\n\n      // Keep track of last line with a note head, so that consecutive heads\n      // are correctly displaced.\n      if (lastLine === null) {\n        lastLine = line;\n      } else {\n        lineDiff = Math.abs(lastLine - line);\n        if (lineDiff === 0 || lineDiff === 0.5) {\n          displaced = !displaced;\n        } else {\n          displaced = false;\n          this.use_default_head_x = true;\n        }\n      }\n      lastLine = line;\n\n      const notehead = new NoteHead({\n        duration: this.duration,\n        note_type: this.noteType,\n        displaced,\n        stem_direction: stemDirection,\n        custom_glyph_code: noteProps.code,\n        glyph_font_scale: this.render_options.glyph_font_scale,\n        x_shift: noteProps.shift_right,\n        stem_up_x_offset: noteProps.stem_up_x_offset,\n        stem_down_x_offset: noteProps.stem_down_x_offset,\n        line: noteProps.line,\n      });\n\n      this.note_heads[i] = notehead;\n    }\n  }\n\n  // Automatically sets the stem direction based on the keys in the note\n  autoStem() {\n    // Figure out optimal stem direction based on given notes\n    this.minLine = this.keyProps[0].line;\n    this.maxLine = this.keyProps[this.keyProps.length - 1].line;\n\n    const MIDDLE_LINE = 3;\n    const decider = (this.minLine + this.maxLine) / 2;\n    const stemDirection = decider < MIDDLE_LINE ? Stem.UP : Stem.DOWN;\n\n    this.setStemDirection(stemDirection);\n  }\n\n  // Calculates and stores the properties for each key in the note\n  calculateKeyProps() {\n    let lastLine = null;\n    for (let i = 0; i < this.keys.length; ++i) {\n      const key = this.keys[i];\n\n      // All rests use the same position on the line.\n      // if (this.glyph.rest) key = this.glyph.position;\n      if (this.glyph.rest) this.glyph.position = key;\n\n      const options = { octave_shift: this.octave_shift || 0 };\n      const props = Flow.keyProperties(key, this.clef, options);\n\n      if (!props) {\n        throw new Vex.RuntimeError('BadArguments', `Invalid key for note properties: ${key}`);\n      }\n\n      // Override line placement for default rests\n      if (props.key === 'R') {\n        if (this.duration === '1' || this.duration === 'w') {\n          props.line = 4;\n        } else {\n          props.line = 3;\n        }\n      }\n\n      // Calculate displacement of this note\n      const line = props.line;\n      if (lastLine === null) {\n        lastLine = line;\n      } else {\n        if (Math.abs(lastLine - line) === 0.5) {\n          this.displaced = true;\n          props.displaced = true;\n\n          // Have to mark the previous note as\n          // displaced as well, for modifier placement\n          if (this.keyProps.length > 0) {\n            this.keyProps[i - 1].displaced = true;\n          }\n        }\n      }\n\n      lastLine = line;\n      this.keyProps.push(props);\n    }\n\n    // Sort the notes from lowest line to highest line\n    lastLine = -Infinity;\n    this.keyProps.forEach(key => {\n      if (key.line < lastLine) {\n        Vex.W(\n          'Unsorted keys in note will be sorted. ' +\n          'See https://github.com/0xfe/vexflow/issues/104 for details.'\n        );\n      }\n      lastLine = key.line;\n    });\n    this.keyProps.sort((a, b) => a.line - b.line);\n  }\n\n  // Get the `BoundingBox` for the entire note\n  getBoundingBox() {\n    if (!this.preFormatted) {\n      throw new Vex.RERR('UnformattedNote', \"Can't call getBoundingBox on an unformatted note.\");\n    }\n\n    const { width: w, modLeftPx, leftDisplacedHeadPx } = this.getMetrics();\n    const x = this.getAbsoluteX() - modLeftPx - leftDisplacedHeadPx;\n\n    let minY = 0;\n    let maxY = 0;\n    const halfLineSpacing = this.getStave().getSpacingBetweenLines() / 2;\n    const lineSpacing = halfLineSpacing * 2;\n\n    if (this.isRest()) {\n      const y = this.ys[0];\n      const frac = Flow.durationToFraction(this.duration);\n      if (frac.equals(1) || frac.equals(2)) {\n        minY = y - halfLineSpacing;\n        maxY = y + halfLineSpacing;\n      } else {\n        minY = y - (this.glyph.line_above * lineSpacing);\n        maxY = y + (this.glyph.line_below * lineSpacing);\n      }\n    } else if (this.glyph.stem) {\n      const ys = this.getStemExtents();\n      ys.baseY += halfLineSpacing * this.stem_direction;\n      minY = Math.min(ys.topY, ys.baseY);\n      maxY = Math.max(ys.topY, ys.baseY);\n    } else {\n      minY = null;\n      maxY = null;\n\n      for (let i = 0; i < this.ys.length; ++i) {\n        const yy = this.ys[i];\n        if (i === 0) {\n          minY = yy;\n          maxY = yy;\n        } else {\n          minY = Math.min(yy, minY);\n          maxY = Math.max(yy, maxY);\n        }\n      }\n      minY -= halfLineSpacing;\n      maxY += halfLineSpacing;\n    }\n\n    return new BoundingBox(x, minY, w, maxY - minY);\n  }\n\n  // Gets the line number of the top or bottom note in the chord.\n  // If `isTopNote` is `true` then get the top note\n  getLineNumber(isTopNote) {\n    if (!this.keyProps.length) {\n      throw new Vex.RERR(\n        'NoKeyProps', \"Can't get bottom note line, because note is not initialized properly.\"\n      );\n    }\n\n    let resultLine = this.keyProps[0].line;\n\n    // No precondition assumed for sortedness of keyProps array\n    for (let i = 0; i < this.keyProps.length; i++) {\n      const thisLine = this.keyProps[i].line;\n      if (isTopNote) {\n        if (thisLine > resultLine) resultLine = thisLine;\n      } else {\n        if (thisLine < resultLine) resultLine = thisLine;\n      }\n    }\n\n    return resultLine;\n  }\n\n  // Determine if current note is a rest\n  isRest() { return this.glyph.rest; }\n\n  // Determine if the current note is a chord\n  isChord() { return !this.isRest() && this.keys.length > 1; }\n\n  // Determine if the `StaveNote` has a stem\n  hasStem() { return this.glyph.stem; }\n\n  hasFlag() {\n    return super.hasFlag() && !this.isRest();\n  }\n\n  getStemX() {\n    if (this.noteType === 'r') {\n      return this.getCenterGlyphX();\n    } else {\n      // We adjust the origin of the stem because we want the stem left-aligned\n      // with the notehead if stemmed-down, and right-aligned if stemmed-up\n      return super.getStemX() + getStemAdjustment(this);\n    }\n  }\n\n  // Get the `y` coordinate for text placed on the top/bottom of a\n  // note at a desired `text_line`\n  getYForTopText(textLine) {\n    const extents = this.getStemExtents();\n    return Math.min(\n      this.stave.getYForTopText(textLine),\n      extents.topY - (this.render_options.annotation_spacing * (textLine + 1))\n    );\n  }\n  getYForBottomText(textLine) {\n    const extents = this.getStemExtents();\n    return Math.max(\n      this.stave.getYForTopText(textLine),\n      extents.baseY + (this.render_options.annotation_spacing * (textLine))\n    );\n  }\n\n  // Sets the current note to the provided `stave`. This applies\n  // `y` values to the `NoteHeads`.\n  setStave(stave) {\n    super.setStave(stave);\n\n    const ys = this.note_heads.map(notehead => {\n      notehead.setStave(stave);\n      return notehead.getY();\n    });\n\n    this.setYs(ys);\n\n    if (this.stem) {\n      const { y_top, y_bottom } = this.getNoteHeadBounds();\n      this.stem.setYBounds(y_top, y_bottom);\n    }\n\n    return this;\n  }\n\n  // Get the pitches in the note\n  getKeys() { return this.keys; }\n\n  // Get the properties for all the keys in the note\n  getKeyProps() {\n    return this.keyProps;\n  }\n\n  // Check if note is shifted to the right\n  isDisplaced() {\n    return this.displaced;\n  }\n\n  // Sets whether shift note to the right. `displaced` is a `boolean`\n  setNoteDisplaced(displaced) {\n    this.displaced = displaced;\n    return this;\n  }\n\n  // Get the starting `x` coordinate for a `StaveTie`\n  getTieRightX() {\n    let tieStartX = this.getAbsoluteX();\n    tieStartX += this.getGlyphWidth() + this.x_shift + this.rightDisplacedHeadPx;\n    if (this.modifierContext) tieStartX += this.modifierContext.getRightShift();\n    return tieStartX;\n  }\n\n  // Get the ending `x` coordinate for a `StaveTie`\n  getTieLeftX() {\n    let tieEndX = this.getAbsoluteX();\n    tieEndX += this.x_shift - this.leftDisplacedHeadPx;\n    return tieEndX;\n  }\n\n  // Get the stave line on which to place a rest\n  getLineForRest() {\n    let restLine = this.keyProps[0].line;\n    if (this.keyProps.length > 1) {\n      const lastLine = this.keyProps[this.keyProps.length - 1].line;\n      const top = Math.max(restLine, lastLine);\n      const bot = Math.min(restLine, lastLine);\n      restLine = Vex.MidLine(top, bot);\n    }\n\n    return restLine;\n  }\n\n  // Get the default `x` and `y` coordinates for the provided `position`\n  // and key `index`\n  getModifierStartXY(position, index, options) {\n    options = options || {};\n    if (!this.preFormatted) {\n      throw new Vex.RERR('UnformattedNote', \"Can't call GetModifierStartXY on an unformatted note\");\n    }\n\n    if (this.ys.length === 0) {\n      throw new Vex.RERR('NoYValues', 'No Y-Values calculated for this note.');\n    }\n\n    const { ABOVE, BELOW, LEFT, RIGHT } = Modifier.Position;\n    let x = 0;\n    if (position === LEFT) {\n      // FIXME: Left modifier padding, move to font file\n      x = -1 * 2;\n    } else if (position === RIGHT) {\n      // FIXME: Right modifier padding, move to font file\n      x = this.getGlyphWidth() + this.x_shift + 2;\n\n      if (this.stem_direction === Stem.UP && this.hasFlag() &&\n        (options.forceFlagRight || isInnerNoteIndex(this, index))) {\n        x += this.flag.getMetrics().width;\n      }\n    } else if (position === BELOW || position === ABOVE) {\n      x = this.getGlyphWidth() / 2;\n    }\n\n    return {\n      x: this.getAbsoluteX() + x,\n      y: this.ys[index],\n    };\n  }\n\n  // Sets the style of the complete StaveNote, including all keys\n  // and the stem.\n  setStyle(style) {\n    super.setStyle(style);\n    this.note_heads.forEach(notehead => notehead.setStyle(style));\n    this.stem.setStyle(style);\n  }\n\n  setStemStyle(style) {\n    const stem = this.getStem();\n    stem.setStyle(style);\n  }\n  getStemStyle() { return this.stem.getStyle(); }\n\n  setLedgerLineStyle(style) { this.ledgerLineStyle = style; }\n  getLedgerLineStyle() { return this.ledgerLineStyle; }\n\n  setFlagStyle(style) { this.flagStyle = style; }\n  getFlagStyle() { return this.flagStyle; }\n\n  // Sets the notehead at `index` to the provided coloring `style`.\n  //\n  // `style` is an `object` with the following properties: `shadowColor`,\n  // `shadowBlur`, `fillStyle`, `strokeStyle`\n  setKeyStyle(index, style) {\n    this.note_heads[index].setStyle(style);\n    return this;\n  }\n\n  setKeyLine(index, line) {\n    this.keyProps[index].line = line;\n    this.reset();\n    return this;\n  }\n\n  getKeyLine(index) {\n    return this.keyProps[index].line;\n  }\n\n  // Add self to modifier context. `mContext` is the `ModifierContext`\n  // to be added to.\n  addToModifierContext(mContext) {\n    this.setModifierContext(mContext);\n    for (let i = 0; i < this.modifiers.length; ++i) {\n      this.modifierContext.addModifier(this.modifiers[i]);\n    }\n    this.modifierContext.addModifier(this);\n    this.setPreFormatted(false);\n    return this;\n  }\n\n  // Generic function to add modifiers to a note\n  //\n  // Parameters:\n  // * `index`: The index of the key that we're modifying\n  // * `modifier`: The modifier to add\n  addModifier(index, modifier) {\n    modifier.setNote(this);\n    modifier.setIndex(index);\n    this.modifiers.push(modifier);\n    this.setPreFormatted(false);\n    return this;\n  }\n\n  // Helper function to add an accidental to a key\n  addAccidental(index, accidental) {\n    return this.addModifier(index, accidental);\n  }\n\n  // Helper function to add an articulation to a key\n  addArticulation(index, articulation) {\n    return this.addModifier(index, articulation);\n  }\n\n  // Helper function to add an annotation to a key\n  addAnnotation(index, annotation) {\n    return this.addModifier(index, annotation);\n  }\n\n  // Helper function to add a dot on a specific key\n  addDot(index) {\n    const dot = new Dot();\n    dot.setDotShiftY(this.glyph.dot_shiftY);\n    this.dots++;\n    return this.addModifier(index, dot);\n  }\n\n  // Convenience method to add dot to all keys in note\n  addDotToAll() {\n    for (let i = 0; i < this.keys.length; ++i) {\n      this.addDot(i);\n    }\n    return this;\n  }\n\n  // Get all accidentals in the `ModifierContext`\n  getAccidentals() {\n    return this.modifierContext.getModifiers('accidentals');\n  }\n\n  // Get all dots in the `ModifierContext`\n  getDots() {\n    return this.modifierContext.getModifiers('dots');\n  }\n\n  // Get the width of the note if it is displaced. Used for `Voice`\n  // formatting\n  getVoiceShiftWidth() {\n    // TODO: may need to accomodate for dot here.\n    return this.getGlyphWidth() * (this.displaced ? 2 : 1);\n  }\n\n  // Calculates and sets the extra pixels to the left or right\n  // if the note is displaced.\n  calcNoteDisplacements() {\n    this.setLeftDisplacedHeadPx(\n      this.displaced && this.stem_direction === Stem.DOWN\n        ? this.getGlyphWidth()\n        : 0\n    );\n\n    // For upstems with flags, the extra space is unnecessary, since it's taken\n    // up by the flag.\n    this.setRightDisplacedHeadPx(\n      !this.hasFlag() && this.displaced && this.stem_direction === Stem.UP\n        ? this.getGlyphWidth()\n        : 0\n    );\n  }\n\n  // Pre-render formatting\n  preFormat() {\n    if (this.preFormatted) return;\n    if (this.modifierContext) this.modifierContext.preFormat();\n\n    let width = this.getGlyphWidth() + this.leftDisplacedHeadPx + this.rightDisplacedHeadPx;\n\n    // For upward flagged notes, the width of the flag needs to be added\n    if (this.glyph.flag && this.beam === null && this.stem_direction === Stem.UP) {\n      width += this.getGlyphWidth();\n      // TODO: Add flag width as a separate metric\n    }\n\n    this.setWidth(width);\n    this.setPreFormatted(true);\n  }\n\n  /**\n   * @typedef {Object} noteHeadBounds\n   * @property {number} y_top the highest notehead bound\n   * @property {number} y_bottom the lowest notehead bound\n   * @property {number|Null} displaced_x the starting x for displaced noteheads\n   * @property {number|Null} non_displaced_x the starting x for non-displaced noteheads\n   * @property {number} highest_line the highest notehead line in traditional music line\n   *  numbering (bottom line = 1, top line = 5)\n   * @property {number} lowest_line the lowest notehead line\n   * @property {number|false} highest_displaced_line the highest staff line number\n   *   for a displaced notehead\n   * @property {number|false} lowest_displaced_line\n   * @property {number} highest_non_displaced_line\n   * @property {number} lowest_non_displaced_line\n   */\n\n  /**\n   * Get the staff line and y value for the highest & lowest noteheads\n   * @returns {noteHeadBounds}\n   */\n  getNoteHeadBounds() {\n    // Top and bottom Y values for stem.\n    let yTop = null;\n    let yBottom = null;\n    let nonDisplacedX = null;\n    let displacedX = null;\n\n    let highestLine = this.stave.getNumLines();\n    let lowestLine = 1;\n    let highestDisplacedLine = false;\n    let lowestDisplacedLine = false;\n    let highestNonDisplacedLine = highestLine;\n    let lowestNonDisplacedLine = lowestLine;\n\n    this.note_heads.forEach(notehead => {\n      const line = notehead.getLine();\n      const y = notehead.getY();\n\n      if (yTop === null || y < yTop) {\n        yTop = y;\n      }\n\n      if (yBottom === null || y > yBottom) {\n        yBottom = y;\n      }\n\n      if (displacedX === null && notehead.isDisplaced()) {\n        displacedX = notehead.getAbsoluteX();\n      }\n\n      if (nonDisplacedX === null && !notehead.isDisplaced()) {\n        nonDisplacedX = notehead.getAbsoluteX();\n      }\n\n      highestLine = line > highestLine ? line : highestLine;\n      lowestLine = line < lowestLine ? line : lowestLine;\n\n      if (notehead.isDisplaced()) {\n        highestDisplacedLine = (highestDisplacedLine === false) ?\n          line : Math.max(line, highestDisplacedLine);\n        lowestDisplacedLine = (lowestDisplacedLine === false) ?\n          line : Math.min(line, lowestDisplacedLine);\n      } else {\n        highestNonDisplacedLine = Math.max(line, highestNonDisplacedLine);\n        lowestNonDisplacedLine = Math.min(line, lowestNonDisplacedLine);\n      }\n    }, this);\n\n    return {\n      y_top: yTop,\n      y_bottom: yBottom,\n      displaced_x: displacedX,\n      non_displaced_x: nonDisplacedX,\n      highest_line: highestLine,\n      lowest_line: lowestLine,\n      highest_displaced_line: highestDisplacedLine,\n      lowest_displaced_line: lowestDisplacedLine,\n      highest_non_displaced_line: highestNonDisplacedLine,\n      lowest_non_displaced_line: lowestNonDisplacedLine,\n    };\n  }\n\n  // Get the starting `x` coordinate for the noteheads\n  getNoteHeadBeginX() {\n    return this.getAbsoluteX() + this.x_shift;\n  }\n\n  // Get the ending `x` coordinate for the noteheads\n  getNoteHeadEndX() {\n    const xBegin = this.getNoteHeadBeginX();\n    return xBegin + this.getGlyphWidth();\n  }\n\n  // Draw the ledger lines between the stave and the highest/lowest keys\n  drawLedgerLines() {\n    const {\n      stave, glyph,\n      render_options: { stroke_px },\n      context: ctx,\n    } = this;\n\n    const width = glyph.getWidth() + (stroke_px * 2);\n    const doubleWidth = 2 * (glyph.getWidth() + stroke_px) - (Stem.WIDTH / 2);\n\n    if (this.isRest()) return;\n    if (!ctx) {\n      throw new Vex.RERR('NoCanvasContext', \"Can't draw without a canvas context.\");\n    }\n\n    const {\n      highest_line,\n      lowest_line,\n      highest_displaced_line,\n      highest_non_displaced_line,\n      lowest_displaced_line,\n      lowest_non_displaced_line,\n      displaced_x,\n      non_displaced_x,\n    } = this.getNoteHeadBounds();\n\n    const min_x = Math.min(displaced_x, non_displaced_x);\n\n    const drawLedgerLine = (y, normal, displaced) => {\n      let x;\n      if (displaced && normal) x = min_x - stroke_px;\n      else if (normal) x = non_displaced_x - stroke_px;\n      else x = displaced_x - stroke_px;\n      const ledgerWidth = (normal && displaced) ? doubleWidth : width;\n\n      ctx.beginPath();\n      ctx.moveTo(x, y);\n      ctx.lineTo(x + ledgerWidth, y);\n      ctx.stroke();\n    };\n\n    const style = { ...stave.getStyle() || {}, ...this.getLedgerLineStyle() || {} };\n    this.applyStyle(ctx, style);\n\n    // Draw ledger lines below the staff:\n    for (let line = 6; line <= highest_line; ++line) {\n      const normal = (non_displaced_x !== null) && (line <= highest_non_displaced_line);\n      const displaced = (displaced_x !== null) && (line <= highest_displaced_line);\n      drawLedgerLine(stave.getYForNote(line), normal, displaced);\n    }\n\n    // Draw ledger lines above the staff:\n    for (let line = 0; line >= lowest_line; --line) {\n      const normal = (non_displaced_x !== null) && (line >= lowest_non_displaced_line);\n      const displaced = (displaced_x !== null) && (line >= lowest_displaced_line);\n      drawLedgerLine(stave.getYForNote(line), normal, displaced);\n    }\n\n    this.restoreStyle(ctx, style);\n  }\n\n  // Draw all key modifiers\n  drawModifiers() {\n    if (!this.context) {\n      throw new Vex.RERR('NoCanvasContext', \"Can't draw without a canvas context.\");\n    }\n\n    const ctx = this.context;\n    ctx.openGroup('modifiers');\n    for (let i = 0; i < this.modifiers.length; i++) {\n      const modifier = this.modifiers[i];\n      const notehead = this.note_heads[modifier.getIndex()];\n      const noteheadStyle = notehead.getStyle();\n      notehead.applyStyle(ctx, noteheadStyle);\n      modifier.setContext(ctx);\n      modifier.drawWithStyle();\n      notehead.restoreStyle(ctx, noteheadStyle);\n    }\n    ctx.closeGroup();\n  }\n\n  // Draw the flag for the note\n  drawFlag() {\n    const { stem, beam, context: ctx } = this;\n\n    if (!ctx) {\n      throw new Vex.RERR('NoCanvasContext', \"Can't draw without a canvas context.\");\n    }\n\n    const shouldRenderFlag = beam === null;\n    const glyph = this.getGlyph();\n\n    if (glyph.flag && shouldRenderFlag) {\n      const { y_top, y_bottom } = this.getNoteHeadBounds();\n      const noteStemHeight = stem.getHeight();\n      const flagX = this.getStemX();\n      // FIXME: What's with the magic +/- 2\n      const flagY = this.getStemDirection() === Stem.DOWN\n        // Down stems have flags on the left\n        ? y_top - noteStemHeight + 2\n        // Up stems have flags on the eft.\n        : y_bottom - noteStemHeight - 2;\n\n      // Draw the Flag\n      ctx.openGroup('flag', null, { pointerBBox: true });\n      this.applyStyle(ctx, this.getFlagStyle() || false);\n      this.flag.render(ctx, flagX, flagY);\n      this.restoreStyle(ctx, this.getFlagStyle() || false);\n      ctx.closeGroup();\n    }\n  }\n\n  // Draw the NoteHeads\n  drawNoteHeads() {\n    this.note_heads.forEach(notehead => {\n      this.context.openGroup('notehead', null, { pointerBBox: true });\n      notehead.setContext(this.context).draw();\n      this.context.closeGroup();\n    });\n  }\n\n  drawStem(stemStruct) {\n    // GCR TODO: I can't find any context in which this is called with the stemStruct\n    // argument in the codebase or tests. Nor can I find a case where super.drawStem\n    // is called at all. Perhaps these should be removed?\n    if (!this.context) {\n      throw new Vex.RERR('NoCanvasContext', \"Can't draw without a canvas context.\");\n    }\n\n    if (stemStruct) {\n      this.setStem(new Stem(stemStruct));\n    }\n\n    this.context.openGroup('stem', null, { pointerBBox: true });\n    this.stem.setContext(this.context).draw();\n    this.context.closeGroup();\n  }\n\n  // Draws all the `StaveNote` parts. This is the main drawing method.\n  draw() {\n    if (!this.context) {\n      throw new Vex.RERR('NoCanvasContext', \"Can't draw without a canvas context.\");\n    }\n    if (!this.stave) {\n      throw new Vex.RERR('NoStave', \"Can't draw without a stave.\");\n    }\n    if (this.ys.length === 0) {\n      throw new Vex.RERR('NoYValues', \"Can't draw note without Y values.\");\n    }\n\n    const xBegin = this.getNoteHeadBeginX();\n    const shouldRenderStem = this.hasStem() && !this.beam;\n\n    // Format note head x positions\n    this.note_heads.forEach(notehead => notehead.setX(xBegin));\n\n    // Format stem x positions\n    const stemX = this.getStemX();\n    this.stem.setNoteHeadXBounds(stemX, stemX);\n\n    L('Rendering ', this.isChord() ? 'chord :' : 'note :', this.keys);\n\n    // Draw each part of the note\n    this.drawLedgerLines();\n\n    // Apply the overall style -- may be contradicted by local settings:\n    this.applyStyle();\n    this.setAttribute('el', this.context.openGroup('stavenote', this.getAttribute('id')));\n    this.context.openGroup('note', null, { pointerBBox: true });\n    if (shouldRenderStem) this.drawStem();\n    this.drawNoteHeads();\n    this.drawFlag();\n    this.context.closeGroup();\n    this.drawModifiers();\n    this.context.closeGroup();\n    this.restoreStyle();\n    this.setRendered();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}