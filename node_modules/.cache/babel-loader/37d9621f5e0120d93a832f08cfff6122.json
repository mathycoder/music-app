{"ast":null,"code":"// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// A generic text parsing class for VexFlow.\nimport { Vex } from './vex'; // To enable logging for this class. Set `Vex.Flow.Parser.DEBUG` to `true`.\n\nfunction L(...args) {\n  if (Parser.DEBUG) Vex.L('Vex.Flow.Parser', args);\n}\n\nexport const X = Vex.MakeException('ParserError'); // Converts parser results into an easy to reference list that can be\n// used in triggers.\n\nfunction flattenMatches(results) {\n  if (results.matchedString !== undefined) return results.matchedString;\n  if (results.results) return flattenMatches(results.results);\n  if (results.length === 1) return flattenMatches(results[0]);\n  if (results.length === 0) return null;\n  return results.map(flattenMatches);\n} // This is the base parser class. Given an arbitrary context-free grammar, it\n// can parse any line and execute code when specific rules are met (e.g.,\n// when a string is terminated.)\n\n\nexport class Parser {\n  // For an example of a simple grammar, take a look at tests/parser_tests.js or\n  // the EasyScore grammar in easyscore.js.\n  constructor(grammar) {\n    this.grammar = grammar;\n  } // Parse `line` using current grammar. Returns {success: true} if the\n  // line parsed correctly, otherwise returns `{success: false, errorPos: N}`\n  // where `errorPos` is the location of the error in the string.\n\n\n  parse(line) {\n    this.line = line;\n    this.pos = 0;\n    this.errorPos = -1;\n    const results = this.expect(this.grammar.begin());\n    results.errorPos = this.errorPos;\n    return results;\n  }\n\n  matchFail(returnPos) {\n    if (this.errorPos === -1) this.errorPos = this.pos;\n    this.pos = returnPos;\n  }\n\n  matchSuccess() {\n    this.errorPos = -1;\n  } // Look for `token` in this.line[this.pos], and return success\n  // if one is found. `token` is specified as a regular expression.\n\n\n  matchToken(token, noSpace = false) {\n    const regexp = noSpace ? new RegExp('^((' + token + '))') : new RegExp('^((' + token + ')\\\\s*)');\n    const workingLine = this.line.slice(this.pos);\n    const result = workingLine.match(regexp);\n\n    if (result !== null) {\n      return {\n        success: true,\n        matchedString: result[2],\n        incrementPos: result[1].length,\n        pos: this.pos\n      };\n    } else {\n      return {\n        success: false,\n        pos: this.pos\n      };\n    }\n  } // Execute rule to match a sequence of tokens (or rules). If `maybe` is\n  // set, then return success even if the token is not found, but reset\n  // the position before exiting.\n\n\n  expectOne(rule, maybe = false) {\n    const results = [];\n    const pos = this.pos;\n    let allMatches = true;\n    let oneMatch = false;\n    maybe = maybe === true || rule.maybe === true; // Execute all sub rules in sequence.\n\n    for (let i = 0; i < rule.expect.length; i++) {\n      const next = rule.expect[i];\n      const localPos = this.pos;\n      const result = this.expect(next); // If `rule.or` is set, then return success if any one\n      // of the subrules match, else all subrules must match.\n\n      if (result.success) {\n        results.push(result);\n        oneMatch = true;\n        if (rule.or) break;\n      } else {\n        allMatches = false;\n\n        if (!rule.or) {\n          this.pos = localPos;\n          break;\n        }\n      }\n    }\n\n    const gotOne = rule.or && oneMatch || allMatches;\n    const success = gotOne || maybe === true;\n    if (maybe && !gotOne) this.pos = pos;\n    if (success) this.matchSuccess();else this.matchFail(pos);\n    return {\n      success,\n      results,\n      numMatches: gotOne ? 1 : 0\n    };\n  } // Try to match multiple (one or more) instances of the rule. If `maybe` is set,\n  // then a failed match is also a success (but the position is reset).\n\n\n  expectOneOrMore(rule, maybe = false) {\n    const results = [];\n    const pos = this.pos;\n    let numMatches = 0;\n    let more = true;\n\n    do {\n      const result = this.expectOne(rule);\n\n      if (result.success) {\n        numMatches++;\n        results.push(result.results);\n      } else {\n        more = false;\n      }\n    } while (more);\n\n    const success = numMatches > 0 || maybe === true;\n    if (maybe && !(numMatches > 0)) this.pos = pos;\n    if (success) this.matchSuccess();else this.matchFail(pos);\n    return {\n      success,\n      results,\n      numMatches\n    };\n  } // Match zero or more instances of `rule`. Offloads to `expectOneOrMore`.\n\n\n  expectZeroOrMore(rule) {\n    return this.expectOneOrMore(rule, true);\n  } // Execute the rule produced by the provided the `rules` function. This\n  // ofloads to one of the above matchers and consolidates the results. It is also\n  // responsible for executing any code triggered by the rule (in `rule.run`.)\n\n\n  expect(rules) {\n    L('Evaluating rules:', rules);\n    let result;\n\n    if (!rules) {\n      throw new X('Invalid Rule: ' + rules, rules);\n    } // Get rule from Grammar class.\n\n\n    const rule = rules.bind(this.grammar)();\n\n    if (rule.token) {\n      // Base case: parse the regex and throw an error if the\n      // line doesn't match.\n      result = this.matchToken(rule.token, rule.noSpace === true);\n\n      if (result.success) {\n        // Token match! Update position and throw away parsed portion\n        // of string.\n        this.pos += result.incrementPos;\n      }\n    } else if (rule.expect) {\n      if (rule.oneOrMore) {\n        result = this.expectOneOrMore(rule);\n      } else if (rule.zeroOrMore) {\n        result = this.expectZeroOrMore(rule);\n      } else {\n        result = this.expectOne(rule);\n      }\n    } else {\n      throw new X('Bad grammar! No `token` or `expect` property', rule);\n    } // If there's a trigger attached to this rule, then pull it.\n\n\n    result.matches = [];\n    if (result.results) result.results.forEach(r => result.matches.push(flattenMatches(r)));\n    if (rule.run && result.success) rule.run(result);\n    return result;\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/parser.js"],"names":["Vex","L","args","Parser","DEBUG","X","MakeException","flattenMatches","results","matchedString","undefined","length","map","constructor","grammar","parse","line","pos","errorPos","expect","begin","matchFail","returnPos","matchSuccess","matchToken","token","noSpace","regexp","RegExp","workingLine","slice","result","match","success","incrementPos","expectOne","rule","maybe","allMatches","oneMatch","i","next","localPos","push","or","gotOne","numMatches","expectOneOrMore","more","expectZeroOrMore","rules","bind","oneOrMore","zeroOrMore","matches","forEach","r","run"],"mappings":"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","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// A generic text parsing class for VexFlow.\n\nimport { Vex } from './vex';\n\n// To enable logging for this class. Set `Vex.Flow.Parser.DEBUG` to `true`.\nfunction L(...args) { if (Parser.DEBUG) Vex.L('Vex.Flow.Parser', args); }\n\nexport const X = Vex.MakeException('ParserError');\n\n// Converts parser results into an easy to reference list that can be\n// used in triggers.\nfunction flattenMatches(results) {\n  if (results.matchedString !== undefined) return results.matchedString;\n  if (results.results) return flattenMatches(results.results);\n  if (results.length === 1) return flattenMatches(results[0]);\n  if (results.length === 0) return null;\n  return results.map(flattenMatches);\n}\n\n// This is the base parser class. Given an arbitrary context-free grammar, it\n// can parse any line and execute code when specific rules are met (e.g.,\n// when a string is terminated.)\nexport class Parser {\n  // For an example of a simple grammar, take a look at tests/parser_tests.js or\n  // the EasyScore grammar in easyscore.js.\n  constructor(grammar) {\n    this.grammar = grammar;\n  }\n\n  // Parse `line` using current grammar. Returns {success: true} if the\n  // line parsed correctly, otherwise returns `{success: false, errorPos: N}`\n  // where `errorPos` is the location of the error in the string.\n  parse(line) {\n    this.line = line;\n    this.pos = 0;\n    this.errorPos = -1;\n    const results = this.expect(this.grammar.begin());\n    results.errorPos = this.errorPos;\n    return results;\n  }\n\n  matchFail(returnPos) {\n    if (this.errorPos === -1) this.errorPos = this.pos;\n    this.pos = returnPos;\n  }\n\n  matchSuccess() {\n    this.errorPos = -1;\n  }\n\n  // Look for `token` in this.line[this.pos], and return success\n  // if one is found. `token` is specified as a regular expression.\n  matchToken(token, noSpace = false) {\n    const regexp = noSpace\n      ? new RegExp('^((' + token + '))')\n      : new RegExp('^((' + token + ')\\\\s*)');\n    const workingLine = this.line.slice(this.pos);\n    const result = workingLine.match(regexp);\n    if (result !== null) {\n      return {\n        success: true,\n        matchedString: result[2],\n        incrementPos: result[1].length,\n        pos: this.pos,\n      };\n    } else {\n      return {\n        success: false,\n        pos: this.pos,\n      };\n    }\n  }\n\n  // Execute rule to match a sequence of tokens (or rules). If `maybe` is\n  // set, then return success even if the token is not found, but reset\n  // the position before exiting.\n  expectOne(rule, maybe = false) {\n    const results = [];\n    const pos = this.pos;\n\n    let allMatches = true;\n    let oneMatch = false;\n    maybe = (maybe === true) || (rule.maybe === true);\n\n    // Execute all sub rules in sequence.\n    for (let i = 0; i < rule.expect.length; i++) {\n      const next = rule.expect[i];\n      const localPos = this.pos;\n      const result = this.expect(next);\n\n      // If `rule.or` is set, then return success if any one\n      // of the subrules match, else all subrules must match.\n      if (result.success) {\n        results.push(result);\n        oneMatch = true;\n        if (rule.or) break;\n      } else {\n        allMatches = false;\n        if (!rule.or) {\n          this.pos = localPos;\n          break;\n        }\n      }\n    }\n\n    const gotOne = (rule.or && oneMatch) || allMatches;\n    const success = gotOne || (maybe === true);\n    if (maybe && !gotOne) this.pos = pos;\n    if (success) this.matchSuccess(); else this.matchFail(pos);\n    return { success, results, numMatches: gotOne ? 1 : 0 };\n  }\n\n  // Try to match multiple (one or more) instances of the rule. If `maybe` is set,\n  // then a failed match is also a success (but the position is reset).\n  expectOneOrMore(rule, maybe = false) {\n    const results = [];\n    const pos = this.pos;\n    let numMatches = 0;\n    let more = true;\n\n    do {\n      const result = this.expectOne(rule);\n      if (result.success) {\n        numMatches++;\n        results.push(result.results);\n      } else {\n        more = false;\n      }\n    } while (more);\n\n    const success = (numMatches > 0) || (maybe === true);\n    if (maybe && !(numMatches > 0)) this.pos = pos;\n    if (success) this.matchSuccess(); else this.matchFail(pos);\n    return { success, results, numMatches };\n  }\n\n  // Match zero or more instances of `rule`. Offloads to `expectOneOrMore`.\n  expectZeroOrMore(rule) {\n    return this.expectOneOrMore(rule, true);\n  }\n\n  // Execute the rule produced by the provided the `rules` function. This\n  // ofloads to one of the above matchers and consolidates the results. It is also\n  // responsible for executing any code triggered by the rule (in `rule.run`.)\n  expect(rules) {\n    L('Evaluating rules:', rules);\n    let result;\n    if (!rules) {\n      throw new X('Invalid Rule: ' + rules, rules);\n    }\n\n    // Get rule from Grammar class.\n    const rule = rules.bind(this.grammar)();\n\n    if (rule.token) {\n      // Base case: parse the regex and throw an error if the\n      // line doesn't match.\n      result = this.matchToken(rule.token, (rule.noSpace === true));\n      if (result.success) {\n        // Token match! Update position and throw away parsed portion\n        // of string.\n        this.pos += result.incrementPos;\n      }\n    } else if (rule.expect) {\n      if (rule.oneOrMore) {\n        result = this.expectOneOrMore(rule);\n      } else if (rule.zeroOrMore) {\n        result = this.expectZeroOrMore(rule);\n      } else {\n        result = this.expectOne(rule);\n      }\n    } else {\n      throw new X('Bad grammar! No `token` or `expect` property', rule);\n    }\n\n    // If there's a trigger attached to this rule, then pull it.\n    result.matches = [];\n    if (result.results) result.results.forEach(r => result.matches.push(flattenMatches(r)));\n    if (rule.run && result.success) rule.run(result);\n    return result;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}