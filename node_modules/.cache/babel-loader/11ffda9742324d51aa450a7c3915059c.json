{"ast":null,"code":"// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n// Author: Larry Kuhns\n//\n// ## Description\n// This file implements the `StringNumber` class which renders string\n// number annotations beside notes.\nimport { Vex } from './vex';\nimport { Modifier } from './modifier';\nimport { Renderer } from './renderer';\nimport { StaveNote } from './stavenote';\nexport class StringNumber extends Modifier {\n  static get CATEGORY() {\n    return 'stringnumber';\n  } // ## Static Methods\n  // Arrange string numbers inside a `ModifierContext`\n\n\n  static format(nums, state) {\n    const left_shift = state.left_shift;\n    const right_shift = state.right_shift;\n    const num_spacing = 1;\n    if (!nums || nums.length === 0) return this;\n    const nums_list = [];\n    let prev_note = null;\n    let shift_left = 0;\n    let shift_right = 0;\n    let i;\n    let num;\n    let note;\n    let pos;\n\n    for (i = 0; i < nums.length; ++i) {\n      num = nums[i];\n      note = num.getNote();\n\n      for (i = 0; i < nums.length; ++i) {\n        num = nums[i];\n        note = num.getNote();\n        pos = num.getPosition();\n        const props = note.getKeyProps()[num.getIndex()];\n\n        if (note !== prev_note) {\n          for (let n = 0; n < note.keys.length; ++n) {\n            if (left_shift === 0) {\n              shift_left = Math.max(note.getLeftDisplacedHeadPx(), shift_left);\n            }\n\n            if (right_shift === 0) {\n              shift_right = Math.max(note.getRightDisplacedHeadPx(), shift_right);\n            }\n          }\n\n          prev_note = note;\n        }\n\n        nums_list.push({\n          pos,\n          note,\n          num,\n          line: props.line,\n          shiftL: shift_left,\n          shiftR: shift_right\n        });\n      }\n    } // Sort string numbers by line number.\n\n\n    nums_list.sort((a, b) => b.line - a.line); // TODO: This variable never gets assigned to anything. Is that a bug or can this be removed?\n\n    let num_shiftL = 0; // eslint-disable-line\n\n    let num_shiftR = 0;\n    let x_widthL = 0;\n    let x_widthR = 0;\n    let last_line = null;\n    let last_note = null;\n\n    for (i = 0; i < nums_list.length; ++i) {\n      let num_shift = 0;\n      note = nums_list[i].note;\n      pos = nums_list[i].pos;\n      num = nums_list[i].num;\n      const line = nums_list[i].line;\n      const shiftL = nums_list[i].shiftL;\n      const shiftR = nums_list[i].shiftR; // Reset the position of the string number every line.\n\n      if (line !== last_line || note !== last_note) {\n        num_shiftL = left_shift + shiftL;\n        num_shiftR = right_shift + shiftR;\n      }\n\n      const num_width = num.getWidth() + num_spacing;\n\n      if (pos === Modifier.Position.LEFT) {\n        num.setXShift(left_shift);\n        num_shift = shift_left + num_width; // spacing\n\n        x_widthL = num_shift > x_widthL ? num_shift : x_widthL;\n      } else if (pos === Modifier.Position.RIGHT) {\n        num.setXShift(num_shiftR);\n        num_shift += num_width; // spacing\n\n        x_widthR = num_shift > x_widthR ? num_shift : x_widthR;\n      }\n\n      last_line = line;\n      last_note = note;\n    }\n\n    state.left_shift += x_widthL;\n    state.right_shift += x_widthR;\n    return true;\n  }\n\n  constructor(number) {\n    super();\n    this.setAttribute('type', 'StringNumber');\n    this.note = null;\n    this.last_note = null;\n    this.index = null;\n    this.string_number = number;\n    this.setWidth(20); // ???\n\n    this.position = Modifier.Position.ABOVE; // Default position above stem or note head\n\n    this.x_shift = 0;\n    this.y_shift = 0;\n    this.x_offset = 0; // Horizontal offset from default\n\n    this.y_offset = 0; // Vertical offset from default\n\n    this.dashed = true; // true - draw dashed extension  false - no extension\n\n    this.leg = Renderer.LineEndType.NONE; // draw upward/downward leg at the of extension line\n\n    this.radius = 8;\n    this.font = {\n      family: 'sans-serif',\n      size: 10,\n      weight: 'bold'\n    };\n  }\n\n  getCategory() {\n    return StringNumber.CATEGORY;\n  }\n\n  getNote() {\n    return this.note;\n  }\n\n  setNote(note) {\n    this.note = note;\n    return this;\n  }\n\n  getIndex() {\n    return this.index;\n  }\n\n  setIndex(index) {\n    this.index = index;\n    return this;\n  }\n\n  setLineEndType(leg) {\n    if (leg >= Renderer.LineEndType.NONE && leg <= Renderer.LineEndType.DOWN) {\n      this.leg = leg;\n    }\n\n    return this;\n  }\n\n  setStringNumber(number) {\n    this.string_number = number;\n    return this;\n  }\n\n  setOffsetX(x) {\n    this.x_offset = x;\n    return this;\n  }\n\n  setOffsetY(y) {\n    this.y_offset = y;\n    return this;\n  }\n\n  setLastNote(note) {\n    this.last_note = note;\n    return this;\n  }\n\n  setDashed(dashed) {\n    this.dashed = dashed;\n    return this;\n  }\n\n  draw() {\n    const ctx = this.checkContext();\n\n    if (!(this.note && this.index != null)) {\n      throw new Vex.RERR('NoAttachedNote', \"Can't draw string number without a note and index.\");\n    }\n\n    this.setRendered();\n    const line_space = this.note.stave.options.spacing_between_lines_px;\n    const start = this.note.getModifierStartXY(this.position, this.index);\n    let dot_x = start.x + this.x_shift + this.x_offset;\n    let dot_y = start.y + this.y_shift + this.y_offset;\n\n    switch (this.position) {\n      case Modifier.Position.ABOVE:\n      case Modifier.Position.BELOW:\n        {\n          const stem_ext = this.note.getStemExtents();\n          let top = stem_ext.topY;\n          let bottom = stem_ext.baseY + 2;\n\n          if (this.note.stem_direction === StaveNote.STEM_DOWN) {\n            top = stem_ext.baseY;\n            bottom = stem_ext.topY - 2;\n          }\n\n          if (this.position === Modifier.Position.ABOVE) {\n            dot_y = this.note.hasStem() ? top - line_space * 1.75 : start.y - line_space * 1.75;\n          } else {\n            dot_y = this.note.hasStem() ? bottom + line_space * 1.5 : start.y + line_space * 1.75;\n          }\n\n          dot_y += this.y_shift + this.y_offset;\n          break;\n        }\n\n      case Modifier.Position.LEFT:\n        dot_x -= this.radius / 2 + 5;\n        break;\n\n      case Modifier.Position.RIGHT:\n        dot_x += this.radius / 2 + 6;\n        break;\n\n      default:\n        throw new Vex.RERR('InvalidPosition', `The position ${this.position} is invalid`);\n    }\n\n    ctx.save();\n    ctx.beginPath();\n    ctx.arc(dot_x, dot_y, this.radius, 0, Math.PI * 2, false);\n    ctx.lineWidth = 1.5;\n    ctx.stroke();\n    ctx.setFont(this.font.family, this.font.size, this.font.weight);\n    const x = dot_x - ctx.measureText(this.string_number).width / 2;\n    ctx.fillText('' + this.string_number, x, dot_y + 4.5);\n\n    if (this.last_note != null) {\n      const end = this.last_note.getStemX() - this.note.getX() + 5;\n      ctx.strokeStyle = '#000000';\n      ctx.lineCap = 'round';\n      ctx.lineWidth = 0.6;\n\n      if (this.dashed) {\n        Renderer.drawDashedLine(ctx, dot_x + 10, dot_y, dot_x + end, dot_y, [3, 3]);\n      } else {\n        Renderer.drawDashedLine(ctx, dot_x + 10, dot_y, dot_x + end, dot_y, [3, 0]);\n      }\n\n      let len;\n      let pattern;\n\n      switch (this.leg) {\n        case Renderer.LineEndType.UP:\n          len = -10;\n          pattern = this.dashed ? [3, 3] : [3, 0];\n          Renderer.drawDashedLine(ctx, dot_x + end, dot_y, dot_x + end, dot_y + len, pattern);\n          break;\n\n        case Renderer.LineEndType.DOWN:\n          len = 10;\n          pattern = this.dashed ? [3, 3] : [3, 0];\n          Renderer.drawDashedLine(ctx, dot_x + end, dot_y, dot_x + end, dot_y + len, pattern);\n          break;\n\n        default:\n          break;\n      }\n    }\n\n    ctx.restore();\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/stringnumber.js"],"names":["Vex","Modifier","Renderer","StaveNote","StringNumber","CATEGORY","format","nums","state","left_shift","right_shift","num_spacing","length","nums_list","prev_note","shift_left","shift_right","i","num","note","pos","getNote","getPosition","props","getKeyProps","getIndex","n","keys","Math","max","getLeftDisplacedHeadPx","getRightDisplacedHeadPx","push","line","shiftL","shiftR","sort","a","b","num_shiftL","num_shiftR","x_widthL","x_widthR","last_line","last_note","num_shift","num_width","getWidth","Position","LEFT","setXShift","RIGHT","constructor","number","setAttribute","index","string_number","setWidth","position","ABOVE","x_shift","y_shift","x_offset","y_offset","dashed","leg","LineEndType","NONE","radius","font","family","size","weight","getCategory","setNote","setIndex","setLineEndType","DOWN","setStringNumber","setOffsetX","x","setOffsetY","y","setLastNote","setDashed","draw","ctx","checkContext","RERR","setRendered","line_space","stave","options","spacing_between_lines_px","start","getModifierStartXY","dot_x","dot_y","BELOW","stem_ext","getStemExtents","top","topY","bottom","baseY","stem_direction","STEM_DOWN","hasStem","save","beginPath","arc","PI","lineWidth","stroke","setFont","measureText","width","fillText","end","getStemX","getX","strokeStyle","lineCap","drawDashedLine","len","pattern","UP","restore"],"mappings":"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","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n// Author: Larry Kuhns\n//\n// ## Description\n// This file implements the `StringNumber` class which renders string\n// number annotations beside notes.\n\nimport { Vex } from './vex';\nimport { Modifier } from './modifier';\nimport { Renderer } from './renderer';\nimport { StaveNote } from './stavenote';\n\nexport class StringNumber extends Modifier {\n  static get CATEGORY() { return 'stringnumber'; }\n\n  // ## Static Methods\n  // Arrange string numbers inside a `ModifierContext`\n  static format(nums, state) {\n    const left_shift = state.left_shift;\n    const right_shift = state.right_shift;\n    const num_spacing = 1;\n\n    if (!nums || nums.length === 0) return this;\n\n    const nums_list = [];\n    let prev_note = null;\n    let shift_left = 0;\n    let shift_right = 0;\n\n    let i;\n    let num;\n    let note;\n    let pos;\n    for (i = 0; i < nums.length; ++i) {\n      num = nums[i];\n      note = num.getNote();\n\n      for (i = 0; i < nums.length; ++i) {\n        num = nums[i];\n        note = num.getNote();\n        pos = num.getPosition();\n        const props = note.getKeyProps()[num.getIndex()];\n\n        if (note !== prev_note) {\n          for (let n = 0; n < note.keys.length; ++n) {\n            if (left_shift === 0) {\n              shift_left = Math.max(note.getLeftDisplacedHeadPx(), shift_left);\n            }\n            if (right_shift === 0) {\n              shift_right = Math.max(note.getRightDisplacedHeadPx(), shift_right);\n            }\n          }\n          prev_note = note;\n        }\n\n        nums_list.push({\n          pos,\n          note,\n          num,\n          line: props.line,\n          shiftL: shift_left,\n          shiftR: shift_right,\n        });\n      }\n    }\n\n    // Sort string numbers by line number.\n    nums_list.sort((a, b) => b.line - a.line);\n\n    // TODO: This variable never gets assigned to anything. Is that a bug or can this be removed?\n    let num_shiftL = 0; // eslint-disable-line\n    let num_shiftR = 0;\n    let x_widthL = 0;\n    let x_widthR = 0;\n    let last_line = null;\n    let last_note = null;\n    for (i = 0; i < nums_list.length; ++i) {\n      let num_shift = 0;\n      note = nums_list[i].note;\n      pos = nums_list[i].pos;\n      num = nums_list[i].num;\n      const line = nums_list[i].line;\n      const shiftL = nums_list[i].shiftL;\n      const shiftR = nums_list[i].shiftR;\n\n      // Reset the position of the string number every line.\n      if (line !== last_line || note !== last_note) {\n        num_shiftL = left_shift + shiftL;\n        num_shiftR = right_shift + shiftR;\n      }\n\n      const num_width = num.getWidth() + num_spacing;\n      if (pos === Modifier.Position.LEFT) {\n        num.setXShift(left_shift);\n        num_shift = shift_left + num_width; // spacing\n        x_widthL = (num_shift > x_widthL) ? num_shift : x_widthL;\n      } else if (pos === Modifier.Position.RIGHT) {\n        num.setXShift(num_shiftR);\n        num_shift += num_width; // spacing\n        x_widthR = (num_shift > x_widthR) ? num_shift : x_widthR;\n      }\n      last_line = line;\n      last_note = note;\n    }\n\n    state.left_shift += x_widthL;\n    state.right_shift += x_widthR;\n    return true;\n  }\n\n  constructor(number) {\n    super();\n    this.setAttribute('type', 'StringNumber');\n\n    this.note = null;\n    this.last_note = null;\n    this.index = null;\n    this.string_number = number;\n    this.setWidth(20); // ???\n    this.position = Modifier.Position.ABOVE; // Default position above stem or note head\n    this.x_shift = 0;\n    this.y_shift = 0;\n    this.x_offset = 0; // Horizontal offset from default\n    this.y_offset = 0; // Vertical offset from default\n    this.dashed = true; // true - draw dashed extension  false - no extension\n    this.leg = Renderer.LineEndType.NONE;   // draw upward/downward leg at the of extension line\n    this.radius = 8;\n    this.font = {\n      family: 'sans-serif',\n      size: 10,\n      weight: 'bold',\n    };\n  }\n  getCategory() { return StringNumber.CATEGORY; }\n  getNote() { return this.note; }\n  setNote(note) { this.note = note; return this; }\n  getIndex() { return this.index; }\n  setIndex(index) { this.index = index; return this; }\n\n  setLineEndType(leg) {\n    if (leg >= Renderer.LineEndType.NONE && leg <= Renderer.LineEndType.DOWN) {\n      this.leg = leg;\n    }\n    return this;\n  }\n\n  setStringNumber(number) { this.string_number = number; return this; }\n  setOffsetX(x) { this.x_offset = x; return this; }\n  setOffsetY(y) { this.y_offset = y; return this; }\n  setLastNote(note) { this.last_note = note; return this; }\n  setDashed(dashed) { this.dashed = dashed; return this; }\n\n  draw() {\n    const ctx = this.checkContext();\n    if (!(this.note && (this.index != null))) {\n      throw new Vex.RERR('NoAttachedNote', \"Can't draw string number without a note and index.\");\n    }\n    this.setRendered();\n\n    const line_space = this.note.stave.options.spacing_between_lines_px;\n\n    const start = this.note.getModifierStartXY(this.position, this.index);\n    let dot_x = (start.x + this.x_shift + this.x_offset);\n    let dot_y = start.y + this.y_shift + this.y_offset;\n\n    switch (this.position) {\n      case Modifier.Position.ABOVE:\n      case Modifier.Position.BELOW: {\n        const stem_ext = this.note.getStemExtents();\n        let top = stem_ext.topY;\n        let bottom = stem_ext.baseY + 2;\n\n        if (this.note.stem_direction === StaveNote.STEM_DOWN) {\n          top = stem_ext.baseY;\n          bottom = stem_ext.topY - 2;\n        }\n\n        if (this.position === Modifier.Position.ABOVE) {\n          dot_y = this.note.hasStem()\n            ? top - (line_space * 1.75)\n            : start.y - (line_space * 1.75);\n        } else {\n          dot_y = this.note.hasStem()\n            ? bottom + (line_space * 1.5)\n            : start.y + (line_space * 1.75);\n        }\n\n        dot_y += this.y_shift + this.y_offset;\n\n        break;\n      } case Modifier.Position.LEFT:\n        dot_x -= (this.radius / 2) + 5;\n        break;\n      case Modifier.Position.RIGHT:\n        dot_x += (this.radius / 2) + 6;\n        break;\n      default:\n        throw new Vex.RERR(\n          'InvalidPosition', `The position ${this.position} is invalid`\n        );\n    }\n\n    ctx.save();\n    ctx.beginPath();\n    ctx.arc(dot_x, dot_y, this.radius, 0, Math.PI * 2, false);\n    ctx.lineWidth = 1.5;\n    ctx.stroke();\n    ctx.setFont(this.font.family, this.font.size, this.font.weight);\n    const x = dot_x - ctx.measureText(this.string_number).width / 2;\n    ctx.fillText('' + this.string_number, x, dot_y + 4.5);\n\n    if (this.last_note != null) {\n      const end = this.last_note.getStemX() - this.note.getX() + 5;\n      ctx.strokeStyle = '#000000';\n      ctx.lineCap = 'round';\n      ctx.lineWidth = 0.6;\n      if (this.dashed) {\n        Renderer.drawDashedLine(ctx, dot_x + 10, dot_y, dot_x + end, dot_y, [3, 3]);\n      } else {\n        Renderer.drawDashedLine(ctx, dot_x + 10, dot_y, dot_x + end, dot_y, [3, 0]);\n      }\n\n      let len;\n      let pattern;\n      switch (this.leg) {\n        case Renderer.LineEndType.UP:\n          len = -10;\n          pattern = this.dashed ? [3, 3] : [3, 0];\n          Renderer.drawDashedLine(ctx, dot_x + end, dot_y, dot_x + end, dot_y + len, pattern);\n          break;\n        case Renderer.LineEndType.DOWN:\n          len = 10;\n          pattern = this.dashed ? [3, 3] : [3, 0];\n          Renderer.drawDashedLine(ctx, dot_x + end, dot_y, dot_x + end, dot_y + len, pattern);\n          break;\n        default:\n          break;\n      }\n    }\n\n    ctx.restore();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}