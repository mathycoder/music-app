{"ast":null,"code":"// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n//\n// This file implements an abstract interface for notes and chords that\n// are rendered on a stave. Notes have some common properties: All of them\n// have a value (e.g., pitch, fret, etc.) and a duration (quarter, half, etc.)\n//\n// Some notes have stems, heads, dots, etc. Most notational elements that\n// surround a note are called *modifiers*, and every note has an associated\n// array of them. All notes also have a rendering context and belong to a stave.\nimport { Vex } from './vex';\nimport { Flow } from './tables';\nimport { Tickable } from './tickable';\nexport class Note extends Tickable {\n  static get CATEGORY() {\n    return 'note';\n  } // Debug helper. Displays various note metrics for the given\n  // note.\n\n\n  static plotMetrics(ctx, note, yPos) {\n    const metrics = note.getMetrics();\n    const xStart = note.getAbsoluteX() - metrics.modLeftPx - metrics.leftDisplacedHeadPx;\n    const xPre1 = note.getAbsoluteX() - metrics.leftDisplacedHeadPx;\n    const xAbs = note.getAbsoluteX();\n    const xPost1 = note.getAbsoluteX() + metrics.notePx;\n    const xPost2 = note.getAbsoluteX() + metrics.notePx + metrics.rightDisplacedHeadPx;\n    const xEnd = note.getAbsoluteX() + metrics.notePx + metrics.rightDisplacedHeadPx + metrics.modRightPx;\n    const xFreedomRight = xEnd + (note.getFormatterMetrics().freedom.right || 0);\n    const xWidth = xEnd - xStart;\n    ctx.save();\n    ctx.setFont('Arial', 8, '');\n    ctx.fillText(Math.round(xWidth) + 'px', xStart + note.getXShift(), yPos);\n    const y = yPos + 7;\n\n    function stroke(x1, x2, color, yy = y) {\n      ctx.beginPath();\n      ctx.setStrokeStyle(color);\n      ctx.setFillStyle(color);\n      ctx.setLineWidth(3);\n      ctx.moveTo(x1 + note.getXShift(), yy);\n      ctx.lineTo(x2 + note.getXShift(), yy);\n      ctx.stroke();\n    }\n\n    stroke(xStart, xPre1, 'red');\n    stroke(xPre1, xAbs, '#999');\n    stroke(xAbs, xPost1, 'green');\n    stroke(xPost1, xPost2, '#999');\n    stroke(xPost2, xEnd, 'red');\n    stroke(xEnd, xFreedomRight, '#DD0');\n    stroke(xStart - note.getXShift(), xStart, '#BBB'); // Shift\n\n    Vex.drawDot(ctx, xAbs + note.getXShift(), y, 'blue');\n    const formatterMetrics = note.getFormatterMetrics();\n\n    if (formatterMetrics.iterations > 0) {\n      const spaceDeviation = formatterMetrics.space.deviation;\n      const prefix = spaceDeviation >= 0 ? '+' : '';\n      ctx.setFillStyle('red');\n      ctx.fillText(prefix + Math.round(spaceDeviation), xAbs + note.getXShift(), yPos - 10);\n    }\n\n    ctx.restore();\n  }\n\n  static parseDuration(durationString) {\n    if (typeof durationString !== 'string') {\n      return null;\n    }\n\n    const regexp = /(\\d*\\/?\\d+|[a-z])(d*)([nrhms]|$)/;\n    const result = regexp.exec(durationString);\n\n    if (!result) {\n      return null;\n    }\n\n    const duration = result[1];\n    const dots = result[2].length;\n    const type = result[3] || 'n';\n    return {\n      duration,\n      dots,\n      type\n    };\n  }\n\n  static parseNoteStruct(noteStruct) {\n    const durationString = noteStruct.duration;\n    const customTypes = []; // Preserve backwards-compatibility\n\n    const durationProps = Note.parseDuration(durationString);\n\n    if (!durationProps) {\n      return null;\n    } // If specified type is invalid, return null\n\n\n    let type = noteStruct.type;\n\n    if (type && !Flow.getGlyphProps.validTypes[type]) {\n      return null;\n    } // If no type specified, check duration or custom types\n\n\n    if (!type) {\n      type = durationProps.type || 'n'; // If we have keys, try and check if we've got a custom glyph\n\n      if (noteStruct.keys !== undefined) {\n        noteStruct.keys.forEach((k, i) => {\n          const result = k.split('/'); // We have a custom glyph specified after the note eg. /X2\n\n          customTypes[i] = result && result.length === 3 ? result[2] : type;\n        });\n      }\n    } // Calculate the tick duration of the note\n\n\n    let ticks = Flow.durationToTicks(durationProps.duration);\n\n    if (ticks == null) {\n      return null;\n    } // Are there any dots?\n\n\n    const dots = noteStruct.dots ? noteStruct.dots : durationProps.dots;\n\n    if (typeof dots !== 'number') {\n      return null;\n    } // Add ticks as necessary depending on the numbr of dots\n\n\n    let currentTicks = ticks;\n\n    for (let i = 0; i < dots; i++) {\n      if (currentTicks <= 1) return null;\n      currentTicks = currentTicks / 2;\n      ticks += currentTicks;\n    }\n\n    return {\n      duration: durationProps.duration,\n      type,\n      customTypes,\n      dots,\n      ticks\n    };\n  } // Every note is a tickable, i.e., it can be mutated by the `Formatter` class for\n  // positioning and layout.\n  // To create a new note you need to provide a `noteStruct`, which consists\n  // of the following fields:\n  //\n  // `type`: The note type (e.g., `r` for rest, `s` for slash notes, etc.)\n  // `dots`: The number of dots, which affects the duration.\n  // `duration`: The time length (e.g., `q` for quarter, `h` for half, `8` for eighth etc.)\n  //\n  // The range of values for these parameters are available in `src/tables.js`.\n\n\n  constructor(noteStruct) {\n    super();\n    this.setAttribute('type', 'Note');\n\n    if (!noteStruct) {\n      throw new Vex.RuntimeError('BadArguments', 'Note must have valid initialization data to identify duration and type.');\n    } // Parse `noteStruct` and get note properties.\n\n\n    const initStruct = Note.parseNoteStruct(noteStruct);\n\n    if (!initStruct) {\n      throw new Vex.RuntimeError('BadArguments', `Invalid note initialization object: ${JSON.stringify(noteStruct)}`);\n    } // Set note properties from parameters.\n\n\n    this.duration = initStruct.duration;\n    this.dots = initStruct.dots;\n    this.noteType = initStruct.type;\n    this.customTypes = initStruct.customTypes;\n\n    if (noteStruct.duration_override) {\n      // Custom duration\n      this.setDuration(noteStruct.duration_override);\n    } else {\n      // Default duration\n      this.setIntrinsicTicks(initStruct.ticks);\n    }\n\n    this.modifiers = []; // Get the glyph code for this note from the font.\n\n    this.glyph = Flow.getGlyphProps(this.duration, this.noteType);\n    this.customGlyphs = this.customTypes.map(t => Flow.getGlyphProps(this.duration, t));\n\n    if (this.positions && (typeof this.positions !== 'object' || !this.positions.length)) {\n      throw new Vex.RuntimeError('BadArguments', 'Note keys must be array type.');\n    } // Note to play for audio players.\n\n\n    this.playNote = null; // Positioning contexts used by the Formatter.\n\n    this.tickContext = null; // The current tick context.\n\n    this.modifierContext = null;\n    this.ignore_ticks = false; // Positioning variables\n\n    this.width = 0; // Width in pixels calculated after preFormat\n\n    this.leftDisplacedHeadPx = 0; // Extra room on left for displaced note head\n\n    this.rightDisplacedHeadPx = 0; // Extra room on right for displaced note head\n\n    this.x_shift = 0; // X shift from tick context X\n\n    this.voice = null; // The voice that this note is in\n\n    this.preFormatted = false; // Is this note preFormatted?\n\n    this.ys = []; // list of y coordinates for each note\n    // we need to hold on to these for ties and beams.\n\n    if (noteStruct.align_center) {\n      this.setCenterAlignment(noteStruct.align_center);\n    } // The render surface.\n\n\n    this.stave = null;\n    this.render_options = {\n      annotation_spacing: 5\n    };\n  } // Get and set the play note, which is arbitrary data that can be used by an\n  // audio player.\n\n\n  getPlayNote() {\n    return this.playNote;\n  }\n\n  setPlayNote(note) {\n    this.playNote = note;\n    return this;\n  } // Don't play notes by default, call them rests. This is also used by things like\n  // beams and dots for positioning.\n\n\n  isRest() {\n    return false;\n  } // TODO(0xfe): Why is this method here?\n\n\n  addStroke(index, stroke) {\n    stroke.setNote(this);\n    stroke.setIndex(index);\n    this.modifiers.push(stroke);\n    this.setPreFormatted(false);\n    return this;\n  } // Get and set the target stave.\n\n\n  getStave() {\n    return this.stave;\n  }\n\n  setStave(stave) {\n    this.stave = stave;\n    this.setYs([stave.getYForLine(0)]); // Update Y values if the stave is changed.\n\n    this.context = this.stave.context;\n    return this;\n  } // `Note` is not really a modifier, but is used in\n  // a `ModifierContext`.\n\n\n  getCategory() {\n    return Note.CATEGORY;\n  } // Set the rendering context for the note.\n\n\n  setContext(context) {\n    this.context = context;\n    return this;\n  } // Get and set spacing to the left and right of the notes.\n\n\n  getLeftDisplacedHeadPx() {\n    return this.leftDisplacedHeadPx;\n  }\n\n  getRightDisplacedHeadPx() {\n    return this.rightDisplacedHeadPx;\n  }\n\n  setLeftDisplacedHeadPx(x) {\n    this.leftDisplacedHeadPx = x;\n    return this;\n  }\n\n  setRightDisplacedHeadPx(x) {\n    this.rightDisplacedHeadPx = x;\n    return this;\n  } // Returns true if this note has no duration (e.g., bar notes, spacers, etc.)\n\n\n  shouldIgnoreTicks() {\n    return this.ignore_ticks;\n  } // Get the stave line number for the note.\n\n\n  getLineNumber() {\n    return 0;\n  } // Get the stave line number for rest.\n\n\n  getLineForRest() {\n    return 0;\n  } // Get the glyph associated with this note.\n\n\n  getGlyph() {\n    return this.glyph;\n  }\n\n  getGlyphWidth() {\n    // TODO: FIXME (multiple potential values for this.glyph)\n    if (this.glyph) {\n      if (this.glyph.getMetrics) {\n        return this.glyph.getMetrics().width;\n      } else if (this.glyph.getWidth) {\n        return this.glyph.getWidth(this.render_options.glyph_font_scale);\n      }\n    }\n\n    return 0;\n  } // Set and get Y positions for this note. Each Y value is associated with\n  // an individual pitch/key within the note/chord.\n\n\n  setYs(ys) {\n    this.ys = ys;\n    return this;\n  }\n\n  getYs() {\n    if (this.ys.length === 0) {\n      throw new Vex.RERR('NoYValues', 'No Y-values calculated for this note.');\n    }\n\n    return this.ys;\n  } // Get the Y position of the space above the stave onto which text can\n  // be rendered.\n\n\n  getYForTopText(text_line) {\n    if (!this.stave) {\n      throw new Vex.RERR('NoStave', 'No stave attached to this note.');\n    }\n\n    return this.stave.getYForTopText(text_line);\n  } // Get a `BoundingBox` for this note.\n\n\n  getBoundingBox() {\n    return null;\n  } // Returns the voice that this note belongs in.\n\n\n  getVoice() {\n    if (!this.voice) throw new Vex.RERR('NoVoice', 'Note has no voice.');\n    return this.voice;\n  } // Attach this note to `voice`.\n\n\n  setVoice(voice) {\n    this.voice = voice;\n    this.preFormatted = false;\n    return this;\n  } // Get and set the `TickContext` for this note.\n\n\n  getTickContext() {\n    return this.tickContext;\n  }\n\n  setTickContext(tc) {\n    this.tickContext = tc;\n    this.preFormatted = false;\n    return this;\n  } // Accessors for the note type.\n\n\n  getDuration() {\n    return this.duration;\n  }\n\n  isDotted() {\n    return this.dots > 0;\n  }\n\n  hasStem() {\n    return false;\n  }\n\n  getDots() {\n    return this.dots;\n  }\n\n  getNoteType() {\n    return this.noteType;\n  }\n\n  setBeam() {\n    return this;\n  } // ignore parameters\n  // Attach this note to a modifier context.\n\n\n  setModifierContext(mc) {\n    this.modifierContext = mc;\n    return this;\n  } // Attach a modifier to this note.\n\n\n  addModifier(modifier, index = 0) {\n    modifier.setNote(this);\n    modifier.setIndex(index);\n    this.modifiers.push(modifier);\n    this.setPreFormatted(false);\n    return this;\n  } // Get the coordinates for where modifiers begin.\n\n\n  getModifierStartXY() {\n    if (!this.preFormatted) {\n      throw new Vex.RERR('UnformattedNote', \"Can't call GetModifierStartXY on an unformatted note\");\n    }\n\n    return {\n      x: this.getAbsoluteX(),\n      y: this.ys[0]\n    };\n  } // Get bounds and metrics for this note.\n  //\n  // Returns a struct with fields:\n  // `width`: The total width of the note (including modifiers.)\n  // `notePx`: The width of the note head only.\n  // `left_shift`: The horizontal displacement of the note.\n  // `modLeftPx`: Start `X` for left modifiers.\n  // `modRightPx`: Start `X` for right modifiers.\n  // `leftDisplacedHeadPx`: Extra space on left of note.\n  // `rightDisplacedHeadPx`: Extra space on right of note.\n\n\n  getMetrics() {\n    if (!this.preFormatted) {\n      throw new Vex.RERR('UnformattedNote', \"Can't call getMetrics on an unformatted note.\");\n    }\n\n    const modLeftPx = this.modifierContext ? this.modifierContext.state.left_shift : 0;\n    const modRightPx = this.modifierContext ? this.modifierContext.state.right_shift : 0;\n    const width = this.getWidth();\n    const glyphWidth = this.getGlyphWidth();\n    const notePx = width - modLeftPx // subtract left modifiers\n    - modRightPx // subtract right modifiers\n    - this.leftDisplacedHeadPx // subtract left displaced head\n    - this.rightDisplacedHeadPx; // subtract right displaced head\n\n    return {\n      // ----------\n      // NOTE: If you change this, remember to update MockTickable in the tests/ directory.\n      // --------------\n      width,\n      glyphWidth,\n      notePx,\n      // Modifier spacing.\n      modLeftPx,\n      modRightPx,\n      // Displaced note head on left or right.\n      leftDisplacedHeadPx: this.leftDisplacedHeadPx,\n      rightDisplacedHeadPx: this.rightDisplacedHeadPx\n    };\n  } // Get the absolute `X` position of this note's tick context. This\n  // excludes x_shift, so you'll need to factor it in if you're\n  // looking for the post-formatted x-position.\n\n\n  getAbsoluteX() {\n    if (!this.tickContext) {\n      throw new Vex.RERR('NoTickContext', 'Note needs a TickContext assigned for an X-Value');\n    } // Position note to left edge of tick context.\n\n\n    let x = this.tickContext.getX();\n\n    if (this.stave) {\n      x += this.stave.getNoteStartX() + this.musicFont.lookupMetric('stave.padding');\n    }\n\n    if (this.isCenterAligned()) {\n      x += this.getCenterXShift();\n    }\n\n    return x;\n  }\n\n  setPreFormatted(value) {\n    this.preFormatted = value;\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/note.js"],"names":["Vex","Flow","Tickable","Note","CATEGORY","plotMetrics","ctx","note","yPos","metrics","getMetrics","xStart","getAbsoluteX","modLeftPx","leftDisplacedHeadPx","xPre1","xAbs","xPost1","notePx","xPost2","rightDisplacedHeadPx","xEnd","modRightPx","xFreedomRight","getFormatterMetrics","freedom","right","xWidth","save","setFont","fillText","Math","round","getXShift","y","stroke","x1","x2","color","yy","beginPath","setStrokeStyle","setFillStyle","setLineWidth","moveTo","lineTo","drawDot","formatterMetrics","iterations","spaceDeviation","space","deviation","prefix","restore","parseDuration","durationString","regexp","result","exec","duration","dots","length","type","parseNoteStruct","noteStruct","customTypes","durationProps","getGlyphProps","validTypes","keys","undefined","forEach","k","i","split","ticks","durationToTicks","currentTicks","constructor","setAttribute","RuntimeError","initStruct","JSON","stringify","noteType","duration_override","setDuration","setIntrinsicTicks","modifiers","glyph","customGlyphs","map","t","positions","playNote","tickContext","modifierContext","ignore_ticks","width","x_shift","voice","preFormatted","ys","align_center","setCenterAlignment","stave","render_options","annotation_spacing","getPlayNote","setPlayNote","isRest","addStroke","index","setNote","setIndex","push","setPreFormatted","getStave","setStave","setYs","getYForLine","context","getCategory","setContext","getLeftDisplacedHeadPx","getRightDisplacedHeadPx","setLeftDisplacedHeadPx","x","setRightDisplacedHeadPx","shouldIgnoreTicks","getLineNumber","getLineForRest","getGlyph","getGlyphWidth","getWidth","glyph_font_scale","getYs","RERR","getYForTopText","text_line","getBoundingBox","getVoice","setVoice","getTickContext","setTickContext","tc","getDuration","isDotted","hasStem","getDots","getNoteType","setBeam","setModifierContext","mc","addModifier","modifier","getModifierStartXY","state","left_shift","right_shift","glyphWidth","getX","getNoteStartX","musicFont","lookupMetric","isCenterAligned","getCenterXShift","value"],"mappings":"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","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n//\n// This file implements an abstract interface for notes and chords that\n// are rendered on a stave. Notes have some common properties: All of them\n// have a value (e.g., pitch, fret, etc.) and a duration (quarter, half, etc.)\n//\n// Some notes have stems, heads, dots, etc. Most notational elements that\n// surround a note are called *modifiers*, and every note has an associated\n// array of them. All notes also have a rendering context and belong to a stave.\n\nimport { Vex } from './vex';\nimport { Flow } from './tables';\nimport { Tickable } from './tickable';\n\nexport class Note extends Tickable {\n  static get CATEGORY() { return 'note'; }\n\n  // Debug helper. Displays various note metrics for the given\n  // note.\n  static plotMetrics(ctx, note, yPos) {\n    const metrics = note.getMetrics();\n    const xStart = note.getAbsoluteX() - metrics.modLeftPx - metrics.leftDisplacedHeadPx;\n    const xPre1 = note.getAbsoluteX() - metrics.leftDisplacedHeadPx;\n    const xAbs = note.getAbsoluteX();\n    const xPost1 = note.getAbsoluteX() + metrics.notePx;\n    const xPost2 = note.getAbsoluteX() + metrics.notePx + metrics.rightDisplacedHeadPx;\n    const xEnd = note.getAbsoluteX()\n      + metrics.notePx\n      + metrics.rightDisplacedHeadPx\n      + metrics.modRightPx;\n    const xFreedomRight = xEnd + (note.getFormatterMetrics().freedom.right || 0);\n\n    const xWidth = xEnd - xStart;\n    ctx.save();\n    ctx.setFont('Arial', 8, '');\n    ctx.fillText(Math.round(xWidth) + 'px', xStart + note.getXShift(), yPos);\n\n    const y = (yPos + 7);\n    function stroke(x1, x2, color, yy = y) {\n      ctx.beginPath();\n      ctx.setStrokeStyle(color);\n      ctx.setFillStyle(color);\n      ctx.setLineWidth(3);\n      ctx.moveTo(x1 + note.getXShift(), yy);\n      ctx.lineTo(x2 + note.getXShift(), yy);\n      ctx.stroke();\n    }\n\n    stroke(xStart, xPre1, 'red');\n    stroke(xPre1, xAbs, '#999');\n    stroke(xAbs, xPost1, 'green');\n    stroke(xPost1, xPost2, '#999');\n    stroke(xPost2, xEnd, 'red');\n    stroke(xEnd, xFreedomRight, '#DD0');\n    stroke(xStart - note.getXShift(), xStart, '#BBB'); // Shift\n    Vex.drawDot(ctx, xAbs + note.getXShift(), y, 'blue');\n\n    const formatterMetrics = note.getFormatterMetrics();\n    if (formatterMetrics.iterations > 0) {\n      const spaceDeviation = formatterMetrics.space.deviation;\n      const prefix = spaceDeviation >= 0 ? '+' : '';\n      ctx.setFillStyle('red');\n      ctx.fillText(prefix + Math.round(spaceDeviation),\n        xAbs + note.getXShift(), yPos - 10);\n    }\n    ctx.restore();\n  }\n\n  static parseDuration(durationString) {\n    if (typeof (durationString) !== 'string') { return null; }\n\n    const regexp = /(\\d*\\/?\\d+|[a-z])(d*)([nrhms]|$)/;\n    const result = regexp.exec(durationString);\n    if (!result) { return null; }\n\n    const duration = result[1];\n    const dots = result[2].length;\n    const type = result[3] || 'n';\n\n    return { duration, dots, type };\n  }\n\n  static parseNoteStruct(noteStruct) {\n    const durationString = noteStruct.duration;\n    const customTypes = [];\n\n    // Preserve backwards-compatibility\n    const durationProps = Note.parseDuration(durationString);\n    if (!durationProps) { return null; }\n\n    // If specified type is invalid, return null\n    let type = noteStruct.type;\n    if (type && !Flow.getGlyphProps.validTypes[type]) { return null; }\n\n\n    // If no type specified, check duration or custom types\n    if (!type) {\n      type = durationProps.type || 'n';\n\n      // If we have keys, try and check if we've got a custom glyph\n      if (noteStruct.keys !== undefined) {\n        noteStruct.keys.forEach((k, i) => {\n          const result = k.split('/');\n          // We have a custom glyph specified after the note eg. /X2\n          customTypes[i] = (result && result.length === 3) ? result[2] : type;\n        });\n      }\n    }\n\n    // Calculate the tick duration of the note\n    let ticks = Flow.durationToTicks(durationProps.duration);\n    if (ticks == null) { return null; }\n\n    // Are there any dots?\n    const dots = noteStruct.dots ? noteStruct.dots : durationProps.dots;\n    if (typeof (dots) !== 'number') { return null; }\n\n    // Add ticks as necessary depending on the numbr of dots\n    let currentTicks = ticks;\n    for (let i = 0; i < dots; i++) {\n      if (currentTicks <= 1) return null;\n\n      currentTicks = currentTicks / 2;\n      ticks += currentTicks;\n    }\n\n    return {\n      duration: durationProps.duration,\n      type,\n      customTypes,\n      dots,\n      ticks,\n    };\n  }\n\n\n  // Every note is a tickable, i.e., it can be mutated by the `Formatter` class for\n  // positioning and layout.\n  // To create a new note you need to provide a `noteStruct`, which consists\n  // of the following fields:\n  //\n  // `type`: The note type (e.g., `r` for rest, `s` for slash notes, etc.)\n  // `dots`: The number of dots, which affects the duration.\n  // `duration`: The time length (e.g., `q` for quarter, `h` for half, `8` for eighth etc.)\n  //\n  // The range of values for these parameters are available in `src/tables.js`.\n  constructor(noteStruct) {\n    super();\n    this.setAttribute('type', 'Note');\n\n    if (!noteStruct) {\n      throw new Vex.RuntimeError(\n        'BadArguments', 'Note must have valid initialization data to identify duration and type.'\n      );\n    }\n\n    // Parse `noteStruct` and get note properties.\n    const initStruct = Note.parseNoteStruct(noteStruct);\n    if (!initStruct) {\n      throw new Vex.RuntimeError(\n        'BadArguments', `Invalid note initialization object: ${JSON.stringify(noteStruct)}`\n      );\n    }\n\n    // Set note properties from parameters.\n    this.duration = initStruct.duration;\n    this.dots = initStruct.dots;\n    this.noteType = initStruct.type;\n    this.customTypes = initStruct.customTypes;\n\n    if (noteStruct.duration_override) {\n      // Custom duration\n      this.setDuration(noteStruct.duration_override);\n    } else {\n      // Default duration\n      this.setIntrinsicTicks(initStruct.ticks);\n    }\n\n    this.modifiers = [];\n\n    // Get the glyph code for this note from the font.\n    this.glyph = Flow.getGlyphProps(this.duration, this.noteType);\n    this.customGlyphs = this.customTypes.map(t => Flow.getGlyphProps(this.duration, t));\n\n    if (this.positions && (typeof (this.positions) !== 'object' || !this.positions.length)) {\n      throw new Vex.RuntimeError('BadArguments', 'Note keys must be array type.');\n    }\n\n    // Note to play for audio players.\n    this.playNote = null;\n\n    // Positioning contexts used by the Formatter.\n    this.tickContext = null;    // The current tick context.\n    this.modifierContext = null;\n    this.ignore_ticks = false;\n\n    // Positioning variables\n    this.width = 0;             // Width in pixels calculated after preFormat\n    this.leftDisplacedHeadPx = 0;       // Extra room on left for displaced note head\n    this.rightDisplacedHeadPx = 0;      // Extra room on right for displaced note head\n    this.x_shift = 0;           // X shift from tick context X\n    this.voice = null;          // The voice that this note is in\n    this.preFormatted = false;  // Is this note preFormatted?\n    this.ys = [];               // list of y coordinates for each note\n    // we need to hold on to these for ties and beams.\n\n    if (noteStruct.align_center) {\n      this.setCenterAlignment(noteStruct.align_center);\n    }\n\n    // The render surface.\n    this.stave = null;\n    this.render_options = {\n      annotation_spacing: 5,\n    };\n  }\n\n  // Get and set the play note, which is arbitrary data that can be used by an\n  // audio player.\n  getPlayNote() { return this.playNote; }\n  setPlayNote(note) { this.playNote = note; return this; }\n\n  // Don't play notes by default, call them rests. This is also used by things like\n  // beams and dots for positioning.\n  isRest() { return false; }\n\n  // TODO(0xfe): Why is this method here?\n  addStroke(index, stroke) {\n    stroke.setNote(this);\n    stroke.setIndex(index);\n    this.modifiers.push(stroke);\n    this.setPreFormatted(false);\n    return this;\n  }\n\n  // Get and set the target stave.\n  getStave() { return this.stave; }\n  setStave(stave) {\n    this.stave = stave;\n    this.setYs([stave.getYForLine(0)]); // Update Y values if the stave is changed.\n    this.context = this.stave.context;\n    return this;\n  }\n\n  // `Note` is not really a modifier, but is used in\n  // a `ModifierContext`.\n  getCategory() { return Note.CATEGORY; }\n\n  // Set the rendering context for the note.\n  setContext(context) { this.context = context; return this; }\n\n  // Get and set spacing to the left and right of the notes.\n  getLeftDisplacedHeadPx() { return this.leftDisplacedHeadPx; }\n  getRightDisplacedHeadPx() { return this.rightDisplacedHeadPx; }\n  setLeftDisplacedHeadPx(x) { this.leftDisplacedHeadPx = x; return this; }\n  setRightDisplacedHeadPx(x) { this.rightDisplacedHeadPx = x; return this; }\n\n  // Returns true if this note has no duration (e.g., bar notes, spacers, etc.)\n  shouldIgnoreTicks() { return this.ignore_ticks; }\n\n  // Get the stave line number for the note.\n  getLineNumber() { return 0; }\n\n  // Get the stave line number for rest.\n  getLineForRest() { return 0; }\n\n  // Get the glyph associated with this note.\n  getGlyph() { return this.glyph; }\n\n  getGlyphWidth() {\n    // TODO: FIXME (multiple potential values for this.glyph)\n    if (this.glyph) {\n      if (this.glyph.getMetrics) {\n        return this.glyph.getMetrics().width;\n      } else if (this.glyph.getWidth) {\n        return this.glyph.getWidth(this.render_options.glyph_font_scale);\n      }\n    }\n\n    return 0;\n  }\n\n  // Set and get Y positions for this note. Each Y value is associated with\n  // an individual pitch/key within the note/chord.\n  setYs(ys) { this.ys = ys; return this; }\n  getYs() {\n    if (this.ys.length === 0) {\n      throw new Vex.RERR('NoYValues', 'No Y-values calculated for this note.');\n    }\n\n    return this.ys;\n  }\n\n  // Get the Y position of the space above the stave onto which text can\n  // be rendered.\n  getYForTopText(text_line) {\n    if (!this.stave) {\n      throw new Vex.RERR('NoStave', 'No stave attached to this note.');\n    }\n\n    return this.stave.getYForTopText(text_line);\n  }\n\n  // Get a `BoundingBox` for this note.\n  getBoundingBox() { return null; }\n\n  // Returns the voice that this note belongs in.\n  getVoice() {\n    if (!this.voice) throw new Vex.RERR('NoVoice', 'Note has no voice.');\n    return this.voice;\n  }\n\n  // Attach this note to `voice`.\n  setVoice(voice) {\n    this.voice = voice;\n    this.preFormatted = false;\n    return this;\n  }\n\n  // Get and set the `TickContext` for this note.\n  getTickContext() { return this.tickContext; }\n  setTickContext(tc) {\n    this.tickContext = tc;\n    this.preFormatted = false;\n    return this;\n  }\n\n  // Accessors for the note type.\n  getDuration() { return this.duration; }\n  isDotted() { return (this.dots > 0); }\n  hasStem() { return false; }\n  getDots() { return this.dots; }\n  getNoteType() { return this.noteType; }\n  setBeam() { return this; } // ignore parameters\n\n  // Attach this note to a modifier context.\n  setModifierContext(mc) { this.modifierContext = mc; return this; }\n\n  // Attach a modifier to this note.\n  addModifier(modifier, index = 0) {\n    modifier.setNote(this);\n    modifier.setIndex(index);\n    this.modifiers.push(modifier);\n    this.setPreFormatted(false);\n    return this;\n  }\n\n  // Get the coordinates for where modifiers begin.\n  getModifierStartXY() {\n    if (!this.preFormatted) {\n      throw new Vex.RERR('UnformattedNote', \"Can't call GetModifierStartXY on an unformatted note\");\n    }\n\n    return {\n      x: this.getAbsoluteX(),\n      y: this.ys[0],\n    };\n  }\n\n  // Get bounds and metrics for this note.\n  //\n  // Returns a struct with fields:\n  // `width`: The total width of the note (including modifiers.)\n  // `notePx`: The width of the note head only.\n  // `left_shift`: The horizontal displacement of the note.\n  // `modLeftPx`: Start `X` for left modifiers.\n  // `modRightPx`: Start `X` for right modifiers.\n  // `leftDisplacedHeadPx`: Extra space on left of note.\n  // `rightDisplacedHeadPx`: Extra space on right of note.\n  getMetrics() {\n    if (!this.preFormatted) {\n      throw new Vex.RERR('UnformattedNote', \"Can't call getMetrics on an unformatted note.\");\n    }\n\n    const modLeftPx = this.modifierContext ? this.modifierContext.state.left_shift : 0;\n    const modRightPx = this.modifierContext ? this.modifierContext.state.right_shift : 0;\n    const width = this.getWidth();\n    const glyphWidth = this.getGlyphWidth();\n    const notePx = width\n      - modLeftPx           // subtract left modifiers\n      - modRightPx          // subtract right modifiers\n      - this.leftDisplacedHeadPx   // subtract left displaced head\n      - this.rightDisplacedHeadPx;  // subtract right displaced head\n\n    return {\n      // ----------\n      // NOTE: If you change this, remember to update MockTickable in the tests/ directory.\n      // --------------\n      width,\n      glyphWidth,\n      notePx,\n\n      // Modifier spacing.\n      modLeftPx,\n      modRightPx,\n\n      // Displaced note head on left or right.\n      leftDisplacedHeadPx: this.leftDisplacedHeadPx,\n      rightDisplacedHeadPx: this.rightDisplacedHeadPx,\n    };\n  }\n\n  // Get the absolute `X` position of this note's tick context. This\n  // excludes x_shift, so you'll need to factor it in if you're\n  // looking for the post-formatted x-position.\n  getAbsoluteX() {\n    if (!this.tickContext) {\n      throw new Vex.RERR('NoTickContext', 'Note needs a TickContext assigned for an X-Value');\n    }\n\n    // Position note to left edge of tick context.\n    let x = this.tickContext.getX();\n    if (this.stave) {\n      x += this.stave.getNoteStartX() + this.musicFont.lookupMetric('stave.padding');\n    }\n\n    if (this.isCenterAligned()) {\n      x += this.getCenterXShift();\n    }\n\n    return x;\n  }\n\n  setPreFormatted(value) {\n    this.preFormatted = value;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}