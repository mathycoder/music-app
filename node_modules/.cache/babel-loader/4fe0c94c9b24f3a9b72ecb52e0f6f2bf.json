{"ast":null,"code":"// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n//\n// `Modifier` is an abstract interface for notational elements that modify\n// a `Note`. Examples of modifiers are `Accidental`, `Annotation`, `Stroke`, etc.\n//\n// For a `Modifier` instance to be positioned correctly, it must be part of\n// a `ModifierContext`. All modifiers in the same context are rendered relative to\n// one another.\n//\n// Typically, all modifiers to a note are part of the same `ModifierContext` instance. Also,\n// in multi-voice staves, all modifiers to notes on the same `tick` are part of the same\n// `ModifierContext`. This ensures that multiple voices don't trample all over each other.\nimport { Vex } from './vex';\nimport { Element } from './element'; // To enable logging for this class. Set `Vex.Flow.Modifier.DEBUG` to `true`.\n// function L(...args) { if (Modifier.DEBUG) Vex.L('Vex.Flow.Modifier', args); }\n\nexport class Modifier extends Element {\n  static get CATEGORY() {\n    return 'none';\n  } // Modifiers can be positioned almost anywhere, relative to a note.\n\n\n  static get Position() {\n    return {\n      LEFT: 1,\n      RIGHT: 2,\n      ABOVE: 3,\n      BELOW: 4\n    };\n  }\n\n  static get PositionString() {\n    return {\n      above: Modifier.Position.ABOVE,\n      below: Modifier.Position.BELOW,\n      left: Modifier.Position.LEFT,\n      right: Modifier.Position.RIGHT\n    };\n  }\n\n  constructor() {\n    super();\n    this.setAttribute('type', 'Modifier');\n    this.width = 0; // Modifiers are attached to a note and an index. An index is a\n    // specific head in a chord.\n\n    this.note = null;\n    this.index = null; // The `text_line` is reserved space above or below a stave.\n\n    this.text_line = 0;\n    this.position = Modifier.Position.LEFT;\n    this.modifier_context = null;\n    this.x_shift = 0;\n    this.y_shift = 0;\n    this.spacingFromNextModifier = 0;\n  } // Called when position changes\n\n\n  reset() {} // do nothing\n  // Every modifier has a category. The `ModifierContext` uses this to determine\n  // the type and order of the modifiers.\n\n\n  getCategory() {\n    return Modifier.CATEGORY;\n  } // Get and set modifier widths.\n\n\n  getWidth() {\n    return this.width;\n  }\n\n  setWidth(width) {\n    this.width = width;\n    return this;\n  } // Get and set attached note (`StaveNote`, `TabNote`, etc.)\n\n\n  getNote() {\n    return this.note;\n  }\n\n  setNote(note) {\n    this.note = note;\n    return this;\n  } // Get and set note index, which is a specific note in a chord.\n\n\n  getIndex() {\n    return this.index;\n  }\n\n  setIndex(index) {\n    this.index = index;\n    return this;\n  } // Every modifier must be part of a `ModifierContext`.\n\n\n  getModifierContext() {\n    return this.modifier_context;\n  }\n\n  setModifierContext(c) {\n    this.modifier_context = c;\n    return this;\n  } // Get and set articulation position.\n\n\n  getPosition() {\n    return this.position;\n  }\n\n  setPosition(position) {\n    this.position = typeof position === 'string' ? Modifier.PositionString[position] : position;\n    this.reset();\n    return this;\n  } // Set the `text_line` for the modifier.\n\n\n  setTextLine(line) {\n    this.text_line = line;\n    return this;\n  } // Shift modifier down `y` pixels. Negative values shift up.\n\n\n  setYShift(y) {\n    this.y_shift = y;\n    return this;\n  }\n\n  setSpacingFromNextModifier(x) {\n    this.spacingFromNextModifier = x;\n  }\n\n  getSpacingFromNextModifier() {\n    return this.spacingFromNextModifier;\n  } // Shift modifier `x` pixels in the direction of the modifier. Negative values\n  // shift reverse.\n\n\n  setXShift(x) {\n    this.x_shift = 0;\n\n    if (this.position === Modifier.Position.LEFT) {\n      this.x_shift -= x;\n    } else {\n      this.x_shift += x;\n    }\n  }\n\n  getXShift() {\n    return this.x_shift;\n  } // Render the modifier onto the canvas.\n\n\n  draw() {\n    this.checkContext();\n    throw new Vex.RERR('MethodNotImplemented', 'draw() not implemented for this modifier.');\n  } // aligns sub notes of NoteSubGroup (or GraceNoteGroup) to the main note with correct x-offset\n\n\n  alignSubNotesWithNote(subNotes, note) {\n    // Shift over the tick contexts of each note\n    const tickContext = note.getTickContext();\n    const metrics = tickContext.getMetrics();\n    const subNoteXOffset = tickContext.getX() - metrics.modLeftPx - metrics.modRightPx + this.getSpacingFromNextModifier();\n    subNotes.forEach(subNote => {\n      const subTickContext = subNote.getTickContext();\n      subNote.setStave(note.stave);\n      subTickContext.setXOffset(subNoteXOffset); // don't touch baseX to avoid shift each render\n    });\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/modifier.js"],"names":["Vex","Element","Modifier","CATEGORY","Position","LEFT","RIGHT","ABOVE","BELOW","PositionString","above","below","left","right","constructor","setAttribute","width","note","index","text_line","position","modifier_context","x_shift","y_shift","spacingFromNextModifier","reset","getCategory","getWidth","setWidth","getNote","setNote","getIndex","setIndex","getModifierContext","setModifierContext","c","getPosition","setPosition","setTextLine","line","setYShift","y","setSpacingFromNextModifier","x","getSpacingFromNextModifier","setXShift","getXShift","draw","checkContext","RERR","alignSubNotesWithNote","subNotes","tickContext","getTickContext","metrics","getMetrics","subNoteXOffset","getX","modLeftPx","modRightPx","forEach","subNote","subTickContext","setStave","stave","setXOffset"],"mappings":"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","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n//\n// `Modifier` is an abstract interface for notational elements that modify\n// a `Note`. Examples of modifiers are `Accidental`, `Annotation`, `Stroke`, etc.\n//\n// For a `Modifier` instance to be positioned correctly, it must be part of\n// a `ModifierContext`. All modifiers in the same context are rendered relative to\n// one another.\n//\n// Typically, all modifiers to a note are part of the same `ModifierContext` instance. Also,\n// in multi-voice staves, all modifiers to notes on the same `tick` are part of the same\n// `ModifierContext`. This ensures that multiple voices don't trample all over each other.\n\nimport { Vex } from './vex';\nimport { Element } from './element';\n\n// To enable logging for this class. Set `Vex.Flow.Modifier.DEBUG` to `true`.\n// function L(...args) { if (Modifier.DEBUG) Vex.L('Vex.Flow.Modifier', args); }\n\nexport class Modifier extends Element {\n  static get CATEGORY() { return 'none'; }\n\n  // Modifiers can be positioned almost anywhere, relative to a note.\n  static get Position() {\n    return {\n      LEFT: 1,\n      RIGHT: 2,\n      ABOVE: 3,\n      BELOW: 4,\n    };\n  }\n\n  static get PositionString() {\n    return {\n      above: Modifier.Position.ABOVE,\n      below: Modifier.Position.BELOW,\n      left: Modifier.Position.LEFT,\n      right: Modifier.Position.RIGHT,\n    };\n  }\n\n  constructor() {\n    super();\n    this.setAttribute('type', 'Modifier');\n\n    this.width = 0;\n\n    // Modifiers are attached to a note and an index. An index is a\n    // specific head in a chord.\n    this.note = null;\n    this.index = null;\n\n    // The `text_line` is reserved space above or below a stave.\n    this.text_line = 0;\n    this.position = Modifier.Position.LEFT;\n    this.modifier_context = null;\n    this.x_shift = 0;\n    this.y_shift = 0;\n    this.spacingFromNextModifier = 0;\n  }\n\n  // Called when position changes\n  reset() {\n    // do nothing\n  }\n\n  // Every modifier has a category. The `ModifierContext` uses this to determine\n  // the type and order of the modifiers.\n  getCategory() { return Modifier.CATEGORY; }\n\n  // Get and set modifier widths.\n  getWidth() { return this.width; }\n  setWidth(width) { this.width = width; return this; }\n\n  // Get and set attached note (`StaveNote`, `TabNote`, etc.)\n  getNote() { return this.note; }\n  setNote(note) { this.note = note; return this; }\n\n  // Get and set note index, which is a specific note in a chord.\n  getIndex() { return this.index; }\n  setIndex(index) { this.index = index; return this; }\n\n  // Every modifier must be part of a `ModifierContext`.\n  getModifierContext() { return this.modifier_context; }\n  setModifierContext(c) { this.modifier_context = c; return this; }\n\n  // Get and set articulation position.\n  getPosition() { return this.position; }\n  setPosition(position) {\n    this.position = typeof(position) === 'string'\n      ? Modifier.PositionString[position]\n      : position;\n    this.reset();\n    return this;\n  }\n\n  // Set the `text_line` for the modifier.\n  setTextLine(line) { this.text_line = line; return this; }\n\n  // Shift modifier down `y` pixels. Negative values shift up.\n  setYShift(y) { this.y_shift = y; return this; }\n\n  setSpacingFromNextModifier(x) {\n    this.spacingFromNextModifier = x;\n  }\n\n  getSpacingFromNextModifier() { return this.spacingFromNextModifier; }\n\n  // Shift modifier `x` pixels in the direction of the modifier. Negative values\n  // shift reverse.\n  setXShift(x) {\n    this.x_shift = 0;\n    if (this.position === Modifier.Position.LEFT) {\n      this.x_shift -= x;\n    } else {\n      this.x_shift += x;\n    }\n  }\n  getXShift() { return this.x_shift; }\n\n  // Render the modifier onto the canvas.\n  draw() {\n    this.checkContext();\n    throw new Vex.RERR('MethodNotImplemented', 'draw() not implemented for this modifier.');\n  }\n\n  // aligns sub notes of NoteSubGroup (or GraceNoteGroup) to the main note with correct x-offset\n  alignSubNotesWithNote(subNotes, note) {\n    // Shift over the tick contexts of each note\n    const tickContext = note.getTickContext();\n    const metrics = tickContext.getMetrics();\n    const subNoteXOffset = tickContext.getX() - metrics.modLeftPx - metrics.modRightPx\n      + this.getSpacingFromNextModifier();\n\n    subNotes.forEach((subNote) => {\n      const subTickContext = subNote.getTickContext();\n      subNote.setStave(note.stave);\n      subTickContext.setXOffset(subNoteXOffset); // don't touch baseX to avoid shift each render\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}