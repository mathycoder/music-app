{"ast":null,"code":"// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\nimport { Vex } from './vex';\nimport { Flow } from './tables';\nimport { Element } from './element';\nimport { BoundingBoxComputation } from './boundingboxcomputation';\nimport { BoundingBox } from './boundingbox';\n\nfunction processOutline(outline, originX, originY, scaleX, scaleY, outlineFns) {\n  let command;\n  let x;\n  let y;\n  let i = 0;\n\n  function nextX() {\n    return originX + outline[i++] * scaleX;\n  }\n\n  function nextY() {\n    return originY + outline[i++] * scaleY;\n  }\n\n  function doOutline(command, ...args) {\n    outlineFns[command](...args);\n  }\n\n  while (i < outline.length) {\n    command = outline[i++];\n\n    switch (command) {\n      case 'm':\n      case 'l':\n        doOutline(command, nextX(), nextY());\n        break;\n\n      case 'q':\n        x = nextX();\n        y = nextY();\n        doOutline(command, nextX(), nextY(), x, y);\n        break;\n\n      case 'b':\n        x = nextX();\n        y = nextY();\n        doOutline(command, nextX(), nextY(), nextX(), nextY(), x, y);\n        break;\n\n      case 'z':\n        break;\n\n      default:\n        break;\n    }\n  }\n}\n\nexport class Glyph extends Element {\n  /*\n    Static methods used to implement loading and rendering glyphs.\n     Below categoryPath can be any metric path under 'glyphs', so stem.up would respolve\n    to glyphs.stem.up.shifX, glyphs.stem.up.shiftY, etc.\n  */\n  static lookupFontMetric({\n    font,\n    category,\n    code,\n    key,\n    defaultValue\n  }) {\n    let value = font.lookupMetric(`glyphs.${category}.${code}.${key}`, null);\n\n    if (value === null) {\n      value = font.lookupMetric(`glyphs.${category}.${key}`, defaultValue);\n    }\n\n    return value;\n  }\n\n  static lookupGlyph(fontStack, code) {\n    if (!fontStack) {\n      throw Vex.RERR('BAD_FONTSTACK', 'Font stack is misconfigured');\n    }\n\n    let glyph;\n    let font;\n\n    for (let i = 0; i < fontStack.length; i++) {\n      font = fontStack[i];\n      glyph = font.getGlyphs()[code];\n      if (glyph) break;\n    }\n\n    if (!glyph) {\n      throw new Vex.RERR('BadGlyph', `Glyph ${code} does not exist in font.`);\n    }\n\n    return {\n      glyph,\n      font\n    };\n  }\n\n  static loadMetrics(fontStack, code, category = null) {\n    const {\n      glyph,\n      font\n    } = Glyph.lookupGlyph(fontStack, code);\n    const x_shift = category ? Glyph.lookupFontMetric({\n      font,\n      category,\n      code,\n      key: 'shiftX',\n      defaultValue: 0\n    }) : 0;\n    const y_shift = category ? Glyph.lookupFontMetric({\n      font,\n      category,\n      code,\n      key: 'shiftY',\n      defaultValue: 0\n    }) : 0;\n    const scale = category ? Glyph.lookupFontMetric({\n      font,\n      category,\n      code,\n      key: 'scale',\n      defaultValue: 1\n    }) : 1;\n    const x_min = glyph.x_min;\n    const x_max = glyph.x_max;\n    const ha = glyph.ha;\n    let outline;\n    const CACHE = true;\n\n    if (glyph.o) {\n      if (CACHE) {\n        if (glyph.cached_outline) {\n          outline = glyph.cached_outline;\n        } else {\n          outline = glyph.o.split(' ');\n          glyph.cached_outline = outline;\n        }\n      } else {\n        if (glyph.cached_outline) delete glyph.cached_outline;\n        outline = glyph.o.split(' ');\n      }\n\n      return {\n        x_min,\n        x_max,\n        x_shift,\n        y_shift,\n        scale,\n        ha,\n        outline,\n        font\n      };\n    } else {\n      throw new Vex.RERR('BadGlyph', `Glyph ${code} has no outline defined.`);\n    }\n  }\n  /**\n   * A quick and dirty static glyph renderer. Renders glyphs from the default\n   * font defined in Vex.Flow.Font.\n   *\n   * @param {!Object} ctx The canvas context.\n   * @param {number} x_pos X coordinate.\n   * @param {number} y_pos Y coordinate.\n   * @param {number} point The point size to use.\n   * @param {string} val The glyph code in font.getGlyphs()\n   */\n\n\n  static renderGlyph(ctx, x_pos, y_pos, point, val, options) {\n    const params = {\n      fontStack: Flow.DEFAULT_FONT_STACK,\n      category: null,\n      ...options\n    };\n    const metrics = Glyph.loadMetrics(params.fontStack, val, params.category);\n    point = params.category ? Glyph.lookupFontMetric({\n      font: metrics.font,\n      category: params.category,\n      code: val,\n      key: 'point',\n      defaultValue: point\n    }) : point;\n    const scale = point * 72.0 / (metrics.font.getResolution() * 100.0);\n    Glyph.renderOutline(ctx, metrics.outline, scale * metrics.scale, x_pos + metrics.x_shift, y_pos + metrics.y_shift, options);\n    return metrics;\n  }\n\n  static renderOutline(ctx, outline, scale, x_pos, y_pos, options) {\n    ctx.beginPath();\n    ctx.moveTo(x_pos, y_pos);\n    processOutline(outline, x_pos, y_pos, scale, -scale, {\n      m: ctx.moveTo.bind(ctx),\n      l: ctx.lineTo.bind(ctx),\n      q: ctx.quadraticCurveTo.bind(ctx),\n      b: ctx.bezierCurveTo.bind(ctx) // z: ctx.fill.bind(ctx), // ignored\n\n    }, options);\n    ctx.fill();\n  }\n\n  static getOutlineBoundingBox(outline, scale, x_pos, y_pos) {\n    const bboxComp = new BoundingBoxComputation();\n    processOutline(outline, x_pos, y_pos, scale, -scale, {\n      m: bboxComp.addPoint.bind(bboxComp),\n      l: bboxComp.addPoint.bind(bboxComp),\n      q: bboxComp.addQuadraticCurve.bind(bboxComp),\n      b: bboxComp.addBezierCurve.bind(bboxComp),\n      z: bboxComp.noOp.bind(bboxComp)\n    });\n    return new BoundingBox(bboxComp.x1, bboxComp.y1, bboxComp.width(), bboxComp.height());\n  }\n  /**\n   * @constructor\n   */\n\n\n  constructor(code, point, options) {\n    super();\n    this.setAttribute('type', 'Glyph');\n    this.code = code;\n    this.point = point;\n    this.options = {\n      fontStack: this.getFontStack(),\n      category: null\n    };\n    this.metrics = null;\n    this.x_shift = 0;\n    this.y_shift = 0;\n    this.originShift = {\n      x: 0,\n      y: 0\n    };\n\n    if (options) {\n      this.setOptions(options);\n    } else {\n      this.reset();\n    }\n  }\n\n  getCode() {\n    return this.code;\n  }\n\n  setOptions(options) {\n    this.options = { ...this.options,\n      ...options\n    };\n    this.reset();\n  }\n\n  setPoint(point) {\n    this.point = point;\n    return this;\n  }\n\n  setStave(stave) {\n    this.stave = stave;\n    return this;\n  }\n\n  setXShift(x_shift) {\n    this.x_shift = x_shift;\n    return this;\n  }\n\n  setYShift(y_shift) {\n    this.y_shift = y_shift;\n    return this;\n  }\n\n  reset() {\n    this.metrics = Glyph.loadMetrics(this.options.fontStack, this.code, this.options.category); // Override point from metrics file\n\n    this.point = this.options.category ? Glyph.lookupFontMetric({\n      category: this.options.category,\n      font: this.metrics.font,\n      code: this.code,\n      key: 'point',\n      defaultValue: this.point\n    }) : this.point;\n    this.scale = this.point * 72 / (this.metrics.font.getResolution() * 100);\n    this.bbox = Glyph.getOutlineBoundingBox(this.metrics.outline, this.scale * this.metrics.scale, this.metrics.x_shift, this.metrics.y_shift);\n  }\n\n  getMetrics() {\n    if (!this.metrics) {\n      throw new Vex.RuntimeError('BadGlyph', `Glyph ${this.code} is not initialized.`);\n    }\n\n    return {\n      x_min: this.metrics.x_min * this.scale * this.metrics.scale,\n      x_max: this.metrics.x_max * this.scale * this.metrics.scale,\n      width: this.bbox.getW(),\n      height: this.bbox.getH()\n    };\n  }\n\n  setOriginX(x) {\n    const {\n      bbox\n    } = this;\n    const originX = Math.abs(bbox.getX() / bbox.getW());\n    const xShift = (x - originX) * bbox.getW();\n    this.originShift.x = -xShift;\n  }\n\n  setOriginY(y) {\n    const {\n      bbox\n    } = this;\n    const originY = Math.abs(bbox.getY() / bbox.getH());\n    const yShift = (y - originY) * bbox.getH();\n    this.originShift.y = -yShift;\n  }\n\n  setOrigin(x, y) {\n    this.setOriginX(x);\n    this.setOriginY(y);\n  }\n\n  render(ctx, x, y) {\n    if (!this.metrics) {\n      throw new Vex.RuntimeError('BadGlyph', `Glyph ${this.code} is not initialized.`);\n    }\n\n    const outline = this.metrics.outline;\n    const scale = this.scale * this.metrics.scale;\n    this.setRendered();\n    this.applyStyle(ctx);\n    Glyph.renderOutline(ctx, outline, scale, x + this.originShift.x + this.metrics.x_shift, y + this.originShift.y + this.metrics.y_shift);\n    this.restoreStyle(ctx);\n  }\n\n  renderToStave(x) {\n    this.checkContext();\n\n    if (!this.metrics) {\n      throw new Vex.RuntimeError('BadGlyph', `Glyph ${this.code} is not initialized.`);\n    }\n\n    if (!this.stave) {\n      throw new Vex.RuntimeError('GlyphError', 'No valid stave');\n    }\n\n    const outline = this.metrics.outline;\n    const scale = this.scale * this.metrics.scale;\n    this.setRendered();\n    this.applyStyle();\n    Glyph.renderOutline(this.context, outline, scale, x + this.x_shift + this.metrics.x_shift, this.stave.getYForGlyphs() + this.y_shift + this.metrics.y_shift);\n    this.restoreStyle();\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/glyph.js"],"names":["Vex","Flow","Element","BoundingBoxComputation","BoundingBox","processOutline","outline","originX","originY","scaleX","scaleY","outlineFns","command","x","y","i","nextX","nextY","doOutline","args","length","Glyph","lookupFontMetric","font","category","code","key","defaultValue","value","lookupMetric","lookupGlyph","fontStack","RERR","glyph","getGlyphs","loadMetrics","x_shift","y_shift","scale","x_min","x_max","ha","CACHE","o","cached_outline","split","renderGlyph","ctx","x_pos","y_pos","point","val","options","params","DEFAULT_FONT_STACK","metrics","getResolution","renderOutline","beginPath","moveTo","m","bind","l","lineTo","q","quadraticCurveTo","b","bezierCurveTo","fill","getOutlineBoundingBox","bboxComp","addPoint","addQuadraticCurve","addBezierCurve","z","noOp","x1","y1","width","height","constructor","setAttribute","getFontStack","originShift","setOptions","reset","getCode","setPoint","setStave","stave","setXShift","setYShift","bbox","getMetrics","RuntimeError","getW","getH","setOriginX","Math","abs","getX","xShift","setOriginY","getY","yShift","setOrigin","render","setRendered","applyStyle","restoreStyle","renderToStave","checkContext","context","getYForGlyphs"],"mappings":"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","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n\nimport { Vex } from './vex';\nimport { Flow } from './tables';\nimport { Element } from './element';\nimport { BoundingBoxComputation } from './boundingboxcomputation';\nimport { BoundingBox } from './boundingbox';\n\nfunction processOutline(outline, originX, originY, scaleX, scaleY, outlineFns) {\n  let command;\n  let x;\n  let y;\n  let i = 0;\n\n  function nextX() { return originX + outline[i++] * scaleX; }\n  function nextY() { return originY + outline[i++] * scaleY; }\n  function doOutline(command, ...args) {\n    outlineFns[command](...args);\n  }\n\n  while (i < outline.length) {\n    command = outline[i++];\n    switch (command) {\n      case 'm':\n      case 'l':\n        doOutline(command, nextX(), nextY());\n        break;\n      case 'q':\n        x = nextX();\n        y = nextY();\n        doOutline(command, nextX(), nextY(), x, y);\n        break;\n      case 'b':\n        x = nextX();\n        y = nextY();\n        doOutline(command, nextX(), nextY(), nextX(), nextY(), x, y);\n        break;\n      case 'z':\n        break;\n      default:\n        break;\n    }\n  }\n}\n\nexport class Glyph extends Element {\n  /*\n    Static methods used to implement loading and rendering glyphs.\n\n    Below categoryPath can be any metric path under 'glyphs', so stem.up would respolve\n    to glyphs.stem.up.shifX, glyphs.stem.up.shiftY, etc.\n  */\n  static lookupFontMetric({ font, category, code, key, defaultValue }) {\n    let value = font.lookupMetric(`glyphs.${category}.${code}.${key}`, null);\n    if (value === null) {\n      value = font.lookupMetric(`glyphs.${category}.${key}`, defaultValue);\n    }\n    return value;\n  }\n\n  static lookupGlyph(fontStack, code) {\n    if (!fontStack) {\n      throw Vex.RERR('BAD_FONTSTACK', 'Font stack is misconfigured');\n    }\n\n    let glyph;\n    let font;\n    for (let i = 0; i < fontStack.length; i++) {\n      font = fontStack[i];\n      glyph = font.getGlyphs()[code];\n      if (glyph) break;\n    }\n\n    if (!glyph) {\n      throw new Vex.RERR('BadGlyph', `Glyph ${code} does not exist in font.`);\n    }\n\n    return { glyph, font };\n  }\n\n\n  static loadMetrics(fontStack, code, category = null) {\n    const { glyph, font } = Glyph.lookupGlyph(fontStack, code);\n\n    const x_shift = category ? Glyph.lookupFontMetric({\n      font, category, code,\n      key: 'shiftX', defaultValue: 0\n    }) : 0;\n    const y_shift = category ? Glyph.lookupFontMetric({\n      font, category, code,\n      key: 'shiftY', defaultValue: 0\n    }) : 0;\n    const scale = category ? Glyph.lookupFontMetric({\n      font, category, code,\n      key: 'scale', defaultValue: 1\n    }) : 1;\n\n    const x_min = glyph.x_min;\n    const x_max = glyph.x_max;\n    const ha = glyph.ha;\n\n    let outline;\n\n    const CACHE = true;\n    if (glyph.o) {\n      if (CACHE) {\n        if (glyph.cached_outline) {\n          outline = glyph.cached_outline;\n        } else {\n          outline = glyph.o.split(' ');\n          glyph.cached_outline = outline;\n        }\n      } else {\n        if (glyph.cached_outline) delete glyph.cached_outline;\n        outline = glyph.o.split(' ');\n      }\n\n      return {\n        x_min,\n        x_max,\n        x_shift,\n        y_shift,\n        scale,\n        ha,\n        outline,\n        font,\n      };\n    } else {\n      throw new Vex.RERR('BadGlyph', `Glyph ${code} has no outline defined.`);\n    }\n  }\n\n  /**\n   * A quick and dirty static glyph renderer. Renders glyphs from the default\n   * font defined in Vex.Flow.Font.\n   *\n   * @param {!Object} ctx The canvas context.\n   * @param {number} x_pos X coordinate.\n   * @param {number} y_pos Y coordinate.\n   * @param {number} point The point size to use.\n   * @param {string} val The glyph code in font.getGlyphs()\n   */\n  static renderGlyph(ctx, x_pos, y_pos, point, val, options) {\n    const params = {\n      fontStack: Flow.DEFAULT_FONT_STACK,\n      category: null,\n      ...options\n    };\n    const metrics = Glyph.loadMetrics(params.fontStack, val, params.category);\n    point = params.category ? Glyph.lookupFontMetric({\n      font: metrics.font,\n      category: params.category,\n      code: val,\n      key: 'point',\n      defaultValue: point\n    }) : point;\n    const scale = point * 72.0 / (metrics.font.getResolution() * 100.0);\n\n    Glyph.renderOutline(ctx, metrics.outline, scale * metrics.scale, x_pos + metrics.x_shift, y_pos + metrics.y_shift, options);\n    return metrics;\n  }\n\n  static renderOutline(ctx, outline, scale, x_pos, y_pos, options) {\n    ctx.beginPath();\n    ctx.moveTo(x_pos, y_pos);\n    processOutline(outline, x_pos, y_pos, scale, -scale, {\n      m: ctx.moveTo.bind(ctx),\n      l: ctx.lineTo.bind(ctx),\n      q: ctx.quadraticCurveTo.bind(ctx),\n      b: ctx.bezierCurveTo.bind(ctx),\n      // z: ctx.fill.bind(ctx), // ignored\n    }, options);\n    ctx.fill();\n  }\n\n  static getOutlineBoundingBox(outline, scale, x_pos, y_pos) {\n    const bboxComp = new BoundingBoxComputation();\n\n    processOutline(outline, x_pos, y_pos, scale, -scale, {\n      m: bboxComp.addPoint.bind(bboxComp),\n      l: bboxComp.addPoint.bind(bboxComp),\n      q: bboxComp.addQuadraticCurve.bind(bboxComp),\n      b: bboxComp.addBezierCurve.bind(bboxComp),\n      z: bboxComp.noOp.bind(bboxComp),\n    });\n\n    return new BoundingBox(\n      bboxComp.x1,\n      bboxComp.y1,\n      bboxComp.width(),\n      bboxComp.height()\n    );\n  }\n\n  /**\n   * @constructor\n   */\n  constructor(code, point, options) {\n    super();\n    this.setAttribute('type', 'Glyph');\n\n    this.code = code;\n    this.point = point;\n    this.options = {\n      fontStack: this.getFontStack(),\n      category: null,\n    };\n\n    this.metrics = null;\n    this.x_shift = 0;\n    this.y_shift = 0;\n\n    this.originShift = {\n      x: 0,\n      y: 0,\n    };\n\n    if (options) {\n      this.setOptions(options);\n    } else {\n      this.reset();\n    }\n  }\n\n  getCode() {\n    return this.code;\n  }\n\n  setOptions(options) {\n    this.options = { ...this.options, ...options };\n    this.reset();\n  }\n\n  setPoint(point) { this.point = point; return this; }\n  setStave(stave) { this.stave = stave; return this; }\n  setXShift(x_shift) { this.x_shift = x_shift; return this; }\n  setYShift(y_shift) { this.y_shift = y_shift; return this; }\n\n  reset() {\n    this.metrics = Glyph.loadMetrics(this.options.fontStack, this.code, this.options.category);\n    // Override point from metrics file\n    this.point = this.options.category ? Glyph.lookupFontMetric({\n      category: this.options.category,\n      font: this.metrics.font,\n      code: this.code,\n      key: 'point',\n      defaultValue: this.point,\n    }) : this.point;\n\n    this.scale = this.point * 72 / (this.metrics.font.getResolution() * 100);\n    this.bbox = Glyph.getOutlineBoundingBox(\n      this.metrics.outline,\n      this.scale * this.metrics.scale,\n      this.metrics.x_shift,\n      this.metrics.y_shift,\n    );\n  }\n\n  getMetrics() {\n    if (!this.metrics) {\n      throw new Vex.RuntimeError('BadGlyph', `Glyph ${this.code} is not initialized.`);\n    }\n\n    return {\n      x_min: this.metrics.x_min * this.scale * this.metrics.scale,\n      x_max: this.metrics.x_max * this.scale * this.metrics.scale,\n      width: this.bbox.getW(),\n      height: this.bbox.getH(),\n    };\n  }\n\n  setOriginX(x) {\n    const { bbox } = this;\n    const originX = Math.abs(bbox.getX() / bbox.getW());\n    const xShift = (x - originX) * bbox.getW();\n    this.originShift.x = -xShift;\n  }\n\n  setOriginY(y) {\n    const { bbox } = this;\n    const originY = Math.abs(bbox.getY() / bbox.getH());\n    const yShift = (y - originY) * bbox.getH();\n    this.originShift.y = -yShift;\n  }\n\n  setOrigin(x, y) {\n    this.setOriginX(x);\n    this.setOriginY(y);\n  }\n\n  render(ctx, x, y) {\n    if (!this.metrics) {\n      throw new Vex.RuntimeError('BadGlyph', `Glyph ${this.code} is not initialized.`);\n    }\n\n    const outline = this.metrics.outline;\n    const scale = this.scale * this.metrics.scale;\n\n    this.setRendered();\n    this.applyStyle(ctx);\n    Glyph.renderOutline(ctx, outline, scale,\n      x + this.originShift.x + this.metrics.x_shift,\n      y + this.originShift.y + this.metrics.y_shift);\n    this.restoreStyle(ctx);\n  }\n\n  renderToStave(x) {\n    this.checkContext();\n\n    if (!this.metrics) {\n      throw new Vex.RuntimeError('BadGlyph', `Glyph ${this.code} is not initialized.`);\n    }\n\n    if (!this.stave) {\n      throw new Vex.RuntimeError('GlyphError', 'No valid stave');\n    }\n\n    const outline = this.metrics.outline;\n    const scale = this.scale * this.metrics.scale;\n\n    this.setRendered();\n    this.applyStyle();\n    Glyph.renderOutline(this.context, outline, scale,\n      x + this.x_shift + this.metrics.x_shift, this.stave.getYForGlyphs() + this.y_shift + this.metrics.y_shift);\n    this.restoreStyle();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}