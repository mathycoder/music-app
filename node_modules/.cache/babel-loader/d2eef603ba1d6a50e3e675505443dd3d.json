{"ast":null,"code":"// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n//\n// This file implements `Beams` that span over a set of `StemmableNotes`.\nimport { Vex } from './vex';\nimport { Flow } from './tables';\nimport { Element } from './element';\nimport { Fraction } from './fraction';\nimport { Tuplet } from './tuplet';\nimport { Stem } from './stem';\n\nfunction calculateStemDirection(notes) {\n  let lineSum = 0;\n  notes.forEach(note => {\n    if (note.keyProps) {\n      note.keyProps.forEach(keyProp => {\n        lineSum += keyProp.line - 3;\n      });\n    }\n  });\n\n  if (lineSum >= 0) {\n    return Stem.DOWN;\n  }\n\n  return Stem.UP;\n}\n\nconst getStemSlope = (firstNote, lastNote) => {\n  const firstStemTipY = firstNote.getStemExtents().topY;\n  const firstStemX = firstNote.getStemX();\n  const lastStemTipY = lastNote.getStemExtents().topY;\n  const lastStemX = lastNote.getStemX();\n  return (lastStemTipY - firstStemTipY) / (lastStemX - firstStemX);\n};\n\nconst BEAM_LEFT = 'L';\nconst BEAM_RIGHT = 'R';\nconst BEAM_BOTH = 'B';\nexport class Beam extends Element {\n  // Gets the default beam groups for a provided time signature.\n  // Attempts to guess if the time signature is not found in table.\n  // Currently this is fairly naive.\n  static getDefaultBeamGroups(time_sig) {\n    if (!time_sig || time_sig === 'c') {\n      time_sig = '4/4';\n    }\n\n    const defaults = {\n      '1/2': ['1/2'],\n      '2/2': ['1/2'],\n      '3/2': ['1/2'],\n      '4/2': ['1/2'],\n      '1/4': ['1/4'],\n      '2/4': ['1/4'],\n      '3/4': ['1/4'],\n      '4/4': ['1/4'],\n      '1/8': ['1/8'],\n      '2/8': ['2/8'],\n      '3/8': ['3/8'],\n      '4/8': ['2/8'],\n      '1/16': ['1/16'],\n      '2/16': ['2/16'],\n      '3/16': ['3/16'],\n      '4/16': ['2/16']\n    };\n    const groups = defaults[time_sig];\n\n    if (groups === undefined) {\n      // If no beam groups found, naively determine\n      // the beam groupings from the time signature\n      const beatTotal = parseInt(time_sig.split('/')[0], 10);\n      const beatValue = parseInt(time_sig.split('/')[1], 10);\n      const tripleMeter = beatTotal % 3 === 0;\n\n      if (tripleMeter) {\n        return [new Fraction(3, beatValue)];\n      } else if (beatValue > 4) {\n        return [new Fraction(2, beatValue)];\n      } else if (beatValue <= 4) {\n        return [new Fraction(1, beatValue)];\n      }\n    } else {\n      return groups.map(group => new Fraction().parse(group));\n    }\n\n    return [new Fraction(1, 4)];\n  } // A helper function to automatically build basic beams for a voice. For more\n  // complex auto-beaming use `Beam.generateBeams()`.\n  //\n  // Parameters:\n  // * `voice` - The voice to generate the beams for\n  // * `stem_direction` - A stem direction to apply to the entire voice\n  // * `groups` - An array of `Fraction` representing beat groupings for the beam\n\n\n  static applyAndGetBeams(voice, stem_direction, groups) {\n    return Beam.generateBeams(voice.getTickables(), {\n      groups,\n      stem_direction\n    });\n  } // A helper function to autimatically build beams for a voice with\n  // configuration options.\n  //\n  // Example configuration object:\n  //\n  // ```\n  // config = {\n  //   groups: [new Vex.Flow.Fraction(2, 8)],\n  //   stem_direction: -1,\n  //   beam_rests: true,\n  //   beam_middle_only: true,\n  //   show_stemlets: false\n  // };\n  // ```\n  //\n  // Parameters:\n  // * `notes` - An array of notes to create the beams for\n  // * `config` - The configuration object\n  //    * `groups` - Array of `Fractions` that represent the beat structure to beam the notes\n  //    * `stem_direction` - Set to apply the same direction to all notes\n  //    * `beam_rests` - Set to `true` to include rests in the beams\n  //    * `beam_middle_only` - Set to `true` to only beam rests in the middle of the beat\n  //    * `show_stemlets` - Set to `true` to draw stemlets for rests\n  //    * `maintain_stem_directions` - Set to `true` to not apply new stem directions\n  //\n\n\n  static generateBeams(notes, config) {\n    if (!config) config = {};\n\n    if (!config.groups || !config.groups.length) {\n      config.groups = [new Fraction(2, 8)];\n    } // Convert beam groups to tick amounts\n\n\n    const tickGroups = config.groups.map(group => {\n      if (!group.multiply) {\n        throw new Vex.RuntimeError('InvalidBeamGroups', 'The beam groups must be an array of Vex.Flow.Fractions');\n      }\n\n      return group.clone().multiply(Flow.RESOLUTION, 1);\n    });\n    const unprocessedNotes = notes;\n    let currentTickGroup = 0;\n    let noteGroups = [];\n    let currentGroup = [];\n\n    function getTotalTicks(vf_notes) {\n      return vf_notes.reduce((memo, note) => note.getTicks().clone().add(memo), new Fraction(0, 1));\n    }\n\n    function nextTickGroup() {\n      if (tickGroups.length - 1 > currentTickGroup) {\n        currentTickGroup += 1;\n      } else {\n        currentTickGroup = 0;\n      }\n    }\n\n    function createGroups() {\n      let nextGroup = [];\n      unprocessedNotes.forEach(unprocessedNote => {\n        nextGroup = [];\n\n        if (unprocessedNote.shouldIgnoreTicks()) {\n          noteGroups.push(currentGroup);\n          currentGroup = nextGroup;\n          return; // Ignore untickables (like bar notes)\n        }\n\n        currentGroup.push(unprocessedNote);\n        const ticksPerGroup = tickGroups[currentTickGroup].clone();\n        const totalTicks = getTotalTicks(currentGroup); // Double the amount of ticks in a group, if it's an unbeamable tuplet\n\n        const unbeamable = Flow.durationToNumber(unprocessedNote.duration) < 8;\n\n        if (unbeamable && unprocessedNote.tuplet) {\n          ticksPerGroup.numerator *= 2;\n        } // If the note that was just added overflows the group tick total\n\n\n        if (totalTicks.greaterThan(ticksPerGroup)) {\n          // If the overflow note can be beamed, start the next group\n          // with it. Unbeamable notes leave the group overflowed.\n          if (!unbeamable) {\n            nextGroup.push(currentGroup.pop());\n          }\n\n          noteGroups.push(currentGroup);\n          currentGroup = nextGroup;\n          nextTickGroup();\n        } else if (totalTicks.equals(ticksPerGroup)) {\n          noteGroups.push(currentGroup);\n          currentGroup = nextGroup;\n          nextTickGroup();\n        }\n      }); // Adds any remainder notes\n\n      if (currentGroup.length > 0) {\n        noteGroups.push(currentGroup);\n      }\n    }\n\n    function getBeamGroups() {\n      return noteGroups.filter(group => {\n        if (group.length > 1) {\n          let beamable = true;\n          group.forEach(note => {\n            if (note.getIntrinsicTicks() >= Flow.durationToTicks('4')) {\n              beamable = false;\n            }\n          });\n          return beamable;\n        }\n\n        return false;\n      });\n    } // Splits up groups by Rest\n\n\n    function sanitizeGroups() {\n      const sanitizedGroups = [];\n      noteGroups.forEach(group => {\n        let tempGroup = [];\n        group.forEach((note, index, group) => {\n          const isFirstOrLast = index === 0 || index === group.length - 1;\n          const prevNote = group[index - 1];\n          const breaksOnEachRest = !config.beam_rests && note.isRest();\n          const breaksOnFirstOrLastRest = config.beam_rests && config.beam_middle_only && note.isRest() && isFirstOrLast;\n          let breakOnStemChange = false;\n\n          if (config.maintain_stem_directions && prevNote && !note.isRest() && !prevNote.isRest()) {\n            const prevDirection = prevNote.getStemDirection();\n            const currentDirection = note.getStemDirection();\n            breakOnStemChange = currentDirection !== prevDirection;\n          }\n\n          const isUnbeamableDuration = parseInt(note.duration, 10) < 8; // Determine if the group should be broken at this note\n\n          const shouldBreak = breaksOnEachRest || breaksOnFirstOrLastRest || breakOnStemChange || isUnbeamableDuration;\n\n          if (shouldBreak) {\n            // Add current group\n            if (tempGroup.length > 0) {\n              sanitizedGroups.push(tempGroup);\n            } // Start a new group. Include the current note if the group\n            // was broken up by stem direction, as that note needs to start\n            // the next group of notes\n\n\n            tempGroup = breakOnStemChange ? [note] : [];\n          } else {\n            // Add note to group\n            tempGroup.push(note);\n          }\n        }); // If there is a remaining group, add it as well\n\n        if (tempGroup.length > 0) {\n          sanitizedGroups.push(tempGroup);\n        }\n      });\n      noteGroups = sanitizedGroups;\n    }\n\n    function formatStems() {\n      noteGroups.forEach(group => {\n        let stemDirection;\n\n        if (config.maintain_stem_directions) {\n          const note = findFirstNote(group);\n          stemDirection = note ? note.getStemDirection() : Stem.UP;\n        } else {\n          if (config.stem_direction) {\n            stemDirection = config.stem_direction;\n          } else {\n            stemDirection = calculateStemDirection(group);\n          }\n        }\n\n        applyStemDirection(group, stemDirection);\n      });\n    }\n\n    function findFirstNote(group) {\n      for (let i = 0; i < group.length; i++) {\n        const note = group[i];\n\n        if (!note.isRest()) {\n          return note;\n        }\n      }\n\n      return false;\n    }\n\n    function applyStemDirection(group, direction) {\n      group.forEach(note => {\n        note.setStemDirection(direction);\n      });\n    } // Get all of the tuplets in all of the note groups\n\n\n    function getTuplets() {\n      const uniqueTuplets = []; // Go through all of the note groups and inspect for tuplets\n\n      noteGroups.forEach(group => {\n        let tuplet = null;\n        group.forEach(note => {\n          if (note.tuplet && tuplet !== note.tuplet) {\n            tuplet = note.tuplet;\n            uniqueTuplets.push(tuplet);\n          }\n        });\n      });\n      return uniqueTuplets;\n    } // Using closures to store the variables throughout the various functions\n    // IMO Keeps it this process lot cleaner - but not super consistent with\n    // the rest of the API's style - Silverwolf90 (Cyril)\n\n\n    createGroups();\n    sanitizeGroups();\n    formatStems(); // Get the notes to be beamed\n\n    const beamedNoteGroups = getBeamGroups(); // Get the tuplets in order to format them accurately\n\n    const allTuplets = getTuplets(); // Create a Vex.Flow.Beam from each group of notes to be beamed\n\n    const beams = [];\n    beamedNoteGroups.forEach(group => {\n      const beam = new Beam(group);\n\n      if (config.show_stemlets) {\n        beam.render_options.show_stemlets = true;\n      }\n\n      if (config.secondary_breaks) {\n        beam.render_options.secondary_break_ticks = Flow.durationToTicks(config.secondary_breaks);\n      }\n\n      if (config.flat_beams === true) {\n        beam.render_options.flat_beams = true;\n        beam.render_options.flat_beam_offset = config.flat_beam_offset;\n      }\n\n      beams.push(beam);\n    }); // Reformat tuplets\n\n    allTuplets.forEach(tuplet => {\n      // Set the tuplet location based on the stem direction\n      const direction = tuplet.notes[0].stem_direction === Stem.DOWN ? Tuplet.LOCATION_BOTTOM : Tuplet.LOCATION_TOP;\n      tuplet.setTupletLocation(direction); // If any of the notes in the tuplet are not beamed, draw a bracket.\n\n      let bracketed = false;\n\n      for (let i = 0; i < tuplet.notes.length; i++) {\n        const note = tuplet.notes[i];\n\n        if (note.beam === null) {\n          bracketed = true;\n          break;\n        }\n      }\n\n      tuplet.setBracketed(bracketed);\n    });\n    return beams;\n  }\n\n  constructor(notes, auto_stem) {\n    super();\n    this.setAttribute('type', 'Beam');\n\n    if (!notes || notes === []) {\n      throw new Vex.RuntimeError('BadArguments', 'No notes provided for beam.');\n    }\n\n    if (notes.length === 1) {\n      throw new Vex.RuntimeError('BadArguments', 'Too few notes for beam.');\n    } // Validate beam line, direction and ticks.\n\n\n    this.ticks = notes[0].getIntrinsicTicks();\n\n    if (this.ticks >= Flow.durationToTicks('4')) {\n      throw new Vex.RuntimeError('BadArguments', 'Beams can only be applied to notes shorter than a quarter note.');\n    }\n\n    let i; // shared iterator\n\n    let note;\n    this.stem_direction = Stem.UP;\n\n    for (i = 0; i < notes.length; ++i) {\n      note = notes[i];\n\n      if (note.hasStem()) {\n        this.stem_direction = note.getStemDirection();\n        break;\n      }\n    }\n\n    let stem_direction = this.stem_direction; // Figure out optimal stem direction based on given notes\n\n    if (auto_stem && notes[0].getCategory() === 'stavenotes') {\n      stem_direction = calculateStemDirection(notes);\n    } else if (auto_stem && notes[0].getCategory() === 'tabnotes') {\n      // Auto Stem TabNotes\n      const stem_weight = notes.reduce((memo, note) => memo + note.stem_direction, 0);\n      stem_direction = stem_weight > -1 ? Stem.UP : Stem.DOWN;\n    } // Apply stem directions and attach beam to notes\n\n\n    for (i = 0; i < notes.length; ++i) {\n      note = notes[i];\n\n      if (auto_stem) {\n        note.setStemDirection(stem_direction);\n        this.stem_direction = stem_direction;\n      }\n\n      note.setBeam(this);\n    }\n\n    this.postFormatted = false;\n    this.notes = notes;\n    this.beam_count = this.getBeamCount();\n    this.break_on_indices = [];\n    this.render_options = {\n      beam_width: 5,\n      max_slope: 0.25,\n      min_slope: -0.25,\n      slope_iterations: 20,\n      slope_cost: 100,\n      show_stemlets: false,\n      stemlet_extension: 7,\n      partial_beam_length: 10,\n      flat_beams: false,\n      min_flat_beam_offset: 15\n    };\n  } // Get the notes in this beam\n\n\n  getNotes() {\n    return this.notes;\n  } // Get the max number of beams in the set of notes\n\n\n  getBeamCount() {\n    const beamCounts = this.notes.map(note => note.getGlyph().beam_count);\n    const maxBeamCount = beamCounts.reduce((max, beamCount) => beamCount > max ? beamCount : max);\n    return maxBeamCount;\n  } // Set which note `indices` to break the secondary beam at\n\n\n  breakSecondaryAt(indices) {\n    this.break_on_indices = indices;\n    return this;\n  } // Return the y coordinate for linear function\n\n\n  getSlopeY(x, first_x_px, first_y_px, slope) {\n    return first_y_px + (x - first_x_px) * slope;\n  } // Calculate the best possible slope for the provided notes\n\n\n  calculateSlope() {\n    const {\n      notes,\n      stem_direction: stemDirection,\n      render_options: {\n        max_slope,\n        min_slope,\n        slope_iterations,\n        slope_cost\n      }\n    } = this;\n    const firstNote = notes[0];\n    const initialSlope = getStemSlope(firstNote, notes[notes.length - 1]);\n    const increment = (max_slope - min_slope) / slope_iterations;\n    let minCost = Number.MAX_VALUE;\n    let bestSlope = 0;\n    let yShift = 0; // iterate through slope values to find best weighted fit\n\n    for (let slope = min_slope; slope <= max_slope; slope += increment) {\n      let totalStemExtension = 0;\n      let yShiftTemp = 0; // iterate through notes, calculating y shift and stem extension\n\n      for (let i = 1; i < notes.length; ++i) {\n        const note = notes[i];\n        const adjustedStemTipY = this.getSlopeY(note.getStemX(), firstNote.getStemX(), firstNote.getStemExtents().topY, slope) + yShiftTemp;\n        const stemTipY = note.getStemExtents().topY; // beam needs to be shifted up to accommodate note\n\n        if (stemTipY * stemDirection < adjustedStemTipY * stemDirection) {\n          const diff = Math.abs(stemTipY - adjustedStemTipY);\n          yShiftTemp += diff * -stemDirection;\n          totalStemExtension += diff * i;\n        } else {\n          // beam overshoots note, account for the difference\n          totalStemExtension += (stemTipY - adjustedStemTipY) * stemDirection;\n        }\n      } // most engraving books suggest aiming for a slope about half the angle of the\n      // difference between the first and last notes' stem length;\n\n\n      const idealSlope = initialSlope / 2;\n      const distanceFromIdeal = Math.abs(idealSlope - slope); // This tries to align most beams to something closer to the idealSlope, but\n      // doesn't go crazy. To disable, set this.render_options.slope_cost = 0\n\n      const cost = slope_cost * distanceFromIdeal + Math.abs(totalStemExtension); // update state when a more ideal slope is found\n\n      if (cost < minCost) {\n        minCost = cost;\n        bestSlope = slope;\n        yShift = yShiftTemp;\n      }\n    }\n\n    this.slope = bestSlope;\n    this.y_shift = yShift;\n  } // Calculate a slope and y-shift for flat beams\n\n\n  calculateFlatSlope() {\n    const {\n      notes,\n      stem_direction,\n      render_options: {\n        beam_width,\n        min_flat_beam_offset,\n        flat_beam_offset\n      }\n    } = this; // If a flat beam offset has not yet been supplied or calculated,\n    // generate one based on the notes in this particular note group\n\n    let total = 0;\n    let extremeY = 0; // Store the highest or lowest note here\n\n    let extremeBeamCount = 0; // The beam count of the extreme note\n\n    let currentExtreme = 0;\n\n    for (let i = 0; i < notes.length; i++) {\n      // Total up all of the offsets so we can average them out later\n      const note = notes[i];\n      const stemTipY = note.getStemExtents().topY;\n      total += stemTipY; // Store the highest (stems-up) or lowest (stems-down) note so the\n      //  offset can be adjusted in case the average isn't enough\n\n      if (stem_direction === Stem.DOWN && currentExtreme < stemTipY) {\n        currentExtreme = stemTipY;\n        extremeY = Math.max(...note.getYs());\n        extremeBeamCount = note.getBeamCount();\n      } else if (stem_direction === Stem.UP && (currentExtreme === 0 || currentExtreme > stemTipY)) {\n        currentExtreme = stemTipY;\n        extremeY = Math.min(...note.getYs());\n        extremeBeamCount = note.getBeamCount();\n      }\n    } // Average the offsets to try and come up with a reasonable one that\n    //  works for all of the notes in the beam group.\n\n\n    let offset = total / notes.length; // In case the average isn't long enough, add or subtract some more\n    //  based on the highest or lowest note (again, based on the stem\n    //  direction). This also takes into account the added height due to\n    //  the width of the beams.\n\n    const beamWidth = beam_width * 1.5;\n    const extremeTest = min_flat_beam_offset + extremeBeamCount * beamWidth;\n    const newOffset = extremeY + extremeTest * -stem_direction;\n\n    if (stem_direction === Stem.DOWN && offset < newOffset) {\n      offset = extremeY + extremeTest;\n    } else if (stem_direction === Stem.UP && offset > newOffset) {\n      offset = extremeY - extremeTest;\n    }\n\n    if (!flat_beam_offset) {\n      // Set the offset for the group based on the calculations above.\n      this.render_options.flat_beam_offset = offset;\n    } else if (stem_direction === Stem.DOWN && offset > flat_beam_offset) {\n      this.render_options.flat_beam_offset = offset;\n    } else if (stem_direction === Stem.UP && offset < flat_beam_offset) {\n      this.render_options.flat_beam_offset = offset;\n    } // for flat beams, the slope and y_shift are simply 0\n\n\n    this.slope = 0;\n    this.y_shift = 0;\n  }\n\n  getBeamYToDraw() {\n    const firstNote = this.notes[0];\n    const firstStemTipY = firstNote.getStemExtents().topY;\n    let beamY = firstStemTipY; // For flat beams, set the first and last Y to the offset, rather than\n    //  using the note's stem extents.\n\n    if (this.render_options.flat_beams && this.render_options.flat_beam_offset) {\n      beamY = this.render_options.flat_beam_offset;\n    }\n\n    return beamY;\n  } // Create new stems for the notes in the beam, so that each stem\n  // extends into the beams.\n\n\n  applyStemExtensions() {\n    const {\n      notes,\n      slope,\n      y_shift,\n      stem_direction,\n      beam_count,\n      render_options: {\n        show_stemlets,\n        stemlet_extension,\n        beam_width\n      }\n    } = this;\n    const firstNote = notes[0];\n    const firstStemTipY = this.getBeamYToDraw();\n    const firstStemX = firstNote.getStemX();\n\n    for (let i = 0; i < notes.length; ++i) {\n      const note = notes[i];\n      const stemX = note.getStemX();\n      const {\n        topY: stemTipY\n      } = note.getStemExtents();\n      const beamedStemTipY = this.getSlopeY(stemX, firstStemX, firstStemTipY, slope) + y_shift;\n      const preBeamExtension = note.getStem().getExtension();\n      const beamExtension = stem_direction === Stem.UP ? stemTipY - beamedStemTipY : beamedStemTipY - stemTipY;\n      note.stem.setExtension(preBeamExtension + beamExtension);\n      note.stem.renderHeightAdjustment = -Stem.WIDTH / 2;\n\n      if (note.isRest() && show_stemlets) {\n        const beamWidth = beam_width;\n        const totalBeamWidth = (beam_count - 1) * beamWidth * 1.5 + beamWidth;\n        note.stem.setVisibility(true).setStemlet(true, totalBeamWidth + stemlet_extension);\n      }\n    }\n  } // return upper level beam direction.\n\n\n  lookupBeamDirection(duration, prev_tick, tick, next_tick) {\n    if (duration === '4') {\n      return BEAM_LEFT;\n    }\n\n    const lookup_duration = `${Flow.durationToNumber(duration) / 2}`;\n    const prev_note_gets_beam = prev_tick < Flow.durationToTicks(lookup_duration);\n    const next_note_gets_beam = next_tick < Flow.durationToTicks(lookup_duration);\n    const note_gets_beam = tick < Flow.durationToTicks(lookup_duration);\n\n    if (prev_note_gets_beam && next_note_gets_beam && note_gets_beam) {\n      return BEAM_BOTH;\n    } else if (prev_note_gets_beam && !next_note_gets_beam && note_gets_beam) {\n      return BEAM_LEFT;\n    } else if (!prev_note_gets_beam && next_note_gets_beam && note_gets_beam) {\n      return BEAM_RIGHT;\n    }\n\n    return this.lookupBeamDirection(lookup_duration, prev_tick, tick, next_tick);\n  } // Get the x coordinates for the beam lines of specific `duration`\n\n\n  getBeamLines(duration) {\n    const tick_of_duration = Flow.durationToTicks(duration);\n    const beam_lines = [];\n    let beam_started = false;\n    let current_beam = null;\n    const partial_beam_length = this.render_options.partial_beam_length;\n    let previous_should_break = false;\n    let tick_tally = 0;\n\n    for (let i = 0; i < this.notes.length; ++i) {\n      const note = this.notes[i]; // See if we need to break secondary beams on this note.\n\n      const ticks = note.ticks.value();\n      tick_tally += ticks;\n      let should_break = false; // 8th note beams are always drawn.\n\n      if (parseInt(duration, 10) >= 8) {\n        // First, check to see if any indices were set up through breakSecondaryAt()\n        should_break = this.break_on_indices.indexOf(i) !== -1; // If the secondary breaks were auto-configured in the render options,\n        //  handle that as well.\n\n        if (this.render_options.secondary_break_ticks && tick_tally >= this.render_options.secondary_break_ticks) {\n          tick_tally = 0;\n          should_break = true;\n        }\n      }\n\n      const note_gets_beam = note.getIntrinsicTicks() < tick_of_duration;\n      const stem_x = note.getStemX() - Stem.WIDTH / 2; // Check to see if the next note in the group will get a beam at this\n      //  level. This will help to inform the partial beam logic below.\n\n      const prev_note = this.notes[i - 1];\n      const next_note = this.notes[i + 1];\n      const next_note_gets_beam = next_note && next_note.getIntrinsicTicks() < tick_of_duration;\n      const prev_note_gets_beam = prev_note && prev_note.getIntrinsicTicks() < tick_of_duration;\n      const beam_alone = prev_note && next_note && note_gets_beam && !prev_note_gets_beam && !next_note_gets_beam; // const beam_alone = note_gets_beam && !prev_note_gets_beam && !next_note_gets_beam;\n\n      if (note_gets_beam) {\n        // This note gets a beam at the current level\n        if (beam_started) {\n          // We're currently in the middle of a beam. Just continue it on to\n          //  the stem X of the current note.\n          current_beam = beam_lines[beam_lines.length - 1];\n          current_beam.end = stem_x; // If a secondary beam break is set up, end the beam right now.\n\n          if (should_break) {\n            beam_started = false;\n\n            if (next_note && !next_note_gets_beam && current_beam.end === null) {\n              // This note gets a beam,.but the next one does not. This means\n              //  we need a partial pointing right.\n              current_beam.end = current_beam.start - partial_beam_length;\n            }\n          }\n        } else {\n          // No beam started yet. Start a new one.\n          current_beam = {\n            start: stem_x,\n            end: null\n          };\n          beam_started = true;\n\n          if (beam_alone) {\n            // previous and next beam exists and does not get a beam but current gets it.\n            const prev_tick = prev_note.getIntrinsicTicks();\n            const next_tick = next_note.getIntrinsicTicks();\n            const tick = note.getIntrinsicTicks();\n            const beam_direction = this.lookupBeamDirection(duration, prev_tick, tick, next_tick);\n\n            if ([BEAM_LEFT, BEAM_BOTH].includes(beam_direction)) {\n              current_beam.end = current_beam.start - partial_beam_length;\n            } else {\n              current_beam.end = current_beam.start + partial_beam_length;\n            }\n          } else if (!next_note_gets_beam) {\n            // The next note doesn't get a beam. Draw a partial.\n            if ((previous_should_break || i === 0) && next_note) {\n              // This is the first note (but not the last one), or it is\n              //  following a secondary break. Draw a partial to the right.\n              current_beam.end = current_beam.start + partial_beam_length;\n            } else {\n              // By default, draw a partial to the left.\n              current_beam.end = current_beam.start - partial_beam_length;\n            }\n          } else if (should_break) {\n            // This note should have a secondary break after it. Even though\n            //  we just started a beam, it needs to end immediately.\n            current_beam.end = current_beam.start - partial_beam_length;\n            beam_started = false;\n          }\n\n          beam_lines.push(current_beam);\n        }\n      } else {\n        // The current note does not get a beam.\n        beam_started = false;\n      } // Store the secondary break flag to inform the partial beam logic in\n      //  the next iteration of the loop.\n\n\n      previous_should_break = should_break;\n    } // Add a partial beam pointing left if this is the last note in the group\n\n\n    const last_beam = beam_lines[beam_lines.length - 1];\n\n    if (last_beam && last_beam.end === null) {\n      last_beam.end = last_beam.start - partial_beam_length;\n    }\n\n    return beam_lines;\n  } // Render the stems for each notes\n\n\n  drawStems() {\n    this.notes.forEach(note => {\n      if (note.getStem()) {\n        note.getStem().setContext(this.context).draw();\n      }\n    }, this);\n  } // Render the beam lines\n\n\n  drawBeamLines() {\n    this.checkContext();\n    const valid_beam_durations = ['4', '8', '16', '32', '64'];\n    const firstNote = this.notes[0];\n    let beamY = this.getBeamYToDraw();\n    const firstStemX = firstNote.getStemX();\n    const beamThickness = this.render_options.beam_width * this.stem_direction; // Draw the beams.\n\n    for (let i = 0; i < valid_beam_durations.length; ++i) {\n      const duration = valid_beam_durations[i];\n      const beamLines = this.getBeamLines(duration);\n\n      for (let j = 0; j < beamLines.length; ++j) {\n        const beam_line = beamLines[j];\n        const startBeamX = beam_line.start;\n        const startBeamY = this.getSlopeY(startBeamX, firstStemX, beamY, this.slope);\n        const lastBeamX = beam_line.end;\n        const lastBeamY = this.getSlopeY(lastBeamX, firstStemX, beamY, this.slope);\n        this.context.beginPath();\n        this.context.moveTo(startBeamX, startBeamY);\n        this.context.lineTo(startBeamX, startBeamY + beamThickness);\n        this.context.lineTo(lastBeamX + 1, lastBeamY + beamThickness);\n        this.context.lineTo(lastBeamX + 1, lastBeamY);\n        this.context.closePath();\n        this.context.fill();\n      }\n\n      beamY += beamThickness * 1.5;\n    }\n  } // Pre-format the beam\n\n\n  preFormat() {\n    return this;\n  } // Post-format the beam. This can only be called after\n  // the notes in the beam have both `x` and `y` values. ie: they've\n  // been formatted and have staves\n\n\n  postFormat() {\n    if (this.postFormatted) return; // Calculate a smart slope if we're not forcing the beams to be flat.\n\n    if (this.notes[0].getCategory() === 'tabnotes' || this.render_options.flat_beams) {\n      this.calculateFlatSlope();\n    } else {\n      this.calculateSlope();\n    }\n\n    this.applyStemExtensions();\n    this.postFormatted = true;\n  } // Render the beam to the canvas context\n\n\n  draw() {\n    this.checkContext();\n    this.setRendered();\n    if (this.unbeamable) return;\n\n    if (!this.postFormatted) {\n      this.postFormat();\n    }\n\n    this.drawStems();\n    this.applyStyle();\n    this.drawBeamLines();\n    this.restoreStyle();\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/beam.js"],"names":["Vex","Flow","Element","Fraction","Tuplet","Stem","calculateStemDirection","notes","lineSum","forEach","note","keyProps","keyProp","line","DOWN","UP","getStemSlope","firstNote","lastNote","firstStemTipY","getStemExtents","topY","firstStemX","getStemX","lastStemTipY","lastStemX","BEAM_LEFT","BEAM_RIGHT","BEAM_BOTH","Beam","getDefaultBeamGroups","time_sig","defaults","groups","undefined","beatTotal","parseInt","split","beatValue","tripleMeter","map","group","parse","applyAndGetBeams","voice","stem_direction","generateBeams","getTickables","config","length","tickGroups","multiply","RuntimeError","clone","RESOLUTION","unprocessedNotes","currentTickGroup","noteGroups","currentGroup","getTotalTicks","vf_notes","reduce","memo","getTicks","add","nextTickGroup","createGroups","nextGroup","unprocessedNote","shouldIgnoreTicks","push","ticksPerGroup","totalTicks","unbeamable","durationToNumber","duration","tuplet","numerator","greaterThan","pop","equals","getBeamGroups","filter","beamable","getIntrinsicTicks","durationToTicks","sanitizeGroups","sanitizedGroups","tempGroup","index","isFirstOrLast","prevNote","breaksOnEachRest","beam_rests","isRest","breaksOnFirstOrLastRest","beam_middle_only","breakOnStemChange","maintain_stem_directions","prevDirection","getStemDirection","currentDirection","isUnbeamableDuration","shouldBreak","formatStems","stemDirection","findFirstNote","applyStemDirection","i","direction","setStemDirection","getTuplets","uniqueTuplets","beamedNoteGroups","allTuplets","beams","beam","show_stemlets","render_options","secondary_breaks","secondary_break_ticks","flat_beams","flat_beam_offset","LOCATION_BOTTOM","LOCATION_TOP","setTupletLocation","bracketed","setBracketed","constructor","auto_stem","setAttribute","ticks","hasStem","getCategory","stem_weight","setBeam","postFormatted","beam_count","getBeamCount","break_on_indices","beam_width","max_slope","min_slope","slope_iterations","slope_cost","stemlet_extension","partial_beam_length","min_flat_beam_offset","getNotes","beamCounts","getGlyph","maxBeamCount","max","beamCount","breakSecondaryAt","indices","getSlopeY","x","first_x_px","first_y_px","slope","calculateSlope","initialSlope","increment","minCost","Number","MAX_VALUE","bestSlope","yShift","totalStemExtension","yShiftTemp","adjustedStemTipY","stemTipY","diff","Math","abs","idealSlope","distanceFromIdeal","cost","y_shift","calculateFlatSlope","total","extremeY","extremeBeamCount","currentExtreme","getYs","min","offset","beamWidth","extremeTest","newOffset","getBeamYToDraw","beamY","applyStemExtensions","stemX","beamedStemTipY","preBeamExtension","getStem","getExtension","beamExtension","stem","setExtension","renderHeightAdjustment","WIDTH","totalBeamWidth","setVisibility","setStemlet","lookupBeamDirection","prev_tick","tick","next_tick","lookup_duration","prev_note_gets_beam","next_note_gets_beam","note_gets_beam","getBeamLines","tick_of_duration","beam_lines","beam_started","current_beam","previous_should_break","tick_tally","value","should_break","indexOf","stem_x","prev_note","next_note","beam_alone","end","start","beam_direction","includes","last_beam","drawStems","setContext","context","draw","drawBeamLines","checkContext","valid_beam_durations","beamThickness","beamLines","j","beam_line","startBeamX","startBeamY","lastBeamX","lastBeamY","beginPath","moveTo","lineTo","closePath","fill","preFormat","postFormat","setRendered","applyStyle","restoreStyle"],"mappings":"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","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n//\n// This file implements `Beams` that span over a set of `StemmableNotes`.\n\nimport { Vex } from './vex';\nimport { Flow } from './tables';\nimport { Element } from './element';\nimport { Fraction } from './fraction';\nimport { Tuplet } from './tuplet';\nimport { Stem } from './stem';\n\nfunction calculateStemDirection(notes) {\n  let lineSum = 0;\n  notes.forEach(note => {\n    if (note.keyProps) {\n      note.keyProps.forEach(keyProp => {\n        lineSum += (keyProp.line - 3);\n      });\n    }\n  });\n\n  if (lineSum >= 0) {\n    return Stem.DOWN;\n  }\n  return Stem.UP;\n}\n\nconst getStemSlope = (firstNote, lastNote) => {\n  const firstStemTipY = firstNote.getStemExtents().topY;\n  const firstStemX = firstNote.getStemX();\n  const lastStemTipY = lastNote.getStemExtents().topY;\n  const lastStemX = lastNote.getStemX();\n  return (lastStemTipY - firstStemTipY) / (lastStemX - firstStemX);\n};\n\nconst BEAM_LEFT = 'L';\nconst BEAM_RIGHT = 'R';\nconst BEAM_BOTH = 'B';\n\nexport class Beam extends Element {\n  // Gets the default beam groups for a provided time signature.\n  // Attempts to guess if the time signature is not found in table.\n  // Currently this is fairly naive.\n  static getDefaultBeamGroups(time_sig) {\n    if (!time_sig || time_sig === 'c') {\n      time_sig = '4/4';\n    }\n\n    const defaults = {\n      '1/2': ['1/2'],\n      '2/2': ['1/2'],\n      '3/2': ['1/2'],\n      '4/2': ['1/2'],\n\n      '1/4': ['1/4'],\n      '2/4': ['1/4'],\n      '3/4': ['1/4'],\n      '4/4': ['1/4'],\n\n      '1/8': ['1/8'],\n      '2/8': ['2/8'],\n      '3/8': ['3/8'],\n      '4/8': ['2/8'],\n\n      '1/16': ['1/16'],\n      '2/16': ['2/16'],\n      '3/16': ['3/16'],\n      '4/16': ['2/16'],\n    };\n\n    const groups = defaults[time_sig];\n\n    if (groups === undefined) {\n      // If no beam groups found, naively determine\n      // the beam groupings from the time signature\n      const beatTotal = parseInt(time_sig.split('/')[0], 10);\n      const beatValue = parseInt(time_sig.split('/')[1], 10);\n\n      const tripleMeter = beatTotal % 3 === 0;\n\n      if (tripleMeter) {\n        return [new Fraction(3, beatValue)];\n      } else if (beatValue > 4) {\n        return [new Fraction(2, beatValue)];\n      } else if (beatValue <= 4) {\n        return [new Fraction(1, beatValue)];\n      }\n    } else {\n      return groups.map(group => new Fraction().parse(group));\n    }\n\n    return [new Fraction(1, 4)];\n  }\n\n  // A helper function to automatically build basic beams for a voice. For more\n  // complex auto-beaming use `Beam.generateBeams()`.\n  //\n  // Parameters:\n  // * `voice` - The voice to generate the beams for\n  // * `stem_direction` - A stem direction to apply to the entire voice\n  // * `groups` - An array of `Fraction` representing beat groupings for the beam\n  static applyAndGetBeams(voice, stem_direction, groups) {\n    return Beam.generateBeams(voice.getTickables(), {\n      groups,\n      stem_direction,\n    });\n  }\n\n  // A helper function to autimatically build beams for a voice with\n  // configuration options.\n  //\n  // Example configuration object:\n  //\n  // ```\n  // config = {\n  //   groups: [new Vex.Flow.Fraction(2, 8)],\n  //   stem_direction: -1,\n  //   beam_rests: true,\n  //   beam_middle_only: true,\n  //   show_stemlets: false\n  // };\n  // ```\n  //\n  // Parameters:\n  // * `notes` - An array of notes to create the beams for\n  // * `config` - The configuration object\n  //    * `groups` - Array of `Fractions` that represent the beat structure to beam the notes\n  //    * `stem_direction` - Set to apply the same direction to all notes\n  //    * `beam_rests` - Set to `true` to include rests in the beams\n  //    * `beam_middle_only` - Set to `true` to only beam rests in the middle of the beat\n  //    * `show_stemlets` - Set to `true` to draw stemlets for rests\n  //    * `maintain_stem_directions` - Set to `true` to not apply new stem directions\n  //\n  static generateBeams(notes, config) {\n    if (!config) config = {};\n\n    if (!config.groups || !config.groups.length) {\n      config.groups = [new Fraction(2, 8)];\n    }\n\n    // Convert beam groups to tick amounts\n    const tickGroups = config.groups.map(group => {\n      if (!group.multiply) {\n        throw new Vex.RuntimeError('InvalidBeamGroups',\n          'The beam groups must be an array of Vex.Flow.Fractions');\n      }\n      return group.clone().multiply(Flow.RESOLUTION, 1);\n    });\n\n    const unprocessedNotes = notes;\n    let currentTickGroup = 0;\n    let noteGroups = [];\n    let currentGroup = [];\n\n    function getTotalTicks(vf_notes) {\n      return vf_notes.reduce((memo, note) => note.getTicks().clone().add(memo), new Fraction(0, 1));\n    }\n\n    function nextTickGroup() {\n      if (tickGroups.length - 1 > currentTickGroup) {\n        currentTickGroup += 1;\n      } else {\n        currentTickGroup = 0;\n      }\n    }\n\n    function createGroups() {\n      let nextGroup = [];\n\n      unprocessedNotes.forEach(unprocessedNote => {\n        nextGroup = [];\n        if (unprocessedNote.shouldIgnoreTicks()) {\n          noteGroups.push(currentGroup);\n          currentGroup = nextGroup;\n          return; // Ignore untickables (like bar notes)\n        }\n\n        currentGroup.push(unprocessedNote);\n        const ticksPerGroup = tickGroups[currentTickGroup].clone();\n        const totalTicks = getTotalTicks(currentGroup);\n\n        // Double the amount of ticks in a group, if it's an unbeamable tuplet\n        const unbeamable = Flow.durationToNumber(unprocessedNote.duration) < 8;\n        if (unbeamable && unprocessedNote.tuplet) {\n          ticksPerGroup.numerator *= 2;\n        }\n\n        // If the note that was just added overflows the group tick total\n        if (totalTicks.greaterThan(ticksPerGroup)) {\n          // If the overflow note can be beamed, start the next group\n          // with it. Unbeamable notes leave the group overflowed.\n          if (!unbeamable) {\n            nextGroup.push(currentGroup.pop());\n          }\n          noteGroups.push(currentGroup);\n          currentGroup = nextGroup;\n          nextTickGroup();\n        } else if (totalTicks.equals(ticksPerGroup)) {\n          noteGroups.push(currentGroup);\n          currentGroup = nextGroup;\n          nextTickGroup();\n        }\n      });\n\n      // Adds any remainder notes\n      if (currentGroup.length > 0) {\n        noteGroups.push(currentGroup);\n      }\n    }\n\n    function getBeamGroups() {\n      return noteGroups.filter(group => {\n        if (group.length > 1) {\n          let beamable = true;\n          group.forEach(note => {\n            if (note.getIntrinsicTicks() >= Flow.durationToTicks('4')) {\n              beamable = false;\n            }\n          });\n          return beamable;\n        }\n        return false;\n      });\n    }\n\n    // Splits up groups by Rest\n    function sanitizeGroups() {\n      const sanitizedGroups = [];\n      noteGroups.forEach(group => {\n        let tempGroup = [];\n        group.forEach((note, index, group) => {\n          const isFirstOrLast = index === 0 || index === group.length - 1;\n          const prevNote = group[index - 1];\n\n          const breaksOnEachRest = !config.beam_rests && note.isRest();\n          const breaksOnFirstOrLastRest = (config.beam_rests &&\n            config.beam_middle_only && note.isRest() && isFirstOrLast);\n\n          let breakOnStemChange = false;\n          if (config.maintain_stem_directions && prevNote &&\n            !note.isRest() && !prevNote.isRest()) {\n            const prevDirection = prevNote.getStemDirection();\n            const currentDirection = note.getStemDirection();\n            breakOnStemChange = currentDirection !== prevDirection;\n          }\n\n          const isUnbeamableDuration = parseInt(note.duration, 10) < 8;\n\n          // Determine if the group should be broken at this note\n          const shouldBreak = breaksOnEachRest || breaksOnFirstOrLastRest ||\n            breakOnStemChange || isUnbeamableDuration;\n\n          if (shouldBreak) {\n            // Add current group\n            if (tempGroup.length > 0) {\n              sanitizedGroups.push(tempGroup);\n            }\n\n            // Start a new group. Include the current note if the group\n            // was broken up by stem direction, as that note needs to start\n            // the next group of notes\n            tempGroup = breakOnStemChange ? [note] : [];\n          } else {\n            // Add note to group\n            tempGroup.push(note);\n          }\n        });\n\n        // If there is a remaining group, add it as well\n        if (tempGroup.length > 0) {\n          sanitizedGroups.push(tempGroup);\n        }\n      });\n\n      noteGroups = sanitizedGroups;\n    }\n\n    function formatStems() {\n      noteGroups.forEach(group => {\n        let stemDirection;\n        if (config.maintain_stem_directions) {\n          const note = findFirstNote(group);\n          stemDirection = note ? note.getStemDirection() : Stem.UP;\n        } else {\n          if (config.stem_direction) {\n            stemDirection = config.stem_direction;\n          } else {\n            stemDirection = calculateStemDirection(group);\n          }\n        }\n        applyStemDirection(group, stemDirection);\n      });\n    }\n\n    function findFirstNote(group) {\n      for (let i = 0; i < group.length; i++) {\n        const note = group[i];\n        if (!note.isRest()) {\n          return note;\n        }\n      }\n\n      return false;\n    }\n\n    function applyStemDirection(group, direction) {\n      group.forEach(note => {\n        note.setStemDirection(direction);\n      });\n    }\n\n    // Get all of the tuplets in all of the note groups\n    function getTuplets() {\n      const uniqueTuplets = [];\n\n      // Go through all of the note groups and inspect for tuplets\n      noteGroups.forEach(group => {\n        let tuplet = null;\n        group.forEach(note => {\n          if (note.tuplet && (tuplet !== note.tuplet)) {\n            tuplet = note.tuplet;\n            uniqueTuplets.push(tuplet);\n          }\n        });\n      });\n      return uniqueTuplets;\n    }\n\n\n    // Using closures to store the variables throughout the various functions\n    // IMO Keeps it this process lot cleaner - but not super consistent with\n    // the rest of the API's style - Silverwolf90 (Cyril)\n    createGroups();\n    sanitizeGroups();\n    formatStems();\n\n    // Get the notes to be beamed\n    const beamedNoteGroups = getBeamGroups();\n\n    // Get the tuplets in order to format them accurately\n    const allTuplets = getTuplets();\n\n    // Create a Vex.Flow.Beam from each group of notes to be beamed\n    const beams = [];\n    beamedNoteGroups.forEach(group => {\n      const beam = new Beam(group);\n\n      if (config.show_stemlets) {\n        beam.render_options.show_stemlets = true;\n      }\n      if (config.secondary_breaks) {\n        beam.render_options.secondary_break_ticks = Flow.durationToTicks(config.secondary_breaks);\n      }\n      if (config.flat_beams === true) {\n        beam.render_options.flat_beams = true;\n        beam.render_options.flat_beam_offset = config.flat_beam_offset;\n      }\n      beams.push(beam);\n    });\n\n    // Reformat tuplets\n    allTuplets.forEach(tuplet => {\n      // Set the tuplet location based on the stem direction\n      const direction = tuplet.notes[0].stem_direction === Stem.DOWN ?\n        Tuplet.LOCATION_BOTTOM : Tuplet.LOCATION_TOP;\n      tuplet.setTupletLocation(direction);\n\n      // If any of the notes in the tuplet are not beamed, draw a bracket.\n      let bracketed = false;\n      for (let i = 0; i < tuplet.notes.length; i++) {\n        const note = tuplet.notes[i];\n        if (note.beam === null) {\n          bracketed = true;\n          break;\n        }\n      }\n      tuplet.setBracketed(bracketed);\n    });\n\n    return beams;\n  }\n\n  constructor(notes, auto_stem) {\n    super();\n    this.setAttribute('type', 'Beam');\n\n    if (!notes || notes === []) {\n      throw new Vex.RuntimeError('BadArguments', 'No notes provided for beam.');\n    }\n\n    if (notes.length === 1) {\n      throw new Vex.RuntimeError('BadArguments', 'Too few notes for beam.');\n    }\n\n    // Validate beam line, direction and ticks.\n    this.ticks = notes[0].getIntrinsicTicks();\n\n    if (this.ticks >= Flow.durationToTicks('4')) {\n      throw new Vex.RuntimeError('BadArguments',\n        'Beams can only be applied to notes shorter than a quarter note.');\n    }\n\n    let i; // shared iterator\n    let note;\n\n    this.stem_direction = Stem.UP;\n\n    for (i = 0; i < notes.length; ++i) {\n      note = notes[i];\n      if (note.hasStem()) {\n        this.stem_direction = note.getStemDirection();\n        break;\n      }\n    }\n\n    let stem_direction = this.stem_direction;\n    // Figure out optimal stem direction based on given notes\n    if (auto_stem && notes[0].getCategory() === 'stavenotes') {\n      stem_direction = calculateStemDirection(notes);\n    } else if (auto_stem && notes[0].getCategory() === 'tabnotes') {\n      // Auto Stem TabNotes\n      const stem_weight = notes.reduce((memo, note) => memo + note.stem_direction, 0);\n\n      stem_direction = stem_weight > -1 ? Stem.UP : Stem.DOWN;\n    }\n\n    // Apply stem directions and attach beam to notes\n    for (i = 0; i < notes.length; ++i) {\n      note = notes[i];\n      if (auto_stem) {\n        note.setStemDirection(stem_direction);\n        this.stem_direction = stem_direction;\n      }\n      note.setBeam(this);\n    }\n\n    this.postFormatted = false;\n    this.notes = notes;\n    this.beam_count = this.getBeamCount();\n    this.break_on_indices = [];\n    this.render_options = {\n      beam_width: 5,\n      max_slope: 0.25,\n      min_slope: -0.25,\n      slope_iterations: 20,\n      slope_cost: 100,\n      show_stemlets: false,\n      stemlet_extension: 7,\n      partial_beam_length: 10,\n      flat_beams: false,\n      min_flat_beam_offset: 15,\n    };\n  }\n\n  // Get the notes in this beam\n  getNotes() { return this.notes; }\n\n  // Get the max number of beams in the set of notes\n  getBeamCount() {\n    const beamCounts = this.notes.map(note => note.getGlyph().beam_count);\n\n    const maxBeamCount = beamCounts.reduce((max, beamCount) => beamCount > max ? beamCount : max);\n\n    return maxBeamCount;\n  }\n\n  // Set which note `indices` to break the secondary beam at\n  breakSecondaryAt(indices) {\n    this.break_on_indices = indices;\n    return this;\n  }\n\n  // Return the y coordinate for linear function\n  getSlopeY(x, first_x_px, first_y_px, slope) {\n    return first_y_px + ((x - first_x_px) * slope);\n  }\n\n  // Calculate the best possible slope for the provided notes\n  calculateSlope() {\n    const {\n      notes,\n      stem_direction: stemDirection,\n      render_options: { max_slope, min_slope, slope_iterations, slope_cost },\n    } = this;\n\n    const firstNote = notes[0];\n    const initialSlope = getStemSlope(firstNote, notes[notes.length - 1]);\n    const increment = (max_slope - min_slope) / slope_iterations;\n    let minCost = Number.MAX_VALUE;\n    let bestSlope = 0;\n    let yShift = 0;\n\n    // iterate through slope values to find best weighted fit\n    for (let slope = min_slope; slope <= max_slope; slope += increment) {\n      let totalStemExtension = 0;\n      let yShiftTemp = 0;\n\n      // iterate through notes, calculating y shift and stem extension\n      for (let i = 1; i < notes.length; ++i) {\n        const note = notes[i];\n        const adjustedStemTipY = this.getSlopeY(\n          note.getStemX(),\n          firstNote.getStemX(),\n          firstNote.getStemExtents().topY,\n          slope\n        ) + yShiftTemp;\n\n        const stemTipY = note.getStemExtents().topY;\n        // beam needs to be shifted up to accommodate note\n        if (stemTipY * stemDirection < adjustedStemTipY * stemDirection) {\n          const diff = Math.abs(stemTipY - adjustedStemTipY);\n          yShiftTemp += diff * -stemDirection;\n          totalStemExtension += diff * i;\n        } else { // beam overshoots note, account for the difference\n          totalStemExtension += (stemTipY - adjustedStemTipY) * stemDirection;\n        }\n      }\n\n      // most engraving books suggest aiming for a slope about half the angle of the\n      // difference between the first and last notes' stem length;\n      const idealSlope = initialSlope / 2;\n      const distanceFromIdeal = Math.abs(idealSlope - slope);\n\n      // This tries to align most beams to something closer to the idealSlope, but\n      // doesn't go crazy. To disable, set this.render_options.slope_cost = 0\n      const cost = slope_cost * distanceFromIdeal + Math.abs(totalStemExtension);\n\n      // update state when a more ideal slope is found\n      if (cost < minCost) {\n        minCost = cost;\n        bestSlope = slope;\n        yShift = yShiftTemp;\n      }\n    }\n\n    this.slope = bestSlope;\n    this.y_shift = yShift;\n  }\n\n  // Calculate a slope and y-shift for flat beams\n  calculateFlatSlope() {\n    const {\n      notes, stem_direction,\n      render_options: { beam_width, min_flat_beam_offset, flat_beam_offset },\n    } = this;\n\n    // If a flat beam offset has not yet been supplied or calculated,\n    // generate one based on the notes in this particular note group\n    let total = 0;\n    let extremeY = 0;  // Store the highest or lowest note here\n    let extremeBeamCount = 0;  // The beam count of the extreme note\n    let currentExtreme = 0;\n    for (let i = 0; i < notes.length; i++) {\n      // Total up all of the offsets so we can average them out later\n      const note = notes[i];\n      const stemTipY = note.getStemExtents().topY;\n      total += stemTipY;\n\n      // Store the highest (stems-up) or lowest (stems-down) note so the\n      //  offset can be adjusted in case the average isn't enough\n      if (stem_direction === Stem.DOWN && currentExtreme < stemTipY) {\n        currentExtreme = stemTipY;\n        extremeY = Math.max(...note.getYs());\n        extremeBeamCount = note.getBeamCount();\n      } else if (\n        stem_direction === Stem.UP && (currentExtreme === 0 || currentExtreme > stemTipY)\n      ) {\n        currentExtreme = stemTipY;\n        extremeY = Math.min(...note.getYs());\n        extremeBeamCount = note.getBeamCount();\n      }\n    }\n\n    // Average the offsets to try and come up with a reasonable one that\n    //  works for all of the notes in the beam group.\n    let offset = total / notes.length;\n\n    // In case the average isn't long enough, add or subtract some more\n    //  based on the highest or lowest note (again, based on the stem\n    //  direction). This also takes into account the added height due to\n    //  the width of the beams.\n    const beamWidth = beam_width * 1.5;\n    const extremeTest = min_flat_beam_offset + (extremeBeamCount * beamWidth);\n    const newOffset = extremeY + (extremeTest * -stem_direction);\n    if (stem_direction === Stem.DOWN && offset < newOffset) {\n      offset = extremeY + extremeTest;\n    } else if (stem_direction === Stem.UP && offset > newOffset) {\n      offset = extremeY - extremeTest;\n    }\n\n    if (!flat_beam_offset) {\n      // Set the offset for the group based on the calculations above.\n      this.render_options.flat_beam_offset = offset;\n    } else if (stem_direction === Stem.DOWN && offset > flat_beam_offset) {\n      this.render_options.flat_beam_offset = offset;\n    } else if (stem_direction === Stem.UP && offset < flat_beam_offset) {\n      this.render_options.flat_beam_offset = offset;\n    }\n\n    // for flat beams, the slope and y_shift are simply 0\n    this.slope = 0;\n    this.y_shift = 0;\n  }\n\n  getBeamYToDraw() {\n    const firstNote = this.notes[0];\n    const firstStemTipY = firstNote.getStemExtents().topY;\n    let beamY = firstStemTipY;\n\n    // For flat beams, set the first and last Y to the offset, rather than\n    //  using the note's stem extents.\n    if (this.render_options.flat_beams && this.render_options.flat_beam_offset) {\n      beamY = this.render_options.flat_beam_offset;\n    }\n    return beamY;\n  }\n\n  // Create new stems for the notes in the beam, so that each stem\n  // extends into the beams.\n  applyStemExtensions() {\n    const {\n      notes, slope, y_shift, stem_direction, beam_count,\n      render_options: {\n        show_stemlets,\n        stemlet_extension,\n        beam_width,\n      },\n    } = this;\n\n    const firstNote = notes[0];\n    const firstStemTipY = this.getBeamYToDraw();\n    const firstStemX = firstNote.getStemX();\n\n    for (let i = 0; i < notes.length; ++i) {\n      const note = notes[i];\n      const stemX = note.getStemX();\n      const { topY: stemTipY } = note.getStemExtents();\n      const beamedStemTipY = this.getSlopeY(stemX, firstStemX, firstStemTipY, slope) + y_shift;\n      const preBeamExtension = note.getStem().getExtension();\n      const beamExtension = stem_direction === Stem.UP\n        ? stemTipY - beamedStemTipY\n        : beamedStemTipY - stemTipY;\n\n      note.stem.setExtension(preBeamExtension + beamExtension);\n      note.stem.renderHeightAdjustment = -Stem.WIDTH / 2;\n\n      if (note.isRest() && show_stemlets) {\n        const beamWidth = beam_width;\n        const totalBeamWidth = ((beam_count - 1) * beamWidth * 1.5) + beamWidth;\n        note.stem\n          .setVisibility(true)\n          .setStemlet(true, totalBeamWidth + stemlet_extension);\n      }\n    }\n  }\n\n  // return upper level beam direction.\n  lookupBeamDirection(duration, prev_tick, tick, next_tick) {\n    if (duration === '4') {\n      return BEAM_LEFT;\n    }\n\n    const lookup_duration =  `${Flow.durationToNumber(duration) / 2}`;\n    const prev_note_gets_beam = prev_tick < Flow.durationToTicks(lookup_duration);\n    const next_note_gets_beam = next_tick < Flow.durationToTicks(lookup_duration);\n    const note_gets_beam = tick < Flow.durationToTicks(lookup_duration);\n\n    if (prev_note_gets_beam && next_note_gets_beam && note_gets_beam) {\n      return BEAM_BOTH;\n    } else if (prev_note_gets_beam && !next_note_gets_beam && note_gets_beam) {\n      return BEAM_LEFT;\n    } else if (!prev_note_gets_beam && next_note_gets_beam && note_gets_beam) {\n      return BEAM_RIGHT;\n    }\n\n    return this.lookupBeamDirection(lookup_duration, prev_tick, tick, next_tick);\n  }\n\n  // Get the x coordinates for the beam lines of specific `duration`\n  getBeamLines(duration) {\n    const tick_of_duration = Flow.durationToTicks(duration);\n    const beam_lines = [];\n    let beam_started = false;\n    let current_beam = null;\n    const partial_beam_length = this.render_options.partial_beam_length;\n    let previous_should_break = false;\n    let tick_tally = 0;\n    for (let i = 0; i < this.notes.length; ++i) {\n      const note = this.notes[i];\n\n      // See if we need to break secondary beams on this note.\n      const ticks = note.ticks.value();\n      tick_tally += ticks;\n      let should_break = false;\n\n      // 8th note beams are always drawn.\n      if (parseInt(duration, 10) >= 8) {\n        // First, check to see if any indices were set up through breakSecondaryAt()\n        should_break = this.break_on_indices.indexOf(i) !== -1;\n\n        // If the secondary breaks were auto-configured in the render options,\n        //  handle that as well.\n        if (this.render_options.secondary_break_ticks && tick_tally >=\n          this.render_options.secondary_break_ticks) {\n          tick_tally = 0;\n          should_break = true;\n        }\n      }\n      const note_gets_beam = note.getIntrinsicTicks() < tick_of_duration;\n\n      const stem_x = note.getStemX() - (Stem.WIDTH / 2);\n\n      // Check to see if the next note in the group will get a beam at this\n      //  level. This will help to inform the partial beam logic below.\n      const prev_note = this.notes[i - 1];\n      const next_note = this.notes[i + 1];\n      const next_note_gets_beam = next_note && next_note.getIntrinsicTicks() < tick_of_duration;\n      const prev_note_gets_beam = prev_note && prev_note.getIntrinsicTicks() < tick_of_duration;\n      const beam_alone = prev_note && next_note &&\n      note_gets_beam && !prev_note_gets_beam && !next_note_gets_beam;\n      // const beam_alone = note_gets_beam && !prev_note_gets_beam && !next_note_gets_beam;\n      if (note_gets_beam) {\n        // This note gets a beam at the current level\n        if (beam_started) {\n          // We're currently in the middle of a beam. Just continue it on to\n          //  the stem X of the current note.\n          current_beam = beam_lines[beam_lines.length - 1];\n          current_beam.end = stem_x;\n\n          // If a secondary beam break is set up, end the beam right now.\n          if (should_break) {\n            beam_started = false;\n            if (next_note && !next_note_gets_beam && current_beam.end === null) {\n              // This note gets a beam,.but the next one does not. This means\n              //  we need a partial pointing right.\n              current_beam.end = current_beam.start - partial_beam_length;\n            }\n          }\n        } else {\n          // No beam started yet. Start a new one.\n          current_beam = { start: stem_x, end: null };\n          beam_started = true;\n\n          if (beam_alone) {\n            // previous and next beam exists and does not get a beam but current gets it.\n            const prev_tick = prev_note.getIntrinsicTicks();\n            const next_tick = next_note.getIntrinsicTicks();\n            const tick = note.getIntrinsicTicks();\n            const beam_direction = this.lookupBeamDirection(duration, prev_tick, tick, next_tick);\n\n            if ([BEAM_LEFT, BEAM_BOTH].includes(beam_direction)) {\n              current_beam.end = current_beam.start - partial_beam_length;\n            } else {\n              current_beam.end = current_beam.start + partial_beam_length;\n            }\n          } else if (!next_note_gets_beam) {\n            // The next note doesn't get a beam. Draw a partial.\n            if ((previous_should_break || i === 0) && next_note) {\n              // This is the first note (but not the last one), or it is\n              //  following a secondary break. Draw a partial to the right.\n              current_beam.end = current_beam.start + partial_beam_length;\n            } else {\n              // By default, draw a partial to the left.\n              current_beam.end = current_beam.start - partial_beam_length;\n            }\n          } else if (should_break) {\n            // This note should have a secondary break after it. Even though\n            //  we just started a beam, it needs to end immediately.\n            current_beam.end = current_beam.start - partial_beam_length;\n            beam_started = false;\n          }\n          beam_lines.push(current_beam);\n        }\n      } else {\n        // The current note does not get a beam.\n        beam_started = false;\n      }\n\n      // Store the secondary break flag to inform the partial beam logic in\n      //  the next iteration of the loop.\n      previous_should_break = should_break;\n    }\n\n    // Add a partial beam pointing left if this is the last note in the group\n    const last_beam = beam_lines[beam_lines.length - 1];\n    if (last_beam && last_beam.end === null) {\n      last_beam.end = last_beam.start - partial_beam_length;\n    }\n    return beam_lines;\n  }\n\n  // Render the stems for each notes\n  drawStems() {\n    this.notes.forEach(note => {\n      if (note.getStem()) {\n        note.getStem().setContext(this.context).draw();\n      }\n    }, this);\n  }\n\n  // Render the beam lines\n  drawBeamLines() {\n    this.checkContext();\n\n    const valid_beam_durations = ['4', '8', '16', '32', '64'];\n\n    const firstNote = this.notes[0];\n    let beamY = this.getBeamYToDraw();\n    const firstStemX = firstNote.getStemX();\n    const beamThickness = this.render_options.beam_width * this.stem_direction;\n\n    // Draw the beams.\n    for (let i = 0; i < valid_beam_durations.length; ++i) {\n      const duration = valid_beam_durations[i];\n      const beamLines = this.getBeamLines(duration);\n\n      for (let j = 0; j < beamLines.length; ++j) {\n        const beam_line = beamLines[j];\n        const startBeamX = beam_line.start;\n\n        const startBeamY = this.getSlopeY(startBeamX, firstStemX, beamY, this.slope);\n        const lastBeamX = beam_line.end;\n        const lastBeamY = this.getSlopeY(lastBeamX, firstStemX, beamY, this.slope);\n\n        this.context.beginPath();\n        this.context.moveTo(startBeamX, startBeamY);\n        this.context.lineTo(startBeamX, startBeamY + beamThickness);\n        this.context.lineTo(lastBeamX + 1, lastBeamY + beamThickness);\n        this.context.lineTo(lastBeamX + 1, lastBeamY);\n        this.context.closePath();\n        this.context.fill();\n      }\n\n      beamY += beamThickness * 1.5;\n    }\n  }\n\n  // Pre-format the beam\n  preFormat() { return this; }\n\n  // Post-format the beam. This can only be called after\n  // the notes in the beam have both `x` and `y` values. ie: they've\n  // been formatted and have staves\n  postFormat() {\n    if (this.postFormatted) return;\n\n    // Calculate a smart slope if we're not forcing the beams to be flat.\n    if (this.notes[0].getCategory() === 'tabnotes' || this.render_options.flat_beams) {\n      this.calculateFlatSlope();\n    } else {\n      this.calculateSlope();\n    }\n    this.applyStemExtensions();\n\n    this.postFormatted = true;\n  }\n\n  // Render the beam to the canvas context\n  draw() {\n    this.checkContext();\n    this.setRendered();\n    if (this.unbeamable) return;\n\n    if (!this.postFormatted) {\n      this.postFormat();\n    }\n\n    this.drawStems();\n    this.applyStyle();\n    this.drawBeamLines();\n    this.restoreStyle();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}