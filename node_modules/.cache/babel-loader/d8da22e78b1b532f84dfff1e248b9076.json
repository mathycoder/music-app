{"ast":null,"code":"// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n// @author Mohit Cheppudira\n//\n// ## Description\n//\n// This file implements a registry for VexFlow elements. It allows users\n// to track, query, and manage some subset of generated elements, and\n// dynamically get and set attributes.\n//\n// There are two ways to regiser with a registry:\n//\n// 1) Explicitly call `element.register(registry)`, or,\n// 2) Call `Registry.enableDefaultRegistry(registry)` when ready, and all future\n//    elements will automatically register with it.\n//\n// Once an element is registered, selected attributes are tracked and indexed by\n// the registry. This allows fast look up of elements by attributes like id, type,\n// and class.\nimport { Vex } from './vex';\nexport const X = Vex.MakeException('RegistryError');\n\nfunction setIndexValue(index, name, value, id, elem) {\n  if (!index[name][value]) index[name][value] = {};\n  index[name][value][id] = elem;\n}\n\nexport class Registry {\n  static get INDEXES() {\n    return ['type'];\n  }\n\n  constructor() {\n    this.clear();\n  } // If you call `enableDefaultRegistry`, any new elements will auto-register with\n  // the provided registry as soon as they're constructed.\n\n\n  static enableDefaultRegistry(registry) {\n    Registry.defaultRegistry = registry;\n  }\n\n  static getDefaultRegistry() {\n    return Registry.defaultRegistry;\n  }\n\n  static disableDefaultRegistry() {\n    Registry.defaultRegistry = null;\n  }\n\n  clear() {\n    // Indexes are represented as maps of maps (of maps). This allows\n    // for both multi-labeling (e.g., an element can have multiple classes)\n    // and efficient lookup.\n    this.index = {\n      id: {},\n      type: {},\n      class: {}\n    };\n    return this;\n  } // Updates the indexes for element 'id'. If an element's attribute changes\n  // from A -> B, make sure to remove the element from A.\n\n\n  updateIndex({\n    id,\n    name,\n    value,\n    oldValue\n  }) {\n    const elem = this.getElementById(id);\n\n    if (oldValue !== null && this.index[name][oldValue]) {\n      delete this.index[name][oldValue][id];\n    }\n\n    if (value !== null) {\n      setIndexValue(this.index, name, value, elem.getAttribute('id'), elem);\n    }\n  } // Register element `elem` with this registry. This adds the element to its index and watches\n  // it for attribute changes.\n\n\n  register(elem, id) {\n    id = id || elem.getAttribute('id');\n\n    if (!id) {\n      throw new X('Can\\'t add element without `id` attribute to registry', elem);\n    } // Manually add id to index, then update other indexes.\n\n\n    elem.setAttribute('id', id);\n    setIndexValue(this.index, 'id', id, id, elem);\n    Registry.INDEXES.forEach(name => {\n      this.updateIndex({\n        id,\n        name,\n        value: elem.getAttribute(name),\n        oldValue: null\n      });\n    });\n    elem.onRegister(this);\n    return this;\n  }\n\n  getElementById(id) {\n    return this.index.id[id] ? this.index.id[id][id] : null;\n  }\n\n  getElementsByAttribute(attrName, value) {\n    const index = this.index[attrName];\n\n    if (index && index[value]) {\n      return Object.keys(index[value]).map(i => index[value][i]);\n    } else {\n      return [];\n    }\n  }\n\n  getElementsByType(type) {\n    return this.getElementsByAttribute('type', type);\n  }\n\n  getElementsByClass(className) {\n    return this.getElementsByAttribute('class', className);\n  } // This is called by the element when an attribute value changes. If an indexed\n  // attribute changes, then update the local index.\n\n\n  onUpdate({\n    id,\n    name,\n    value,\n    oldValue\n  }) {\n    function includes(array, value) {\n      return array.filter(x => x === value).length > 0;\n    }\n\n    if (!includes(Registry.INDEXES.concat(['id', 'class']), name)) return this;\n    this.updateIndex({\n      id,\n      name,\n      value,\n      oldValue\n    });\n    return this;\n  }\n\n}\nRegistry.defaultRegistry = null;","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/registry.js"],"names":["Vex","X","MakeException","setIndexValue","index","name","value","id","elem","Registry","INDEXES","constructor","clear","enableDefaultRegistry","registry","defaultRegistry","getDefaultRegistry","disableDefaultRegistry","type","class","updateIndex","oldValue","getElementById","getAttribute","register","setAttribute","forEach","onRegister","getElementsByAttribute","attrName","Object","keys","map","i","getElementsByType","getElementsByClass","className","onUpdate","includes","array","filter","x","length","concat"],"mappings":"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","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n// @author Mohit Cheppudira\n//\n// ## Description\n//\n// This file implements a registry for VexFlow elements. It allows users\n// to track, query, and manage some subset of generated elements, and\n// dynamically get and set attributes.\n//\n// There are two ways to regiser with a registry:\n//\n// 1) Explicitly call `element.register(registry)`, or,\n// 2) Call `Registry.enableDefaultRegistry(registry)` when ready, and all future\n//    elements will automatically register with it.\n//\n// Once an element is registered, selected attributes are tracked and indexed by\n// the registry. This allows fast look up of elements by attributes like id, type,\n// and class.\n\nimport { Vex } from './vex';\n\nexport const X = Vex.MakeException('RegistryError');\n\nfunction setIndexValue(index, name, value, id, elem) {\n  if (!index[name][value]) index[name][value] = {};\n  index[name][value][id] = elem;\n}\n\nexport class Registry {\n  static get INDEXES() { return ['type']; }\n\n  constructor() {\n    this.clear();\n  }\n\n  // If you call `enableDefaultRegistry`, any new elements will auto-register with\n  // the provided registry as soon as they're constructed.\n  static enableDefaultRegistry(registry) {\n    Registry.defaultRegistry = registry;\n  }\n\n  static getDefaultRegistry() {\n    return Registry.defaultRegistry;\n  }\n\n  static disableDefaultRegistry() {\n    Registry.defaultRegistry = null;\n  }\n\n  clear() {\n    // Indexes are represented as maps of maps (of maps). This allows\n    // for both multi-labeling (e.g., an element can have multiple classes)\n    // and efficient lookup.\n    this.index = {\n      id: {},\n      type: {},\n      class: {},\n    };\n    return this;\n  }\n\n  // Updates the indexes for element 'id'. If an element's attribute changes\n  // from A -> B, make sure to remove the element from A.\n  updateIndex({ id, name, value, oldValue }) {\n    const elem = this.getElementById(id);\n    if (oldValue !== null && this.index[name][oldValue]) {\n      delete this.index[name][oldValue][id];\n    }\n    if (value !== null) {\n      setIndexValue(this.index, name, value, elem.getAttribute('id'), elem);\n    }\n  }\n\n  // Register element `elem` with this registry. This adds the element to its index and watches\n  // it for attribute changes.\n  register(elem, id) {\n    id = id || elem.getAttribute('id');\n\n    if (!id) {\n      throw new X('Can\\'t add element without `id` attribute to registry', elem);\n    }\n\n    // Manually add id to index, then update other indexes.\n    elem.setAttribute('id', id);\n    setIndexValue(this.index, 'id', id, id, elem);\n    Registry.INDEXES.forEach(name => {\n      this.updateIndex({ id, name, value: elem.getAttribute(name), oldValue: null });\n    });\n    elem.onRegister(this);\n    return this;\n  }\n\n  getElementById(id) {\n    return this.index.id[id] ? this.index.id[id][id] : null;\n  }\n\n  getElementsByAttribute(attrName, value) {\n    const index = this.index[attrName];\n    if (index && index[value]) {\n      return Object.keys(index[value]).map(i => index[value][i]);\n    } else {\n      return [];\n    }\n  }\n\n  getElementsByType(type) { return this.getElementsByAttribute('type', type); }\n  getElementsByClass(className) { return this.getElementsByAttribute('class', className); }\n\n  // This is called by the element when an attribute value changes. If an indexed\n  // attribute changes, then update the local index.\n  onUpdate({ id, name, value, oldValue }) {\n    function includes(array, value) {\n      return array.filter(x => x === value).length > 0;\n    }\n\n    if (!includes(Registry.INDEXES.concat(['id', 'class']), name)) return this;\n    this.updateIndex({ id, name, value, oldValue });\n    return this;\n  }\n}\n\nRegistry.defaultRegistry = null;\n"]},"metadata":{},"sourceType":"module"}