{"ast":null,"code":"// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n// Author Larry Kuhns 2011\nimport { StaveModifier } from './stavemodifier';\nexport class StaveSection extends StaveModifier {\n  static get CATEGORY() {\n    return 'stavesection';\n  }\n\n  constructor(section, x, shift_y) {\n    super();\n    this.setAttribute('type', 'StaveSection');\n    this.setWidth(16);\n    this.section = section;\n    this.x = x;\n    this.shift_x = 0;\n    this.shift_y = shift_y;\n    this.font = {\n      family: 'sans-serif',\n      size: 12,\n      weight: 'bold'\n    };\n  }\n\n  getCategory() {\n    return StaveSection.CATEGORY;\n  }\n\n  setStaveSection(section) {\n    this.section = section;\n    return this;\n  }\n\n  setShiftX(x) {\n    this.shift_x = x;\n    return this;\n  }\n\n  setShiftY(y) {\n    this.shift_y = y;\n    return this;\n  }\n\n  draw(stave, shift_x) {\n    const ctx = stave.checkContext();\n    this.setRendered();\n    ctx.save();\n    ctx.lineWidth = 2;\n    ctx.setFont(this.font.family, this.font.size, this.font.weight);\n    const text_width = ctx.measureText('' + this.section).width;\n    let width = text_width + 6; // add left & right padding\n\n    if (width < 18) width = 18;\n    const height = 20; //  Seems to be a good default y\n\n    const y = stave.getYForTopText(3) + this.shift_y;\n    let x = this.x + shift_x;\n    ctx.beginPath();\n    ctx.lineWidth = 2;\n    ctx.rect(x, y, width, height);\n    ctx.stroke();\n    x += (width - text_width) / 2;\n    ctx.fillText('' + this.section, x, y + 16);\n    ctx.restore();\n    return this;\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/stavesection.js"],"names":["StaveModifier","StaveSection","CATEGORY","constructor","section","x","shift_y","setAttribute","setWidth","shift_x","font","family","size","weight","getCategory","setStaveSection","setShiftX","setShiftY","y","draw","stave","ctx","checkContext","setRendered","save","lineWidth","setFont","text_width","measureText","width","height","getYForTopText","beginPath","rect","stroke","fillText","restore"],"mappings":"AAAA;AACA;AAEA,SAASA,aAAT,QAA8B,iBAA9B;AAEA,OAAO,MAAMC,YAAN,SAA2BD,aAA3B,CAAyC;AAC9C,aAAWE,QAAX,GAAsB;AAAE,WAAO,cAAP;AAAwB;;AAEhDC,EAAAA,WAAW,CAACC,OAAD,EAAUC,CAAV,EAAaC,OAAb,EAAsB;AAC/B;AACA,SAAKC,YAAL,CAAkB,MAAlB,EAA0B,cAA1B;AAEA,SAAKC,QAAL,CAAc,EAAd;AACA,SAAKJ,OAAL,GAAeA,OAAf;AACA,SAAKC,CAAL,GAASA,CAAT;AACA,SAAKI,OAAL,GAAe,CAAf;AACA,SAAKH,OAAL,GAAeA,OAAf;AACA,SAAKI,IAAL,GAAY;AACVC,MAAAA,MAAM,EAAE,YADE;AAEVC,MAAAA,IAAI,EAAE,EAFI;AAGVC,MAAAA,MAAM,EAAE;AAHE,KAAZ;AAKD;;AAEDC,EAAAA,WAAW,GAAG;AAAE,WAAOb,YAAY,CAACC,QAApB;AAA+B;;AAC/Ca,EAAAA,eAAe,CAACX,OAAD,EAAU;AAAE,SAAKA,OAAL,GAAeA,OAAf;AAAwB,WAAO,IAAP;AAAc;;AACjEY,EAAAA,SAAS,CAACX,CAAD,EAAI;AAAE,SAAKI,OAAL,GAAeJ,CAAf;AAAkB,WAAO,IAAP;AAAc;;AAC/CY,EAAAA,SAAS,CAACC,CAAD,EAAI;AAAE,SAAKZ,OAAL,GAAeY,CAAf;AAAkB,WAAO,IAAP;AAAc;;AAC/CC,EAAAA,IAAI,CAACC,KAAD,EAAQX,OAAR,EAAiB;AACnB,UAAMY,GAAG,GAAGD,KAAK,CAACE,YAAN,EAAZ;AACA,SAAKC,WAAL;AAEAF,IAAAA,GAAG,CAACG,IAAJ;AACAH,IAAAA,GAAG,CAACI,SAAJ,GAAgB,CAAhB;AACAJ,IAAAA,GAAG,CAACK,OAAJ,CAAY,KAAKhB,IAAL,CAAUC,MAAtB,EAA8B,KAAKD,IAAL,CAAUE,IAAxC,EAA8C,KAAKF,IAAL,CAAUG,MAAxD;AACA,UAAMc,UAAU,GAAGN,GAAG,CAACO,WAAJ,CAAgB,KAAK,KAAKxB,OAA1B,EAAmCyB,KAAtD;AACA,QAAIA,KAAK,GAAGF,UAAU,GAAG,CAAzB,CARmB,CAQU;;AAC7B,QAAIE,KAAK,GAAG,EAAZ,EAAgBA,KAAK,GAAG,EAAR;AAChB,UAAMC,MAAM,GAAG,EAAf,CAVmB,CAWnB;;AACA,UAAMZ,CAAC,GAAGE,KAAK,CAACW,cAAN,CAAqB,CAArB,IAA0B,KAAKzB,OAAzC;AACA,QAAID,CAAC,GAAG,KAAKA,CAAL,GAASI,OAAjB;AACAY,IAAAA,GAAG,CAACW,SAAJ;AACAX,IAAAA,GAAG,CAACI,SAAJ,GAAgB,CAAhB;AACAJ,IAAAA,GAAG,CAACY,IAAJ,CAAS5B,CAAT,EAAYa,CAAZ,EAAeW,KAAf,EAAsBC,MAAtB;AACAT,IAAAA,GAAG,CAACa,MAAJ;AACA7B,IAAAA,CAAC,IAAI,CAACwB,KAAK,GAAGF,UAAT,IAAuB,CAA5B;AACAN,IAAAA,GAAG,CAACc,QAAJ,CAAa,KAAK,KAAK/B,OAAvB,EAAgCC,CAAhC,EAAmCa,CAAC,GAAG,EAAvC;AACAG,IAAAA,GAAG,CAACe,OAAJ;AACA,WAAO,IAAP;AACD;;AA7C6C","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n// Author Larry Kuhns 2011\n\nimport { StaveModifier } from './stavemodifier';\n\nexport class StaveSection extends StaveModifier {\n  static get CATEGORY() { return 'stavesection'; }\n\n  constructor(section, x, shift_y) {\n    super();\n    this.setAttribute('type', 'StaveSection');\n\n    this.setWidth(16);\n    this.section = section;\n    this.x = x;\n    this.shift_x = 0;\n    this.shift_y = shift_y;\n    this.font = {\n      family: 'sans-serif',\n      size: 12,\n      weight: 'bold',\n    };\n  }\n\n  getCategory() { return StaveSection.CATEGORY; }\n  setStaveSection(section) { this.section = section; return this; }\n  setShiftX(x) { this.shift_x = x; return this; }\n  setShiftY(y) { this.shift_y = y; return this; }\n  draw(stave, shift_x) {\n    const ctx = stave.checkContext();\n    this.setRendered();\n\n    ctx.save();\n    ctx.lineWidth = 2;\n    ctx.setFont(this.font.family, this.font.size, this.font.weight);\n    const text_width = ctx.measureText('' + this.section).width;\n    let width = text_width + 6;  // add left & right padding\n    if (width < 18) width = 18;\n    const height = 20;\n    //  Seems to be a good default y\n    const y = stave.getYForTopText(3) + this.shift_y;\n    let x = this.x + shift_x;\n    ctx.beginPath();\n    ctx.lineWidth = 2;\n    ctx.rect(x, y, width, height);\n    ctx.stroke();\n    x += (width - text_width) / 2;\n    ctx.fillText('' + this.section, x, y + 16);\n    ctx.restore();\n    return this;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}