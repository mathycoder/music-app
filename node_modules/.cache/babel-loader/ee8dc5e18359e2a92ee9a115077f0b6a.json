{"ast":null,"code":"// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n// The tickable interface. Tickables are things that sit on a score and\n// have a duration, i.e., they occupy space in the musical rendering dimension.\nimport { Vex } from './vex';\nimport { Element } from './element';\nimport { Flow } from './tables';\nimport { Fraction } from './fraction';\nexport class Tickable extends Element {\n  constructor() {\n    super();\n    this.setAttribute('type', 'Tickable'); // These properties represent the duration of\n    // this tickable element.\n\n    this.ticks = new Fraction(0, 1); // Fractional value of ticks\n\n    this.intrinsicTicks = 0; // Floating point value of ticks\n\n    this.tickMultiplier = new Fraction(1, 1); // Formatter metrics\n\n    this.width = 0;\n    this.x_shift = 0; // Shift from tick context\n\n    this.voice = null;\n    this.tickContext = null;\n    this.modifierContext = null;\n    this.modifiers = [];\n    this.preFormatted = false;\n    this.postFormatted = false;\n    this.tuplet = null;\n    this.tupletStack = [];\n    this.align_center = false;\n    this.center_x_shift = 0; // Shift from tick context if center aligned\n    // This flag tells the formatter to ignore this tickable during\n    // formatting and justification. It is set by tickables such as BarNote.\n\n    this.ignore_ticks = false; // This is a space for an external formatting class or function to maintain\n    // metrics.\n\n    this.formatterMetrics = {\n      // The freedom of a tickable is the distance it can move without colliding\n      // with neighboring elements. A formatter can set these values during its\n      // formatting pass, which a different formatter can then use to fine tune.\n      freedom: {\n        left: 0,\n        right: 0\n      },\n      // The simplified rational duration of this tick as a string. It can be\n      // used as an index to a map or hashtable.\n      duration: '',\n      // The number of formatting iterations undergone.\n      iterations: 0,\n      // The space in pixels allocated by this formatter, along with the mean space\n      // for tickables of this duration, and the deviation from the mean.\n      space: {\n        used: 0,\n        mean: 0,\n        deviation: 0\n      }\n    };\n  }\n\n  reset() {\n    return this;\n  }\n\n  getTicks() {\n    return this.ticks;\n  }\n\n  shouldIgnoreTicks() {\n    return this.ignore_ticks;\n  } // Get and set width of note. Used by the formatter for positioning.\n\n\n  setWidth(width) {\n    this.width = width;\n  }\n\n  getWidth() {\n    if (!this.preFormatted) {\n      throw new Vex.RERR('UnformattedNote', \"Can't call GetWidth on an unformatted note.\");\n    }\n\n    return this.width + (this.modifierContext ? this.modifierContext.getWidth() : 0);\n  } // Displace note by `x` pixels. Used by the formatter.\n\n\n  setXShift(x) {\n    this.x_shift = x;\n    return this;\n  }\n\n  getXShift() {\n    return this.x_shift;\n  } // Get `X` position of this tick context.\n\n\n  getX() {\n    if (!this.tickContext) {\n      throw new Vex.RERR('NoTickContext', 'Note needs a TickContext assigned for an X-Value');\n    }\n\n    return this.tickContext.getX() + this.x_shift;\n  }\n\n  getFormatterMetrics() {\n    return this.formatterMetrics;\n  }\n\n  getCenterXShift() {\n    if (this.isCenterAligned()) {\n      return this.center_x_shift;\n    }\n\n    return 0;\n  }\n\n  isCenterAligned() {\n    return this.align_center;\n  }\n\n  setCenterAlignment(align_center) {\n    this.align_center = align_center;\n    return this;\n  } // Every tickable must be associated with a voice. This allows formatters\n  // and preFormatter to associate them with the right modifierContexts.\n\n\n  getVoice() {\n    if (!this.voice) throw new Vex.RERR('NoVoice', 'Tickable has no voice.');\n    return this.voice;\n  }\n\n  setVoice(voice) {\n    this.voice = voice;\n  }\n\n  getTuplet() {\n    return this.tuplet;\n  }\n  /*\n   * resetTuplet\n   * @param tuplet -- the specific tuplet to reset\n   *   if this is not provided, all tuplets are reset.\n   * @returns this\n   *\n   * Removes any prior tuplets from the tick calculation and\n   * resets the intrinsic tick value to\n   */\n\n\n  resetTuplet(tuplet) {\n    let noteCount;\n    let notesOccupied;\n\n    if (tuplet) {\n      const i = this.tupletStack.indexOf(tuplet);\n\n      if (i !== -1) {\n        this.tupletStack.splice(i, 1);\n        noteCount = tuplet.getNoteCount();\n        notesOccupied = tuplet.getNotesOccupied(); // Revert old multiplier by inverting numerator & denom.:\n\n        this.applyTickMultiplier(noteCount, notesOccupied);\n      }\n\n      return this;\n    }\n\n    while (this.tupletStack.length) {\n      tuplet = this.tupletStack.pop();\n      noteCount = tuplet.getNoteCount();\n      notesOccupied = tuplet.getNotesOccupied(); // Revert old multiplier by inverting numerator & denom.:\n\n      this.applyTickMultiplier(noteCount, notesOccupied);\n    }\n\n    return this;\n  }\n\n  setTuplet(tuplet) {\n    // Attach to new tuplet\n    if (tuplet) {\n      this.tupletStack.push(tuplet);\n      const noteCount = tuplet.getNoteCount();\n      const notesOccupied = tuplet.getNotesOccupied();\n      this.applyTickMultiplier(notesOccupied, noteCount);\n    }\n\n    this.tuplet = tuplet;\n    return this;\n  }\n  /** optional, if tickable has modifiers **/\n\n\n  addToModifierContext(mc) {\n    this.modifierContext = mc; // Add modifiers to modifier context (if any)\n\n    this.preFormatted = false;\n  }\n  /** optional, if tickable has modifiers **/\n\n\n  addModifier(mod) {\n    this.modifiers.push(mod);\n    this.preFormatted = false;\n    return this;\n  }\n\n  getModifiers() {\n    return this.modifiers;\n  }\n\n  setTickContext(tc) {\n    this.tickContext = tc;\n    this.preFormatted = false;\n  }\n\n  preFormat() {\n    if (this.preFormatted) return;\n    this.width = 0;\n\n    if (this.modifierContext) {\n      this.modifierContext.preFormat();\n      this.width += this.modifierContext.getWidth();\n    }\n  }\n\n  postFormat() {\n    if (this.postFormatted) return this;\n    this.postFormatted = true;\n    return this;\n  }\n\n  getIntrinsicTicks() {\n    return this.intrinsicTicks;\n  }\n\n  setIntrinsicTicks(intrinsicTicks) {\n    this.intrinsicTicks = intrinsicTicks;\n    this.ticks = this.tickMultiplier.clone().multiply(this.intrinsicTicks);\n  }\n\n  getTickMultiplier() {\n    return this.tickMultiplier;\n  }\n\n  applyTickMultiplier(numerator, denominator) {\n    this.tickMultiplier.multiply(numerator, denominator);\n    this.ticks = this.tickMultiplier.clone().multiply(this.intrinsicTicks);\n  }\n\n  setDuration(duration) {\n    const ticks = duration.numerator * (Flow.RESOLUTION / duration.denominator);\n    this.ticks = this.tickMultiplier.clone().multiply(ticks);\n    this.intrinsicTicks = this.ticks.value();\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/tickable.js"],"names":["Vex","Element","Flow","Fraction","Tickable","constructor","setAttribute","ticks","intrinsicTicks","tickMultiplier","width","x_shift","voice","tickContext","modifierContext","modifiers","preFormatted","postFormatted","tuplet","tupletStack","align_center","center_x_shift","ignore_ticks","formatterMetrics","freedom","left","right","duration","iterations","space","used","mean","deviation","reset","getTicks","shouldIgnoreTicks","setWidth","getWidth","RERR","setXShift","x","getXShift","getX","getFormatterMetrics","getCenterXShift","isCenterAligned","setCenterAlignment","getVoice","setVoice","getTuplet","resetTuplet","noteCount","notesOccupied","i","indexOf","splice","getNoteCount","getNotesOccupied","applyTickMultiplier","length","pop","setTuplet","push","addToModifierContext","mc","addModifier","mod","getModifiers","setTickContext","tc","preFormat","postFormat","getIntrinsicTicks","setIntrinsicTicks","clone","multiply","getTickMultiplier","numerator","denominator","setDuration","RESOLUTION","value"],"mappings":"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","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n// The tickable interface. Tickables are things that sit on a score and\n// have a duration, i.e., they occupy space in the musical rendering dimension.\n\nimport { Vex } from './vex';\nimport { Element } from './element';\nimport { Flow } from './tables';\nimport { Fraction } from './fraction';\n\nexport class Tickable extends Element {\n  constructor() {\n    super();\n    this.setAttribute('type', 'Tickable');\n\n    // These properties represent the duration of\n    // this tickable element.\n    this.ticks = new Fraction(0, 1); // Fractional value of ticks\n    this.intrinsicTicks = 0; // Floating point value of ticks\n    this.tickMultiplier = new Fraction(1, 1);\n\n    // Formatter metrics\n    this.width = 0;\n    this.x_shift = 0; // Shift from tick context\n\n    this.voice = null;\n    this.tickContext = null;\n    this.modifierContext = null;\n    this.modifiers = [];\n    this.preFormatted = false;\n    this.postFormatted = false;\n    this.tuplet = null;\n    this.tupletStack = [];\n\n    this.align_center = false;\n    this.center_x_shift = 0; // Shift from tick context if center aligned\n\n    // This flag tells the formatter to ignore this tickable during\n    // formatting and justification. It is set by tickables such as BarNote.\n    this.ignore_ticks = false;\n\n    // This is a space for an external formatting class or function to maintain\n    // metrics.\n    this.formatterMetrics = {\n      // The freedom of a tickable is the distance it can move without colliding\n      // with neighboring elements. A formatter can set these values during its\n      // formatting pass, which a different formatter can then use to fine tune.\n      freedom: { left: 0, right: 0 },\n\n      // The simplified rational duration of this tick as a string. It can be\n      // used as an index to a map or hashtable.\n      duration: '',\n\n      // The number of formatting iterations undergone.\n      iterations: 0,\n\n      // The space in pixels allocated by this formatter, along with the mean space\n      // for tickables of this duration, and the deviation from the mean.\n      space: {\n        used: 0,\n        mean: 0,\n        deviation: 0,\n      },\n    };\n  }\n\n  reset() { return this; }\n\n  getTicks() { return this.ticks; }\n  shouldIgnoreTicks() { return this.ignore_ticks; }\n\n  // Get and set width of note. Used by the formatter for positioning.\n  setWidth(width) { this.width = width; }\n  getWidth() {\n    if (!this.preFormatted) {\n      throw new Vex.RERR('UnformattedNote', \"Can't call GetWidth on an unformatted note.\");\n    }\n\n    return this.width + (this.modifierContext ? this.modifierContext.getWidth() : 0);\n  }\n\n  // Displace note by `x` pixels. Used by the formatter.\n  setXShift(x) { this.x_shift = x; return this; }\n  getXShift() { return this.x_shift; }\n\n  // Get `X` position of this tick context.\n  getX() {\n    if (!this.tickContext) {\n      throw new Vex.RERR('NoTickContext', 'Note needs a TickContext assigned for an X-Value');\n    }\n\n    return this.tickContext.getX() + this.x_shift;\n  }\n\n\n  getFormatterMetrics() { return this.formatterMetrics; }\n\n  getCenterXShift() {\n    if (this.isCenterAligned()) {\n      return this.center_x_shift;\n    }\n\n    return 0;\n  }\n  isCenterAligned() { return this.align_center; }\n  setCenterAlignment(align_center) {\n    this.align_center = align_center;\n    return this;\n  }\n\n  // Every tickable must be associated with a voice. This allows formatters\n  // and preFormatter to associate them with the right modifierContexts.\n  getVoice() {\n    if (!this.voice) throw new Vex.RERR('NoVoice', 'Tickable has no voice.');\n    return this.voice;\n  }\n  setVoice(voice) { this.voice = voice; }\n  getTuplet() { return this.tuplet; }\n\n  /*\n   * resetTuplet\n   * @param tuplet -- the specific tuplet to reset\n   *   if this is not provided, all tuplets are reset.\n   * @returns this\n   *\n   * Removes any prior tuplets from the tick calculation and\n   * resets the intrinsic tick value to\n   */\n  resetTuplet(tuplet) {\n    let noteCount;\n    let notesOccupied;\n    if (tuplet) {\n      const i = this.tupletStack.indexOf(tuplet);\n      if (i !== -1) {\n        this.tupletStack.splice(i, 1);\n        noteCount = tuplet.getNoteCount();\n        notesOccupied = tuplet.getNotesOccupied();\n\n        // Revert old multiplier by inverting numerator & denom.:\n        this.applyTickMultiplier(noteCount, notesOccupied);\n      }\n      return this;\n    }\n\n    while (this.tupletStack.length) {\n      tuplet = this.tupletStack.pop();\n      noteCount = tuplet.getNoteCount();\n      notesOccupied = tuplet.getNotesOccupied();\n\n      // Revert old multiplier by inverting numerator & denom.:\n      this.applyTickMultiplier(noteCount, notesOccupied);\n    }\n    return this;\n  }\n\n  setTuplet(tuplet) {\n    // Attach to new tuplet\n\n    if (tuplet) {\n      this.tupletStack.push(tuplet);\n\n      const noteCount = tuplet.getNoteCount();\n      const notesOccupied = tuplet.getNotesOccupied();\n\n      this.applyTickMultiplier(notesOccupied, noteCount);\n    }\n\n    this.tuplet = tuplet;\n\n    return this;\n  }\n\n  /** optional, if tickable has modifiers **/\n  addToModifierContext(mc) {\n    this.modifierContext = mc;\n    // Add modifiers to modifier context (if any)\n    this.preFormatted = false;\n  }\n\n  /** optional, if tickable has modifiers **/\n  addModifier(mod) {\n    this.modifiers.push(mod);\n    this.preFormatted = false;\n    return this;\n  }\n  getModifiers() {\n    return this.modifiers;\n  }\n  setTickContext(tc) {\n    this.tickContext = tc;\n    this.preFormatted = false;\n  }\n  preFormat() {\n    if (this.preFormatted) return;\n\n    this.width = 0;\n    if (this.modifierContext) {\n      this.modifierContext.preFormat();\n      this.width += this.modifierContext.getWidth();\n    }\n  }\n  postFormat() {\n    if (this.postFormatted) return this;\n    this.postFormatted = true;\n    return this;\n  }\n  getIntrinsicTicks() {\n    return this.intrinsicTicks;\n  }\n  setIntrinsicTicks(intrinsicTicks) {\n    this.intrinsicTicks = intrinsicTicks;\n    this.ticks = this.tickMultiplier.clone().multiply(this.intrinsicTicks);\n  }\n  getTickMultiplier() {\n    return this.tickMultiplier;\n  }\n  applyTickMultiplier(numerator, denominator) {\n    this.tickMultiplier.multiply(numerator, denominator);\n    this.ticks = this.tickMultiplier.clone().multiply(this.intrinsicTicks);\n  }\n  setDuration(duration) {\n    const ticks = duration.numerator * (Flow.RESOLUTION / duration.denominator);\n    this.ticks = this.tickMultiplier.clone().multiply(ticks);\n    this.intrinsicTicks = this.ticks.value();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}