{"ast":null,"code":"// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n// This file implements the `TextDynamics` which renders traditional\n// text dynamics markings, **ie: p, f, sfz, rfz, ppp**\n//\n// You can render any dynamics string that contains a combination of\n// the following letters:  P, M, F, Z, R, S\nimport { Vex } from './vex';\nimport { Note } from './note';\nimport { Glyph } from './glyph'; // To enable logging for this class. Set `Vex.Flow.TextDynamics.DEBUG` to `true`.\n\nfunction L(...args) {\n  if (TextDynamics.DEBUG) Vex.L('Vex.Flow.TextDynamics', args);\n}\n\nexport class TextDynamics extends Note {\n  // The glyph data for each dynamics letter\n  static get GLYPHS() {\n    return {\n      'f': {\n        code: 'dynamicForte',\n        width: 12\n      },\n      'p': {\n        code: 'dynamicPiano',\n        width: 14\n      },\n      'm': {\n        code: 'dynamicMezzo',\n        width: 17\n      },\n      's': {\n        code: 'dynamicSforzando',\n        width: 10\n      },\n      'z': {\n        code: 'dynamicZ',\n        width: 12\n      },\n      'r': {\n        code: 'dynamicRinforzando',\n        width: 12\n      }\n    };\n  } // A `TextDynamics` object inherits from `Note` so that it can be formatted\n  // within a `Voice`.\n  // Create the dynamics marking. `text_struct` is an object\n  // that contains a `duration` property and a `sequence` of\n  // letters that represents the letters to render\n\n\n  constructor(text_struct) {\n    super(text_struct);\n    this.setAttribute('type', 'TextDynamics');\n    this.sequence = text_struct.text.toLowerCase();\n    this.line = text_struct.line || 0;\n    this.glyphs = [];\n    Vex.Merge(this.render_options, {\n      glyph_font_size: 40\n    });\n    L('New Dynamics Text: ', this.sequence);\n  } // Set the Stave line on which the note should be placed\n\n\n  setLine(line) {\n    this.line = line;\n    return this;\n  } // Preformat the dynamics text\n\n\n  preFormat() {\n    let total_width = 0; // Iterate through each letter\n\n    this.sequence.split('').forEach(letter => {\n      // Get the glyph data for the letter\n      const glyph_data = TextDynamics.GLYPHS[letter];\n      if (!glyph_data) throw new Vex.RERR('Invalid dynamics character: ' + letter);\n      const size = this.render_options.glyph_font_size;\n      const glyph = new Glyph(glyph_data.code, size, {\n        category: 'textNote'\n      }); // Add the glyph\n\n      this.glyphs.push(glyph);\n      total_width += glyph_data.width;\n    }); // Store the width of the text\n\n    this.setWidth(total_width);\n    this.preFormatted = true;\n    return this;\n  } // Draw the dynamics text on the rendering context\n\n\n  draw() {\n    this.setRendered();\n    const x = this.getAbsoluteX();\n    const y = this.stave.getYForLine(this.line + -3);\n    L('Rendering Dynamics: ', this.sequence);\n    let letter_x = x;\n    this.glyphs.forEach((glyph, index) => {\n      const current_letter = this.sequence[index];\n      glyph.render(this.context, letter_x, y);\n      letter_x += TextDynamics.GLYPHS[current_letter].width;\n    });\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/textdynamics.js"],"names":["Vex","Note","Glyph","L","args","TextDynamics","DEBUG","GLYPHS","code","width","constructor","text_struct","setAttribute","sequence","text","toLowerCase","line","glyphs","Merge","render_options","glyph_font_size","setLine","preFormat","total_width","split","forEach","letter","glyph_data","RERR","size","glyph","category","push","setWidth","preFormatted","draw","setRendered","x","getAbsoluteX","y","stave","getYForLine","letter_x","index","current_letter","render","context"],"mappings":"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","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n// This file implements the `TextDynamics` which renders traditional\n// text dynamics markings, **ie: p, f, sfz, rfz, ppp**\n//\n// You can render any dynamics string that contains a combination of\n// the following letters:  P, M, F, Z, R, S\n\nimport { Vex } from './vex';\nimport { Note } from './note';\nimport { Glyph } from './glyph';\n\n// To enable logging for this class. Set `Vex.Flow.TextDynamics.DEBUG` to `true`.\nfunction L(...args) { if (TextDynamics.DEBUG) Vex.L('Vex.Flow.TextDynamics', args); }\n\nexport class TextDynamics extends Note {\n  // The glyph data for each dynamics letter\n  static get GLYPHS() {\n    return {\n      'f': {\n        code: 'dynamicForte',\n        width: 12,\n      },\n      'p': {\n        code: 'dynamicPiano',\n        width: 14,\n      },\n      'm': {\n        code: 'dynamicMezzo',\n        width: 17,\n      },\n      's': {\n        code: 'dynamicSforzando',\n        width: 10,\n      },\n      'z': {\n        code: 'dynamicZ',\n        width: 12,\n      },\n      'r': {\n        code: 'dynamicRinforzando',\n        width: 12,\n      },\n    };\n  }\n\n  // A `TextDynamics` object inherits from `Note` so that it can be formatted\n  // within a `Voice`.\n  // Create the dynamics marking. `text_struct` is an object\n  // that contains a `duration` property and a `sequence` of\n  // letters that represents the letters to render\n  constructor(text_struct) {\n    super(text_struct);\n    this.setAttribute('type', 'TextDynamics');\n\n    this.sequence = text_struct.text.toLowerCase();\n    this.line = text_struct.line || 0;\n    this.glyphs = [];\n\n    Vex.Merge(this.render_options, {\n      glyph_font_size: 40,\n    });\n\n    L('New Dynamics Text: ', this.sequence);\n  }\n\n  // Set the Stave line on which the note should be placed\n  setLine(line) {\n    this.line = line;\n    return this;\n  }\n\n  // Preformat the dynamics text\n  preFormat() {\n    let total_width = 0;\n    // Iterate through each letter\n    this.sequence.split('').forEach(letter => {\n      // Get the glyph data for the letter\n      const glyph_data = TextDynamics.GLYPHS[letter];\n      if (!glyph_data) throw new Vex.RERR('Invalid dynamics character: ' + letter);\n\n      const size =  this.render_options.glyph_font_size;\n      const glyph = new Glyph(glyph_data.code, size, { category: 'textNote' });\n\n      // Add the glyph\n      this.glyphs.push(glyph);\n\n      total_width += glyph_data.width;\n    });\n\n    // Store the width of the text\n    this.setWidth(total_width);\n    this.preFormatted = true;\n    return this;\n  }\n\n  // Draw the dynamics text on the rendering context\n  draw() {\n    this.setRendered();\n    const x = this.getAbsoluteX();\n    const y = this.stave.getYForLine(this.line + (-3));\n\n    L('Rendering Dynamics: ', this.sequence);\n\n    let letter_x = x;\n    this.glyphs.forEach((glyph, index) => {\n      const current_letter = this.sequence[index];\n      glyph.render(this.context, letter_x, y);\n      letter_x += TextDynamics.GLYPHS[current_letter].width;\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}