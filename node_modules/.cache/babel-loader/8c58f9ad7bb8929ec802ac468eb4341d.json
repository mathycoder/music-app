{"ast":null,"code":"// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n//\n// This file implements tablature bends.\nimport { Vex } from './vex';\nimport { Flow } from './tables';\nimport { Modifier } from './modifier';\n/**\n   @param text Text for bend (\"Full\", \"Half\", etc.) (DEPRECATED)\n   @param release If true, render a release. (DEPRECATED)\n   @param phrase If set, ignore \"text\" and \"release\", and use the more\n                 sophisticated phrase specified.\n\n   Example of a phrase:\n\n     [{\n       type: UP,\n       text: \"whole\"\n       width: 8;\n     },\n     {\n       type: DOWN,\n       text: \"whole\"\n       width: 8;\n     },\n     {\n       type: UP,\n       text: \"half\"\n       width: 8;\n     },\n     {\n       type: UP,\n       text: \"whole\"\n       width: 8;\n     },\n     {\n       type: DOWN,\n       text: \"1 1/2\"\n       width: 8;\n     }]\n */\n\nexport class Bend extends Modifier {\n  static get CATEGORY() {\n    return 'bends';\n  }\n\n  static get UP() {\n    return 0;\n  }\n\n  static get DOWN() {\n    return 1;\n  } // ## Static Methods\n  // Arrange bends in `ModifierContext`\n\n\n  static format(bends, state) {\n    if (!bends || bends.length === 0) return false;\n    let last_width = 0; // Bends are always on top.\n\n    const text_line = state.top_text_line; // Format Bends\n\n    for (let i = 0; i < bends.length; ++i) {\n      const bend = bends[i];\n      bend.setXShift(last_width);\n      last_width = bend.getWidth();\n      bend.setTextLine(text_line);\n    }\n\n    state.right_shift += last_width;\n    state.top_text_line += 1;\n    return true;\n  } // ## Prototype Methods\n\n\n  constructor(text, release, phrase) {\n    super();\n    this.setAttribute('type', 'Bend');\n    this.text = text;\n    this.x_shift = 0;\n    this.release = release || false;\n    this.font = '10pt Arial';\n    this.render_options = {\n      line_width: 1.5,\n      line_style: '#777777',\n      bend_width: 8,\n      release_width: 8\n    };\n\n    if (phrase) {\n      this.phrase = phrase;\n    } else {\n      // Backward compatibility\n      this.phrase = [{\n        type: Bend.UP,\n        text: this.text\n      }];\n      if (this.release) this.phrase.push({\n        type: Bend.DOWN,\n        text: ''\n      });\n    }\n\n    this.updateWidth();\n  }\n\n  getCategory() {\n    return Bend.CATEGORY;\n  }\n\n  setXShift(value) {\n    this.x_shift = value;\n    this.updateWidth();\n  }\n\n  setFont(font) {\n    this.font = font;\n    return this;\n  }\n\n  getText() {\n    return this.text;\n  }\n\n  updateWidth() {\n    const that = this;\n\n    function measure_text(text) {\n      let text_width;\n\n      if (that.context) {\n        text_width = that.context.measureText(text).width;\n      } else {\n        text_width = Flow.textWidth(text);\n      }\n\n      return text_width;\n    }\n\n    let total_width = 0;\n\n    for (let i = 0; i < this.phrase.length; ++i) {\n      const bend = this.phrase[i];\n\n      if ('width' in bend) {\n        total_width += bend.width;\n      } else {\n        const additional_width = bend.type === Bend.UP ? this.render_options.bend_width : this.render_options.release_width;\n        bend.width = Vex.Max(additional_width, measure_text(bend.text)) + 3;\n        bend.draw_width = bend.width / 2;\n        total_width += bend.width;\n      }\n    }\n\n    this.setWidth(total_width + this.x_shift);\n    return this;\n  }\n\n  draw() {\n    this.checkContext();\n\n    if (!(this.note && this.index != null)) {\n      throw new Vex.RERR('NoNoteForBend', \"Can't draw bend without a note or index.\");\n    }\n\n    this.setRendered();\n    const start = this.note.getModifierStartXY(Modifier.Position.RIGHT, this.index);\n    start.x += 3;\n    start.y += 0.5;\n    const x_shift = this.x_shift;\n    const ctx = this.context;\n    const bend_height = this.note.getStave().getYForTopText(this.text_line) + 3;\n    const annotation_y = this.note.getStave().getYForTopText(this.text_line) - 1;\n    const that = this;\n\n    function renderBend(x, y, width, height) {\n      const cp_x = x + width;\n      const cp_y = y;\n      ctx.save();\n      ctx.beginPath();\n      ctx.setLineWidth(that.render_options.line_width);\n      ctx.setStrokeStyle(that.render_options.line_style);\n      ctx.setFillStyle(that.render_options.line_style);\n      ctx.moveTo(x, y);\n      ctx.quadraticCurveTo(cp_x, cp_y, x + width, height);\n      ctx.stroke();\n      ctx.restore();\n    }\n\n    function renderRelease(x, y, width, height) {\n      ctx.save();\n      ctx.beginPath();\n      ctx.setLineWidth(that.render_options.line_width);\n      ctx.setStrokeStyle(that.render_options.line_style);\n      ctx.setFillStyle(that.render_options.line_style);\n      ctx.moveTo(x, height);\n      ctx.quadraticCurveTo(x + width, height, x + width, y);\n      ctx.stroke();\n      ctx.restore();\n    }\n\n    function renderArrowHead(x, y, direction) {\n      const width = 4;\n      const dir = direction || 1;\n      ctx.beginPath();\n      ctx.moveTo(x, y);\n      ctx.lineTo(x - width, y + width * dir);\n      ctx.lineTo(x + width, y + width * dir);\n      ctx.closePath();\n      ctx.fill();\n    }\n\n    function renderText(x, text) {\n      ctx.save();\n      ctx.setRawFont(that.font);\n      const render_x = x - ctx.measureText(text).width / 2;\n      ctx.fillText(text, render_x, annotation_y);\n      ctx.restore();\n    }\n\n    let last_bend = null;\n    let last_drawn_width = 0;\n\n    for (let i = 0; i < this.phrase.length; ++i) {\n      const bend = this.phrase[i];\n      if (i === 0) bend.draw_width += x_shift;\n      last_drawn_width = bend.draw_width + (last_bend ? last_bend.draw_width : 0) - (i === 1 ? x_shift : 0);\n\n      if (bend.type === Bend.UP) {\n        if (last_bend && last_bend.type === Bend.UP) {\n          renderArrowHead(start.x, bend_height);\n        }\n\n        renderBend(start.x, start.y, last_drawn_width, bend_height);\n      }\n\n      if (bend.type === Bend.DOWN) {\n        if (last_bend && last_bend.type === Bend.UP) {\n          renderRelease(start.x, start.y, last_drawn_width, bend_height);\n        }\n\n        if (last_bend && last_bend.type === Bend.DOWN) {\n          renderArrowHead(start.x, start.y, -1);\n          renderRelease(start.x, start.y, last_drawn_width, bend_height);\n        }\n\n        if (last_bend === null) {\n          last_drawn_width = bend.draw_width;\n          renderRelease(start.x, start.y, last_drawn_width, bend_height);\n        }\n      }\n\n      renderText(start.x + last_drawn_width, bend.text);\n      last_bend = bend;\n      last_bend.x = start.x;\n      start.x += last_drawn_width;\n    } // Final arrowhead and text\n\n\n    if (last_bend.type === Bend.UP) {\n      renderArrowHead(last_bend.x + last_drawn_width, bend_height);\n    } else if (last_bend.type === Bend.DOWN) {\n      renderArrowHead(last_bend.x + last_drawn_width, start.y, -1);\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/bend.js"],"names":["Vex","Flow","Modifier","Bend","CATEGORY","UP","DOWN","format","bends","state","length","last_width","text_line","top_text_line","i","bend","setXShift","getWidth","setTextLine","right_shift","constructor","text","release","phrase","setAttribute","x_shift","font","render_options","line_width","line_style","bend_width","release_width","type","push","updateWidth","getCategory","value","setFont","getText","that","measure_text","text_width","context","measureText","width","textWidth","total_width","additional_width","Max","draw_width","setWidth","draw","checkContext","note","index","RERR","setRendered","start","getModifierStartXY","Position","RIGHT","x","y","ctx","bend_height","getStave","getYForTopText","annotation_y","renderBend","height","cp_x","cp_y","save","beginPath","setLineWidth","setStrokeStyle","setFillStyle","moveTo","quadraticCurveTo","stroke","restore","renderRelease","renderArrowHead","direction","dir","lineTo","closePath","fill","renderText","setRawFont","render_x","fillText","last_bend","last_drawn_width"],"mappings":"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","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n//\n// This file implements tablature bends.\n\nimport { Vex } from './vex';\nimport { Flow } from './tables';\nimport { Modifier } from './modifier';\n/**\n   @param text Text for bend (\"Full\", \"Half\", etc.) (DEPRECATED)\n   @param release If true, render a release. (DEPRECATED)\n   @param phrase If set, ignore \"text\" and \"release\", and use the more\n                 sophisticated phrase specified.\n\n   Example of a phrase:\n\n     [{\n       type: UP,\n       text: \"whole\"\n       width: 8;\n     },\n     {\n       type: DOWN,\n       text: \"whole\"\n       width: 8;\n     },\n     {\n       type: UP,\n       text: \"half\"\n       width: 8;\n     },\n     {\n       type: UP,\n       text: \"whole\"\n       width: 8;\n     },\n     {\n       type: DOWN,\n       text: \"1 1/2\"\n       width: 8;\n     }]\n */\nexport class Bend extends Modifier {\n  static get CATEGORY() { return 'bends'; }\n\n  static get UP() {\n    return 0;\n  }\n  static get DOWN() {\n    return 1;\n  }\n\n  // ## Static Methods\n  // Arrange bends in `ModifierContext`\n  static format(bends, state) {\n    if (!bends || bends.length === 0) return false;\n\n    let last_width = 0;\n    // Bends are always on top.\n    const text_line = state.top_text_line;\n\n    // Format Bends\n    for (let i = 0; i < bends.length; ++i) {\n      const bend = bends[i];\n      bend.setXShift(last_width);\n      last_width = bend.getWidth();\n      bend.setTextLine(text_line);\n    }\n\n    state.right_shift += last_width;\n    state.top_text_line += 1;\n    return true;\n  }\n\n  // ## Prototype Methods\n  constructor(text, release, phrase) {\n    super();\n    this.setAttribute('type', 'Bend');\n\n    this.text = text;\n    this.x_shift = 0;\n    this.release = release || false;\n    this.font = '10pt Arial';\n    this.render_options = {\n      line_width: 1.5,\n      line_style: '#777777',\n      bend_width: 8,\n      release_width: 8,\n    };\n\n    if (phrase) {\n      this.phrase = phrase;\n    } else {\n      // Backward compatibility\n      this.phrase = [{ type: Bend.UP, text: this.text }];\n      if (this.release) this.phrase.push({ type: Bend.DOWN, text: '' });\n    }\n\n    this.updateWidth();\n  }\n\n  getCategory() { return Bend.CATEGORY; }\n\n  setXShift(value) {\n    this.x_shift = value;\n    this.updateWidth();\n  }\n  setFont(font) { this.font = font; return this; }\n  getText() { return this.text; }\n  updateWidth() {\n    const that = this;\n\n    function measure_text(text) {\n      let text_width;\n      if (that.context) {\n        text_width = that.context.measureText(text).width;\n      } else {\n        text_width = Flow.textWidth(text);\n      }\n\n      return text_width;\n    }\n\n    let total_width = 0;\n    for (let i = 0; i < this.phrase.length; ++i) {\n      const bend = this.phrase[i];\n      if ('width' in bend) {\n        total_width += bend.width;\n      } else {\n        const additional_width = (bend.type === Bend.UP) ?\n          this.render_options.bend_width : this.render_options.release_width;\n\n        bend.width = Vex.Max(additional_width, measure_text(bend.text)) + 3;\n        bend.draw_width = bend.width / 2;\n        total_width += bend.width;\n      }\n    }\n\n    this.setWidth(total_width + this.x_shift);\n    return this;\n  }\n  draw() {\n    this.checkContext();\n    if (!(this.note && (this.index != null))) {\n      throw new Vex.RERR('NoNoteForBend', \"Can't draw bend without a note or index.\");\n    }\n\n    this.setRendered();\n\n    const start = this.note.getModifierStartXY(Modifier.Position.RIGHT,\n      this.index);\n    start.x += 3;\n    start.y += 0.5;\n    const x_shift = this.x_shift;\n\n    const ctx = this.context;\n    const bend_height = this.note.getStave().getYForTopText(this.text_line) + 3;\n    const annotation_y = this.note.getStave().getYForTopText(this.text_line) - 1;\n    const that = this;\n\n    function renderBend(x, y, width, height) {\n      const cp_x = x + width;\n      const cp_y = y;\n\n      ctx.save();\n      ctx.beginPath();\n      ctx.setLineWidth(that.render_options.line_width);\n      ctx.setStrokeStyle(that.render_options.line_style);\n      ctx.setFillStyle(that.render_options.line_style);\n      ctx.moveTo(x, y);\n      ctx.quadraticCurveTo(cp_x, cp_y, x + width, height);\n      ctx.stroke();\n      ctx.restore();\n    }\n\n    function renderRelease(x, y, width, height) {\n      ctx.save();\n      ctx.beginPath();\n      ctx.setLineWidth(that.render_options.line_width);\n      ctx.setStrokeStyle(that.render_options.line_style);\n      ctx.setFillStyle(that.render_options.line_style);\n      ctx.moveTo(x, height);\n      ctx.quadraticCurveTo(\n        x + width, height,\n        x + width, y);\n      ctx.stroke();\n      ctx.restore();\n    }\n\n    function renderArrowHead(x, y, direction) {\n      const width = 4;\n      const dir = direction || 1;\n\n      ctx.beginPath();\n      ctx.moveTo(x, y);\n      ctx.lineTo(x - width, y + width * dir);\n      ctx.lineTo(x + width, y + width * dir);\n      ctx.closePath();\n      ctx.fill();\n    }\n\n    function renderText(x, text) {\n      ctx.save();\n      ctx.setRawFont(that.font);\n      const render_x = x - (ctx.measureText(text).width / 2);\n      ctx.fillText(text, render_x, annotation_y);\n      ctx.restore();\n    }\n\n    let last_bend = null;\n    let last_drawn_width = 0;\n    for (let i = 0; i < this.phrase.length; ++i) {\n      const bend = this.phrase[i];\n      if (i === 0) bend.draw_width += x_shift;\n\n      last_drawn_width = bend.draw_width +\n        (last_bend ? last_bend.draw_width : 0) -\n        (i === 1 ? x_shift : 0);\n      if (bend.type === Bend.UP) {\n        if (last_bend && last_bend.type === Bend.UP) {\n          renderArrowHead(start.x, bend_height);\n        }\n\n        renderBend(start.x, start.y, last_drawn_width, bend_height);\n      }\n\n      if (bend.type === Bend.DOWN) {\n        if (last_bend && last_bend.type === Bend.UP) {\n          renderRelease(start.x, start.y, last_drawn_width, bend_height);\n        }\n\n        if (last_bend && last_bend.type === Bend.DOWN) {\n          renderArrowHead(start.x, start.y, -1);\n          renderRelease(start.x, start.y, last_drawn_width, bend_height);\n        }\n\n        if (last_bend === null) {\n          last_drawn_width = bend.draw_width;\n          renderRelease(start.x, start.y, last_drawn_width, bend_height);\n        }\n      }\n\n      renderText(start.x + last_drawn_width, bend.text);\n      last_bend = bend;\n      last_bend.x = start.x;\n\n      start.x += last_drawn_width;\n    }\n\n    // Final arrowhead and text\n    if (last_bend.type === Bend.UP) {\n      renderArrowHead(last_bend.x + last_drawn_width, bend_height);\n    } else if (last_bend.type === Bend.DOWN) {\n      renderArrowHead(last_bend.x + last_drawn_width, start.y, -1);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}