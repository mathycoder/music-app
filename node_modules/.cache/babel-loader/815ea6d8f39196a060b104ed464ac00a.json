{"ast":null,"code":"// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n// This class implements varies types of ties between contiguous notes. The\n// ties include: regular ties, hammer ons, pull offs, and slides.\nimport { Vex } from './vex';\nimport { TabTie } from './tabtie';\nexport class TabSlide extends TabTie {\n  static get SLIDE_UP() {\n    return 1;\n  }\n\n  static get SLIDE_DOWN() {\n    return -1;\n  }\n\n  static createSlideUp(notes) {\n    return new TabSlide(notes, TabSlide.SLIDE_UP);\n  }\n\n  static createSlideDown(notes) {\n    return new TabSlide(notes, TabSlide.SLIDE_DOWN);\n  }\n\n  constructor(notes, direction) {\n    /**\n     * Notes is a struct that has:\n     *\n     *  {\n     *    first_note: Note,\n     *    last_note: Note,\n     *    first_indices: [n1, n2, n3],\n     *    last_indices: [n1, n2, n3]\n     *  }\n     *\n     **/\n    super(notes, 'sl.');\n    this.setAttribute('type', 'TabSlide');\n\n    if (!direction) {\n      const first_fret = notes.first_note.getPositions()[0].fret;\n      const last_fret = notes.last_note.getPositions()[0].fret;\n      direction = parseInt(first_fret, 10) > parseInt(last_fret, 10) ? TabSlide.SLIDE_DOWN : TabSlide.SLIDE_UP;\n    }\n\n    this.slide_direction = direction;\n    this.render_options.cp1 = 11;\n    this.render_options.cp2 = 14;\n    this.render_options.y_shift = 0.5;\n    this.setFont({\n      font: 'Times',\n      size: 10,\n      style: 'bold italic'\n    });\n    this.setNotes(notes);\n  }\n\n  renderTie(params) {\n    if (params.first_ys.length === 0 || params.last_ys.length === 0) {\n      throw new Vex.RERR('BadArguments', 'No Y-values to render');\n    }\n\n    const ctx = this.context;\n    const first_x_px = params.first_x_px;\n    const first_ys = params.first_ys;\n    const last_x_px = params.last_x_px;\n    const direction = this.slide_direction;\n\n    if (direction !== TabSlide.SLIDE_UP && direction !== TabSlide.SLIDE_DOWN) {\n      throw new Vex.RERR('BadSlide', 'Invalid slide direction');\n    }\n\n    for (let i = 0; i < this.first_indices.length; ++i) {\n      const slide_y = first_ys[this.first_indices[i]] + this.render_options.y_shift;\n\n      if (isNaN(slide_y)) {\n        throw new Vex.RERR('BadArguments', 'Bad indices for slide rendering.');\n      }\n\n      ctx.beginPath();\n      ctx.moveTo(first_x_px, slide_y + 3 * direction);\n      ctx.lineTo(last_x_px, slide_y - 3 * direction);\n      ctx.closePath();\n      ctx.stroke();\n    }\n\n    this.setRendered();\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/tabslide.js"],"names":["Vex","TabTie","TabSlide","SLIDE_UP","SLIDE_DOWN","createSlideUp","notes","createSlideDown","constructor","direction","setAttribute","first_fret","first_note","getPositions","fret","last_fret","last_note","parseInt","slide_direction","render_options","cp1","cp2","y_shift","setFont","font","size","style","setNotes","renderTie","params","first_ys","length","last_ys","RERR","ctx","context","first_x_px","last_x_px","i","first_indices","slide_y","isNaN","beginPath","moveTo","lineTo","closePath","stroke","setRendered"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AAEA,SAASA,GAAT,QAAoB,OAApB;AACA,SAASC,MAAT,QAAuB,UAAvB;AAEA,OAAO,MAAMC,QAAN,SAAuBD,MAAvB,CAA8B;AACnC,aAAWE,QAAX,GAAsB;AACpB,WAAO,CAAP;AACD;;AACD,aAAWC,UAAX,GAAwB;AACtB,WAAO,CAAC,CAAR;AACD;;AAED,SAAOC,aAAP,CAAqBC,KAArB,EAA4B;AAC1B,WAAO,IAAIJ,QAAJ,CAAaI,KAAb,EAAoBJ,QAAQ,CAACC,QAA7B,CAAP;AACD;;AAED,SAAOI,eAAP,CAAuBD,KAAvB,EAA8B;AAC5B,WAAO,IAAIJ,QAAJ,CAAaI,KAAb,EAAoBJ,QAAQ,CAACE,UAA7B,CAAP;AACD;;AAEDI,EAAAA,WAAW,CAACF,KAAD,EAAQG,SAAR,EAAmB;AAC5B;;;;;;;;;;;AAWA,UAAMH,KAAN,EAAa,KAAb;AACA,SAAKI,YAAL,CAAkB,MAAlB,EAA0B,UAA1B;;AAEA,QAAI,CAACD,SAAL,EAAgB;AACd,YAAME,UAAU,GAAGL,KAAK,CAACM,UAAN,CAAiBC,YAAjB,GAAgC,CAAhC,EAAmCC,IAAtD;AACA,YAAMC,SAAS,GAAGT,KAAK,CAACU,SAAN,CAAgBH,YAAhB,GAA+B,CAA/B,EAAkCC,IAApD;AAEAL,MAAAA,SAAS,GAAKQ,QAAQ,CAACN,UAAD,EAAa,EAAb,CAAR,GAA2BM,QAAQ,CAACF,SAAD,EAAY,EAAZ,CAApC,GACXb,QAAQ,CAACE,UADE,GACWF,QAAQ,CAACC,QADjC;AAED;;AAED,SAAKe,eAAL,GAAuBT,SAAvB;AACA,SAAKU,cAAL,CAAoBC,GAApB,GAA0B,EAA1B;AACA,SAAKD,cAAL,CAAoBE,GAApB,GAA0B,EAA1B;AACA,SAAKF,cAAL,CAAoBG,OAApB,GAA8B,GAA9B;AAEA,SAAKC,OAAL,CAAa;AAAEC,MAAAA,IAAI,EAAE,OAAR;AAAiBC,MAAAA,IAAI,EAAE,EAAvB;AAA2BC,MAAAA,KAAK,EAAE;AAAlC,KAAb;AACA,SAAKC,QAAL,CAAcrB,KAAd;AACD;;AAEDsB,EAAAA,SAAS,CAACC,MAAD,EAAS;AAChB,QAAIA,MAAM,CAACC,QAAP,CAAgBC,MAAhB,KAA2B,CAA3B,IAAgCF,MAAM,CAACG,OAAP,CAAeD,MAAf,KAA0B,CAA9D,EAAiE;AAC/D,YAAM,IAAI/B,GAAG,CAACiC,IAAR,CAAa,cAAb,EAA6B,uBAA7B,CAAN;AACD;;AAED,UAAMC,GAAG,GAAG,KAAKC,OAAjB;AACA,UAAMC,UAAU,GAAGP,MAAM,CAACO,UAA1B;AACA,UAAMN,QAAQ,GAAGD,MAAM,CAACC,QAAxB;AACA,UAAMO,SAAS,GAAGR,MAAM,CAACQ,SAAzB;AAEA,UAAM5B,SAAS,GAAG,KAAKS,eAAvB;;AACA,QAAIT,SAAS,KAAKP,QAAQ,CAACC,QAAvB,IAAmCM,SAAS,KAAKP,QAAQ,CAACE,UAA9D,EAA0E;AACxE,YAAM,IAAIJ,GAAG,CAACiC,IAAR,CAAa,UAAb,EAAyB,yBAAzB,CAAN;AACD;;AAED,SAAK,IAAIK,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKC,aAAL,CAAmBR,MAAvC,EAA+C,EAAEO,CAAjD,EAAoD;AAClD,YAAME,OAAO,GAAGV,QAAQ,CAAC,KAAKS,aAAL,CAAmBD,CAAnB,CAAD,CAAR,GACd,KAAKnB,cAAL,CAAoBG,OADtB;;AAGA,UAAImB,KAAK,CAACD,OAAD,CAAT,EAAoB;AAClB,cAAM,IAAIxC,GAAG,CAACiC,IAAR,CAAa,cAAb,EAA6B,kCAA7B,CAAN;AACD;;AAEDC,MAAAA,GAAG,CAACQ,SAAJ;AACAR,MAAAA,GAAG,CAACS,MAAJ,CAAWP,UAAX,EAAuBI,OAAO,GAAI,IAAI/B,SAAtC;AACAyB,MAAAA,GAAG,CAACU,MAAJ,CAAWP,SAAX,EAAsBG,OAAO,GAAI,IAAI/B,SAArC;AACAyB,MAAAA,GAAG,CAACW,SAAJ;AACAX,MAAAA,GAAG,CAACY,MAAJ;AACD;;AAED,SAAKC,WAAL;AACD;;AA/EkC","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n// This class implements varies types of ties between contiguous notes. The\n// ties include: regular ties, hammer ons, pull offs, and slides.\n\nimport { Vex } from './vex';\nimport { TabTie } from './tabtie';\n\nexport class TabSlide extends TabTie {\n  static get SLIDE_UP() {\n    return 1;\n  }\n  static get SLIDE_DOWN() {\n    return -1;\n  }\n\n  static createSlideUp(notes) {\n    return new TabSlide(notes, TabSlide.SLIDE_UP);\n  }\n\n  static createSlideDown(notes) {\n    return new TabSlide(notes, TabSlide.SLIDE_DOWN);\n  }\n\n  constructor(notes, direction) {\n    /**\n     * Notes is a struct that has:\n     *\n     *  {\n     *    first_note: Note,\n     *    last_note: Note,\n     *    first_indices: [n1, n2, n3],\n     *    last_indices: [n1, n2, n3]\n     *  }\n     *\n     **/\n    super(notes, 'sl.');\n    this.setAttribute('type', 'TabSlide');\n\n    if (!direction) {\n      const first_fret = notes.first_note.getPositions()[0].fret;\n      const last_fret = notes.last_note.getPositions()[0].fret;\n\n      direction = ((parseInt(first_fret, 10) > parseInt(last_fret, 10)) ?\n        TabSlide.SLIDE_DOWN : TabSlide.SLIDE_UP);\n    }\n\n    this.slide_direction = direction;\n    this.render_options.cp1 = 11;\n    this.render_options.cp2 = 14;\n    this.render_options.y_shift = 0.5;\n\n    this.setFont({ font: 'Times', size: 10, style: 'bold italic' });\n    this.setNotes(notes);\n  }\n\n  renderTie(params) {\n    if (params.first_ys.length === 0 || params.last_ys.length === 0) {\n      throw new Vex.RERR('BadArguments', 'No Y-values to render');\n    }\n\n    const ctx = this.context;\n    const first_x_px = params.first_x_px;\n    const first_ys = params.first_ys;\n    const last_x_px = params.last_x_px;\n\n    const direction = this.slide_direction;\n    if (direction !== TabSlide.SLIDE_UP && direction !== TabSlide.SLIDE_DOWN) {\n      throw new Vex.RERR('BadSlide', 'Invalid slide direction');\n    }\n\n    for (let i = 0; i < this.first_indices.length; ++i) {\n      const slide_y = first_ys[this.first_indices[i]] +\n        this.render_options.y_shift;\n\n      if (isNaN(slide_y)) {\n        throw new Vex.RERR('BadArguments', 'Bad indices for slide rendering.');\n      }\n\n      ctx.beginPath();\n      ctx.moveTo(first_x_px, slide_y + (3 * direction));\n      ctx.lineTo(last_x_px, slide_y - (3 * direction));\n      ctx.closePath();\n      ctx.stroke();\n    }\n\n    this.setRendered();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}