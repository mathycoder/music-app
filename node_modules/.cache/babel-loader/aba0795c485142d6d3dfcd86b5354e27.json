{"ast":null,"code":"// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n// A formatter for abstract tickable objects, such as notes, chords,\n// tabs, etc.\nimport { Vex } from './vex';\nimport { Tickable } from './tickable';\nimport { Fraction } from './fraction';\nexport class TickContext extends Tickable {\n  static getNextContext(tContext) {\n    const contexts = tContext.tContexts;\n    const index = contexts.indexOf(tContext);\n    return contexts[index + 1];\n  }\n\n  constructor(options) {\n    super();\n    this.tickID = options && options.tickID;\n    this.setAttribute('type', 'TickContext');\n    this.currentTick = new Fraction(0, 1);\n    this.maxTicks = new Fraction(0, 1);\n    this.maxTickable = null; // Biggest tickable\n\n    this.minTicks = null; // this can remian null if all tickables have ignore_ticks\n\n    this.minTickable = null;\n    this.padding = 1; // padding on each side (width += padding * 2)\n\n    this.x = 0;\n    this.xBase = 0; // base x position without xOffset\n\n    this.xOffset = 0; // xBase and xOffset are an alternative way to describe x (x = xB + xO)\n\n    this.tickables = []; // Notes, tabs, chords, lyrics.\n\n    this.tickablesByVoice = {}; // Tickables indeced by voice number\n    // Formatting metrics\n\n    this.notePx = 0; // width of widest note in this context\n\n    this.glyphPx = 0; // width of glyph (note head)\n\n    this.leftDisplacedHeadPx = 0; // Extra left pixels for displaced notes\n\n    this.rightDisplacedHeadPx = 0; // Extra right pixels for displaced notes\n\n    this.modLeftPx = 0; // Left modifier pixels\n\n    this.modRightPx = 0; // Right modifier pixels\n\n    this.totalLeftPx = 0; // Total left pixels\n\n    this.totalRightPx = 0; // Total right pixels\n\n    this.tContexts = []; // Parent array of tick contexts\n  }\n\n  getTickID() {\n    return this.tickID;\n  }\n\n  getX() {\n    return this.x;\n  }\n\n  setX(x) {\n    this.x = x;\n    this.xBase = x;\n    this.xOffset = 0;\n    return this;\n  }\n\n  getXBase() {\n    return this.xBase;\n  } // use of xBase and xOffset is optional, avoids offset creep\n\n\n  setXBase(xBase) {\n    this.xBase = xBase;\n    this.x = xBase + this.xOffset;\n  }\n\n  getXOffset() {\n    return this.xOffset;\n  }\n\n  setXOffset(xOffset) {\n    this.xOffset = xOffset;\n    this.x = this.xBase + xOffset;\n  }\n\n  getWidth() {\n    return this.width + this.padding * 2;\n  }\n\n  setPadding(padding) {\n    this.padding = padding;\n    return this;\n  }\n\n  getMaxTicks() {\n    return this.maxTicks;\n  }\n\n  getMinTicks() {\n    return this.minTicks;\n  }\n\n  getMaxTickable() {\n    return this.maxTickable;\n  }\n\n  getMinTickable() {\n    return this.minTickable;\n  }\n\n  getTickables() {\n    return this.tickables;\n  }\n\n  getTickablesForVoice(voiceIndex) {\n    return this.tickablesByVoice[voiceIndex];\n  }\n\n  getTickablesByVoice() {\n    return this.tickablesByVoice;\n  }\n\n  getCenterAlignedTickables() {\n    return this.tickables.filter(tickable => tickable.isCenterAligned());\n  } // Get widths context, note and left/right modifiers for formatting\n\n\n  getMetrics() {\n    const {\n      width,\n      glyphPx,\n      notePx,\n      leftDisplacedHeadPx,\n      rightDisplacedHeadPx,\n      modLeftPx,\n      modRightPx,\n      totalLeftPx,\n      totalRightPx\n    } = this;\n    return {\n      width,\n      // Width of largest tickable in context\n      glyphPx,\n      // Width of largest glyph (note head)\n      notePx,\n      // Width of notehead + stem\n      leftDisplacedHeadPx,\n      // Left modifiers\n      rightDisplacedHeadPx,\n      // Right modifiers\n      modLeftPx,\n      modRightPx,\n      totalLeftPx,\n      totalRightPx\n    };\n  }\n\n  getCurrentTick() {\n    return this.currentTick;\n  }\n\n  setCurrentTick(tick) {\n    this.currentTick = tick;\n    this.preFormatted = false;\n  }\n\n  addTickable(tickable, voiceIndex) {\n    if (!tickable) {\n      throw new Vex.RERR('BadArgument', 'Invalid tickable added.');\n    }\n\n    if (!tickable.shouldIgnoreTicks()) {\n      this.ignore_ticks = false;\n      const ticks = tickable.getTicks();\n\n      if (ticks.greaterThan(this.maxTicks)) {\n        this.maxTicks = ticks.clone();\n        this.maxTickable = tickable;\n      }\n\n      if (this.minTicks == null) {\n        this.minTicks = ticks.clone();\n        this.minTickable = tickable;\n      } else if (ticks.lessThan(this.minTicks)) {\n        this.minTicks = ticks.clone();\n        this.minTickable = tickable;\n      }\n    }\n\n    tickable.setTickContext(this);\n    this.tickables.push(tickable);\n    this.tickablesByVoice[voiceIndex] = tickable;\n    this.preFormatted = false;\n    return this;\n  }\n\n  preFormat() {\n    if (this.preFormatted) return this;\n\n    for (let i = 0; i < this.tickables.length; ++i) {\n      const tickable = this.tickables[i];\n      tickable.preFormat();\n      const metrics = tickable.getMetrics(); // Maintain max displaced head pixels from all tickables in the context\n\n      this.leftDisplacedHeadPx = Math.max(this.leftDisplacedHeadPx, metrics.leftDisplacedHeadPx);\n      this.rightDisplacedHeadPx = Math.max(this.rightDisplacedHeadPx, metrics.rightDisplacedHeadPx); // Maintain the widest note for all tickables in the context\n\n      this.notePx = Math.max(this.notePx, metrics.notePx); // Maintain the widest note head\n\n      this.glyphPx = Math.max(this.glyphPx, metrics.glyphWidth); // Total modifier shift\n\n      this.modLeftPx = Math.max(this.modLeftPx, metrics.modLeftPx);\n      this.modRightPx = Math.max(this.modRightPx, metrics.modRightPx); // Total shift\n\n      this.totalLeftPx = Math.max(this.totalLeftPx, metrics.modLeftPx + metrics.leftDisplacedHeadPx);\n      this.totalRightPx = Math.max(this.totalRightPx, metrics.modRightPx + metrics.rightDisplacedHeadPx); // Recalculate the tick context total width\n\n      this.width = this.notePx + this.totalLeftPx + this.totalRightPx;\n    }\n\n    return this;\n  }\n\n  postFormat() {\n    if (this.postFormatted) return this;\n    this.postFormatted = true;\n    return this;\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/tickcontext.js"],"names":["Vex","Tickable","Fraction","TickContext","getNextContext","tContext","contexts","tContexts","index","indexOf","constructor","options","tickID","setAttribute","currentTick","maxTicks","maxTickable","minTicks","minTickable","padding","x","xBase","xOffset","tickables","tickablesByVoice","notePx","glyphPx","leftDisplacedHeadPx","rightDisplacedHeadPx","modLeftPx","modRightPx","totalLeftPx","totalRightPx","getTickID","getX","setX","getXBase","setXBase","getXOffset","setXOffset","getWidth","width","setPadding","getMaxTicks","getMinTicks","getMaxTickable","getMinTickable","getTickables","getTickablesForVoice","voiceIndex","getTickablesByVoice","getCenterAlignedTickables","filter","tickable","isCenterAligned","getMetrics","getCurrentTick","setCurrentTick","tick","preFormatted","addTickable","RERR","shouldIgnoreTicks","ignore_ticks","ticks","getTicks","greaterThan","clone","lessThan","setTickContext","push","preFormat","i","length","metrics","Math","max","glyphWidth","postFormat","postFormatted"],"mappings":"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","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n// A formatter for abstract tickable objects, such as notes, chords,\n// tabs, etc.\n\nimport { Vex } from './vex';\nimport { Tickable } from './tickable';\nimport { Fraction } from './fraction';\n\nexport class TickContext extends Tickable {\n  static getNextContext(tContext) {\n    const contexts = tContext.tContexts;\n    const index = contexts.indexOf(tContext);\n\n    return contexts[index + 1];\n  }\n\n  constructor(options) {\n    super();\n    this.tickID = options && options.tickID;\n    this.setAttribute('type', 'TickContext');\n    this.currentTick = new Fraction(0, 1);\n\n    this.maxTicks = new Fraction(0, 1);\n    this.maxTickable = null; // Biggest tickable\n    this.minTicks = null; // this can remian null if all tickables have ignore_ticks\n    this.minTickable = null;\n\n    this.padding = 1;     // padding on each side (width += padding * 2)\n    this.x = 0;\n    this.xBase = 0;        // base x position without xOffset\n    this.xOffset = 0;      // xBase and xOffset are an alternative way to describe x (x = xB + xO)\n    this.tickables = [];   // Notes, tabs, chords, lyrics.\n    this.tickablesByVoice = {};   // Tickables indeced by voice number\n\n    // Formatting metrics\n    this.notePx = 0;       // width of widest note in this context\n    this.glyphPx = 0;       // width of glyph (note head)\n    this.leftDisplacedHeadPx = 0;  // Extra left pixels for displaced notes\n    this.rightDisplacedHeadPx = 0; // Extra right pixels for displaced notes\n    this.modLeftPx = 0; // Left modifier pixels\n    this.modRightPx = 0; // Right modifier pixels\n    this.totalLeftPx = 0;  // Total left pixels\n    this.totalRightPx = 0; // Total right pixels\n    this.tContexts = [];   // Parent array of tick contexts\n  }\n\n  getTickID() { return this.tickID; }\n  getX() { return this.x; }\n  setX(x) { this.x = x; this.xBase = x; this.xOffset = 0; return this; }\n  getXBase() { return this.xBase; } // use of xBase and xOffset is optional, avoids offset creep\n  setXBase(xBase) { this.xBase = xBase; this.x = xBase + this.xOffset; }\n  getXOffset() { return this.xOffset; }\n  setXOffset(xOffset) { this.xOffset = xOffset; this.x = this.xBase + xOffset; }\n  getWidth() { return this.width + (this.padding * 2); }\n  setPadding(padding) { this.padding = padding; return this; }\n  getMaxTicks() { return this.maxTicks; }\n  getMinTicks() { return this.minTicks; }\n  getMaxTickable() { return this.maxTickable; }\n  getMinTickable() { return this.minTickable; }\n  getTickables() { return this.tickables; }\n  getTickablesForVoice(voiceIndex) { return this.tickablesByVoice[voiceIndex]; }\n  getTickablesByVoice() { return this.tickablesByVoice; }\n\n  getCenterAlignedTickables() {\n    return this.tickables.filter(tickable => tickable.isCenterAligned());\n  }\n\n  // Get widths context, note and left/right modifiers for formatting\n  getMetrics() {\n    const { width, glyphPx, notePx, leftDisplacedHeadPx, rightDisplacedHeadPx, modLeftPx, modRightPx, totalLeftPx, totalRightPx } = this;\n    return {\n      width, // Width of largest tickable in context\n      glyphPx, // Width of largest glyph (note head)\n      notePx, // Width of notehead + stem\n      leftDisplacedHeadPx, // Left modifiers\n      rightDisplacedHeadPx, // Right modifiers\n      modLeftPx,\n      modRightPx,\n      totalLeftPx,\n      totalRightPx\n    };\n  }\n\n  getCurrentTick() { return this.currentTick; }\n  setCurrentTick(tick) {\n    this.currentTick = tick;\n    this.preFormatted = false;\n  }\n\n  addTickable(tickable, voiceIndex) {\n    if (!tickable) {\n      throw new Vex.RERR('BadArgument', 'Invalid tickable added.');\n    }\n\n    if (!tickable.shouldIgnoreTicks()) {\n      this.ignore_ticks = false;\n\n      const ticks = tickable.getTicks();\n\n      if (ticks.greaterThan(this.maxTicks)) {\n        this.maxTicks = ticks.clone();\n        this.maxTickable = tickable;\n      }\n\n      if (this.minTicks == null) {\n        this.minTicks = ticks.clone();\n        this.minTickable = tickable;\n      } else if (ticks.lessThan(this.minTicks)) {\n        this.minTicks = ticks.clone();\n        this.minTickable = tickable;\n      }\n    }\n\n    tickable.setTickContext(this);\n    this.tickables.push(tickable);\n    this.tickablesByVoice[voiceIndex] = tickable;\n    this.preFormatted = false;\n    return this;\n  }\n\n  preFormat() {\n    if (this.preFormatted) return this;\n\n    for (let i = 0; i < this.tickables.length; ++i) {\n      const tickable = this.tickables[i];\n      tickable.preFormat();\n      const metrics = tickable.getMetrics();\n\n      // Maintain max displaced head pixels from all tickables in the context\n      this.leftDisplacedHeadPx = Math.max(this.leftDisplacedHeadPx, metrics.leftDisplacedHeadPx);\n      this.rightDisplacedHeadPx = Math.max(this.rightDisplacedHeadPx, metrics.rightDisplacedHeadPx);\n\n      // Maintain the widest note for all tickables in the context\n      this.notePx = Math.max(this.notePx, metrics.notePx);\n\n      // Maintain the widest note head\n      this.glyphPx = Math.max(this.glyphPx, metrics.glyphWidth);\n\n      // Total modifier shift\n      this.modLeftPx = Math.max(this.modLeftPx, metrics.modLeftPx);\n      this.modRightPx = Math.max(this.modRightPx, metrics.modRightPx);\n\n      // Total shift\n      this.totalLeftPx = Math.max(this.totalLeftPx, metrics.modLeftPx + metrics.leftDisplacedHeadPx);\n      this.totalRightPx = Math.max(this.totalRightPx, metrics.modRightPx + metrics.rightDisplacedHeadPx);\n\n      // Recalculate the tick context total width\n      this.width = this.notePx + this.totalLeftPx + this.totalRightPx;\n    }\n\n    return this;\n  }\n\n  postFormat() {\n    if (this.postFormatted) return this;\n    this.postFormatted = true;\n    return this;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}