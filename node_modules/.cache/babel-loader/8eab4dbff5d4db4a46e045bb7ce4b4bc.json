{"ast":null,"code":"// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n//\n// This file implements `StaveLine` which are simply lines that connect\n// two notes. This object is highly configurable, see the `render_options`.\n// A simple line is often used for notating glissando articulations, but you\n// can format a `StaveLine` with arrows or colors for more pedagogical\n// purposes, such as diagrams.\nimport { Vex } from './vex';\nimport { Element } from './element';\nimport { Flow } from './tables'; // Attribution: Arrow rendering implementations based off of\n// Patrick Horgan's article, \"Drawing lines and arcs with\n// arrow heads on  HTML5 Canvas\"\n//\n// Draw an arrow head that connects between 3 coordinates\n\nfunction drawArrowHead(ctx, x0, y0, x1, y1, x2, y2) {\n  // all cases do this.\n  ctx.beginPath();\n  ctx.moveTo(x0, y0);\n  ctx.lineTo(x1, y1);\n  ctx.lineTo(x2, y2);\n  ctx.lineTo(x0, y0);\n  ctx.closePath();\n  ctx.fill();\n} // Helper function to draw a line with arrow heads\n\n\nfunction drawArrowLine(ctx, point1, point2, config) {\n  const both_arrows = config.draw_start_arrow && config.draw_end_arrow;\n  const x1 = point1.x;\n  const y1 = point1.y;\n  const x2 = point2.x;\n  const y2 = point2.y; // For ends with arrow we actually want to stop before we get to the arrow\n  // so that wide lines won't put a flat end on the arrow.\n\n  const distance = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n  const ratio = (distance - config.arrowhead_length / 3) / distance;\n  let end_x;\n  let end_y;\n  let start_x;\n  let start_y;\n\n  if (config.draw_end_arrow || both_arrows) {\n    end_x = Math.round(x1 + (x2 - x1) * ratio);\n    end_y = Math.round(y1 + (y2 - y1) * ratio);\n  } else {\n    end_x = x2;\n    end_y = y2;\n  }\n\n  if (config.draw_start_arrow || both_arrows) {\n    start_x = x1 + (x2 - x1) * (1 - ratio);\n    start_y = y1 + (y2 - y1) * (1 - ratio);\n  } else {\n    start_x = x1;\n    start_y = y1;\n  }\n\n  if (config.color) {\n    ctx.setStrokeStyle(config.color);\n    ctx.setFillStyle(config.color);\n  } // Draw the shaft of the arrow\n\n\n  ctx.beginPath();\n  ctx.moveTo(start_x, start_y);\n  ctx.lineTo(end_x, end_y);\n  ctx.stroke();\n  ctx.closePath(); // calculate the angle of the line\n\n  const line_angle = Math.atan2(y2 - y1, x2 - x1); // h is the line length of a side of the arrow head\n\n  const h = Math.abs(config.arrowhead_length / Math.cos(config.arrowhead_angle));\n  let angle1;\n  let angle2;\n  let top_x;\n  let top_y;\n  let bottom_x;\n  let bottom_y;\n\n  if (config.draw_end_arrow || both_arrows) {\n    angle1 = line_angle + Math.PI + config.arrowhead_angle;\n    top_x = x2 + Math.cos(angle1) * h;\n    top_y = y2 + Math.sin(angle1) * h;\n    angle2 = line_angle + Math.PI - config.arrowhead_angle;\n    bottom_x = x2 + Math.cos(angle2) * h;\n    bottom_y = y2 + Math.sin(angle2) * h;\n    drawArrowHead(ctx, top_x, top_y, x2, y2, bottom_x, bottom_y);\n  }\n\n  if (config.draw_start_arrow || both_arrows) {\n    angle1 = line_angle + config.arrowhead_angle;\n    top_x = x1 + Math.cos(angle1) * h;\n    top_y = y1 + Math.sin(angle1) * h;\n    angle2 = line_angle - config.arrowhead_angle;\n    bottom_x = x1 + Math.cos(angle2) * h;\n    bottom_y = y1 + Math.sin(angle2) * h;\n    drawArrowHead(ctx, top_x, top_y, x1, y1, bottom_x, bottom_y);\n  }\n}\n\nexport class StaveLine extends Element {\n  // Text Positioning\n  static get TextVerticalPosition() {\n    return {\n      TOP: 1,\n      BOTTOM: 2\n    };\n  }\n\n  static get TextJustification() {\n    return {\n      LEFT: 1,\n      CENTER: 2,\n      RIGHT: 3\n    };\n  } // Initialize the StaveLine with the given `notes`.\n  //\n  // `notes` is a struct that has:\n  //\n  //  ```\n  //  {\n  //    first_note: Note,\n  //    last_note: Note,\n  //    first_indices: [n1, n2, n3],\n  //    last_indices: [n1, n2, n3]\n  //  }\n  //  ```\n\n\n  constructor(notes) {\n    super();\n    this.setAttribute('type', 'StaveLine');\n    this.notes = notes;\n    this.text = '';\n    this.font = {\n      family: 'Arial',\n      size: 10,\n      weight: ''\n    };\n    this.render_options = {\n      // Space to add to the left or the right\n      padding_left: 4,\n      padding_right: 3,\n      // The width of the line in pixels\n      line_width: 1,\n      // An array of line/space lengths. Unsupported with Raphael (SVG)\n      line_dash: null,\n      // Can draw rounded line end, instead of a square. Unsupported with Raphael (SVG)\n      rounded_end: true,\n      // The color of the line and arrowheads\n      color: null,\n      // Flags to draw arrows on each end of the line\n      draw_start_arrow: false,\n      draw_end_arrow: false,\n      // The length of the arrowhead sides\n      arrowhead_length: 10,\n      // The angle of the arrowhead\n      arrowhead_angle: Math.PI / 8,\n      // The position of the text\n      text_position_vertical: StaveLine.TextVerticalPosition.TOP,\n      text_justification: StaveLine.TextJustification.CENTER\n    };\n    this.setNotes(notes);\n  } // Set the font for the `StaveLine` text\n\n\n  setFont(font) {\n    this.font = font;\n    return this;\n  } // The the annotation for the `StaveLine`\n\n\n  setText(text) {\n    this.text = text;\n    return this;\n  } // Set the notes for the `StaveLine`\n\n\n  setNotes(notes) {\n    if (!notes.first_note && !notes.last_note) {\n      throw new Vex.RuntimeError('BadArguments', 'Notes needs to have either first_note or last_note set.');\n    }\n\n    if (!notes.first_indices) notes.first_indices = [0];\n    if (!notes.last_indices) notes.last_indices = [0];\n\n    if (notes.first_indices.length !== notes.last_indices.length) {\n      throw new Vex.RuntimeError('BadArguments', 'Connected notes must have similar index sizes');\n    } // Success. Lets grab 'em notes.\n\n\n    this.first_note = notes.first_note;\n    this.first_indices = notes.first_indices;\n    this.last_note = notes.last_note;\n    this.last_indices = notes.last_indices;\n    return this;\n  } // Apply the style of the `StaveLine` to the context\n\n\n  applyLineStyle() {\n    const ctx = this.checkContext();\n    const render_options = this.render_options;\n\n    if (render_options.line_dash) {\n      ctx.setLineDash(render_options.line_dash);\n    }\n\n    if (render_options.line_width) {\n      ctx.setLineWidth(render_options.line_width);\n    }\n\n    if (render_options.rounded_end) {\n      ctx.setLineCap('round');\n    } else {\n      ctx.setLineCap('square');\n    }\n  } // Apply the text styling to the context\n\n\n  applyFontStyle() {\n    const ctx = this.checkContext();\n\n    if (this.font) {\n      ctx.setFont(this.font.family, this.font.size, this.font.weight);\n    }\n\n    if (this.render_options.color) {\n      ctx.setStrokeStyle(this.render_options.color);\n      ctx.setFillStyle(this.render_options.color);\n    }\n  } // Renders the `StaveLine` on the context\n\n\n  draw() {\n    const ctx = this.checkContext();\n    this.setRendered();\n    const first_note = this.first_note;\n    const last_note = this.last_note;\n    const render_options = this.render_options;\n    ctx.save();\n    this.applyLineStyle(); // Cycle through each set of indices and draw lines\n\n    let start_position;\n    let end_position;\n    this.first_indices.forEach((first_index, i) => {\n      const last_index = this.last_indices[i]; // Get initial coordinates for the start/end of the line\n\n      start_position = first_note.getModifierStartXY(2, first_index);\n      end_position = last_note.getModifierStartXY(1, last_index);\n      const upwards_slope = start_position.y > end_position.y; // Adjust `x` coordinates for modifiers\n\n      start_position.x += first_note.getMetrics().modRightPx + render_options.padding_left;\n      end_position.x -= last_note.getMetrics().modLeftPx + render_options.padding_right; // Adjust first `x` coordinates for displacements\n\n      const notehead_width = first_note.getGlyph().getWidth();\n      const first_displaced = first_note.getKeyProps()[first_index].displaced;\n\n      if (first_displaced && first_note.getStemDirection() === 1) {\n        start_position.x += notehead_width + render_options.padding_left;\n      } // Adjust last `x` coordinates for displacements\n\n\n      const last_displaced = last_note.getKeyProps()[last_index].displaced;\n\n      if (last_displaced && last_note.getStemDirection() === -1) {\n        end_position.x -= notehead_width + render_options.padding_right;\n      } // Adjust y position better if it's not coming from the center of the note\n\n\n      start_position.y += upwards_slope ? -3 : 1;\n      end_position.y += upwards_slope ? 2 : 0;\n      drawArrowLine(ctx, start_position, end_position, this.render_options);\n    });\n    ctx.restore(); // Determine the x coordinate where to start the text\n\n    const text_width = ctx.measureText(this.text).width;\n    const justification = render_options.text_justification;\n    let x = 0;\n\n    if (justification === StaveLine.TextJustification.LEFT) {\n      x = start_position.x;\n    } else if (justification === StaveLine.TextJustification.CENTER) {\n      const delta_x = end_position.x - start_position.x;\n      const center_x = delta_x / 2 + start_position.x;\n      x = center_x - text_width / 2;\n    } else if (justification === StaveLine.TextJustification.RIGHT) {\n      x = end_position.x - text_width;\n    } // Determine the y value to start the text\n\n\n    let y;\n    const vertical_position = render_options.text_position_vertical;\n\n    if (vertical_position === StaveLine.TextVerticalPosition.TOP) {\n      y = first_note.getStave().getYForTopText();\n    } else if (vertical_position === StaveLine.TextVerticalPosition.BOTTOM) {\n      y = first_note.getStave().getYForBottomText(Flow.TEXT_HEIGHT_OFFSET_HACK);\n    } // Draw the text\n\n\n    ctx.save();\n    this.applyFontStyle();\n    ctx.fillText(this.text, x, y);\n    ctx.restore();\n    return this;\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/staveline.js"],"names":["Vex","Element","Flow","drawArrowHead","ctx","x0","y0","x1","y1","x2","y2","beginPath","moveTo","lineTo","closePath","fill","drawArrowLine","point1","point2","config","both_arrows","draw_start_arrow","draw_end_arrow","x","y","distance","Math","sqrt","ratio","arrowhead_length","end_x","end_y","start_x","start_y","round","color","setStrokeStyle","setFillStyle","stroke","line_angle","atan2","h","abs","cos","arrowhead_angle","angle1","angle2","top_x","top_y","bottom_x","bottom_y","PI","sin","StaveLine","TextVerticalPosition","TOP","BOTTOM","TextJustification","LEFT","CENTER","RIGHT","constructor","notes","setAttribute","text","font","family","size","weight","render_options","padding_left","padding_right","line_width","line_dash","rounded_end","text_position_vertical","text_justification","setNotes","setFont","setText","first_note","last_note","RuntimeError","first_indices","last_indices","length","applyLineStyle","checkContext","setLineDash","setLineWidth","setLineCap","applyFontStyle","draw","setRendered","save","start_position","end_position","forEach","first_index","i","last_index","getModifierStartXY","upwards_slope","getMetrics","modRightPx","modLeftPx","notehead_width","getGlyph","getWidth","first_displaced","getKeyProps","displaced","getStemDirection","last_displaced","restore","text_width","measureText","width","justification","delta_x","center_x","vertical_position","getStave","getYForTopText","getYForBottomText","TEXT_HEIGHT_OFFSET_HACK","fillText"],"mappings":"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","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n//\n// This file implements `StaveLine` which are simply lines that connect\n// two notes. This object is highly configurable, see the `render_options`.\n// A simple line is often used for notating glissando articulations, but you\n// can format a `StaveLine` with arrows or colors for more pedagogical\n// purposes, such as diagrams.\nimport { Vex } from './vex';\nimport { Element } from './element';\nimport { Flow } from './tables';\n\n// Attribution: Arrow rendering implementations based off of\n// Patrick Horgan's article, \"Drawing lines and arcs with\n// arrow heads on  HTML5 Canvas\"\n//\n// Draw an arrow head that connects between 3 coordinates\nfunction drawArrowHead(ctx, x0, y0, x1, y1, x2, y2) {\n  // all cases do this.\n  ctx.beginPath();\n  ctx.moveTo(x0, y0);\n  ctx.lineTo(x1, y1);\n  ctx.lineTo(x2, y2);\n  ctx.lineTo(x0, y0);\n  ctx.closePath();\n\n  ctx.fill();\n}\n\n// Helper function to draw a line with arrow heads\nfunction drawArrowLine(ctx, point1, point2, config) {\n  const both_arrows = config.draw_start_arrow && config.draw_end_arrow;\n\n  const x1 = point1.x;\n  const y1 = point1.y;\n  const x2 = point2.x;\n  const y2 = point2.y;\n\n  // For ends with arrow we actually want to stop before we get to the arrow\n  // so that wide lines won't put a flat end on the arrow.\n  const distance = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));\n  const ratio = (distance - config.arrowhead_length / 3) / distance;\n  let end_x;\n  let end_y;\n  let start_x;\n  let start_y;\n  if (config.draw_end_arrow || both_arrows) {\n    end_x = Math.round(x1 + (x2 - x1) * ratio);\n    end_y = Math.round(y1 + (y2 - y1) * ratio);\n  } else {\n    end_x = x2;\n    end_y = y2;\n  }\n\n  if (config.draw_start_arrow || both_arrows) {\n    start_x = x1 + (x2 - x1) * (1 - ratio);\n    start_y = y1 + (y2 - y1) * (1 - ratio);\n  } else {\n    start_x = x1;\n    start_y = y1;\n  }\n\n  if (config.color) {\n    ctx.setStrokeStyle(config.color);\n    ctx.setFillStyle(config.color);\n  }\n\n  // Draw the shaft of the arrow\n  ctx.beginPath();\n  ctx.moveTo(start_x, start_y);\n  ctx.lineTo(end_x, end_y);\n  ctx.stroke();\n  ctx.closePath();\n\n  // calculate the angle of the line\n  const line_angle = Math.atan2(y2 - y1, x2 - x1);\n  // h is the line length of a side of the arrow head\n  const h = Math.abs(config.arrowhead_length / Math.cos(config.arrowhead_angle));\n\n  let angle1;\n  let angle2;\n  let top_x;\n  let top_y;\n  let bottom_x;\n  let bottom_y;\n\n  if (config.draw_end_arrow || both_arrows) {\n    angle1 = line_angle + Math.PI + config.arrowhead_angle;\n    top_x = x2 + Math.cos(angle1) * h;\n    top_y = y2 + Math.sin(angle1) * h;\n\n    angle2 = line_angle + Math.PI - config.arrowhead_angle;\n    bottom_x = x2 + Math.cos(angle2) * h;\n    bottom_y = y2 + Math.sin(angle2) * h;\n\n    drawArrowHead(ctx, top_x, top_y, x2, y2, bottom_x, bottom_y);\n  }\n\n  if (config.draw_start_arrow || both_arrows) {\n    angle1 = line_angle + config.arrowhead_angle;\n    top_x = x1 + Math.cos(angle1) * h;\n    top_y = y1 + Math.sin(angle1) * h;\n\n    angle2 = line_angle - config.arrowhead_angle;\n    bottom_x = x1 + Math.cos(angle2) * h;\n    bottom_y = y1 + Math.sin(angle2) * h;\n\n    drawArrowHead(ctx, top_x, top_y, x1, y1, bottom_x, bottom_y);\n  }\n}\n\nexport class StaveLine extends Element {\n  // Text Positioning\n  static get TextVerticalPosition() {\n    return {\n      TOP: 1,\n      BOTTOM: 2,\n    };\n  }\n\n  static get TextJustification() {\n    return {\n      LEFT: 1,\n      CENTER: 2,\n      RIGHT: 3,\n    };\n  }\n\n  // Initialize the StaveLine with the given `notes`.\n  //\n  // `notes` is a struct that has:\n  //\n  //  ```\n  //  {\n  //    first_note: Note,\n  //    last_note: Note,\n  //    first_indices: [n1, n2, n3],\n  //    last_indices: [n1, n2, n3]\n  //  }\n  //  ```\n  constructor(notes) {\n    super();\n    this.setAttribute('type', 'StaveLine');\n\n    this.notes = notes;\n\n    this.text = '';\n\n    this.font = {\n      family: 'Arial',\n      size: 10,\n      weight: '',\n    };\n\n    this.render_options = {\n      // Space to add to the left or the right\n      padding_left: 4,\n      padding_right: 3,\n\n      // The width of the line in pixels\n      line_width: 1,\n      // An array of line/space lengths. Unsupported with Raphael (SVG)\n      line_dash: null,\n      // Can draw rounded line end, instead of a square. Unsupported with Raphael (SVG)\n      rounded_end: true,\n      // The color of the line and arrowheads\n      color: null,\n\n      // Flags to draw arrows on each end of the line\n      draw_start_arrow: false,\n      draw_end_arrow: false,\n\n      // The length of the arrowhead sides\n      arrowhead_length: 10,\n      // The angle of the arrowhead\n      arrowhead_angle: Math.PI / 8,\n\n      // The position of the text\n      text_position_vertical: StaveLine.TextVerticalPosition.TOP,\n      text_justification: StaveLine.TextJustification.CENTER,\n    };\n\n    this.setNotes(notes);\n  }\n\n  // Set the font for the `StaveLine` text\n  setFont(font) { this.font = font; return this; }\n  // The the annotation for the `StaveLine`\n  setText(text) { this.text = text; return this; }\n\n  // Set the notes for the `StaveLine`\n  setNotes(notes) {\n    if (!notes.first_note && !notes.last_note) {\n      throw new Vex.RuntimeError(\n        'BadArguments', 'Notes needs to have either first_note or last_note set.'\n      );\n    }\n\n    if (!notes.first_indices) notes.first_indices = [0];\n    if (!notes.last_indices) notes.last_indices = [0];\n\n    if (notes.first_indices.length !== notes.last_indices.length) {\n      throw new Vex.RuntimeError(\n        'BadArguments', 'Connected notes must have similar index sizes'\n      );\n    }\n\n    // Success. Lets grab 'em notes.\n    this.first_note = notes.first_note;\n    this.first_indices = notes.first_indices;\n    this.last_note = notes.last_note;\n    this.last_indices = notes.last_indices;\n    return this;\n  }\n\n  // Apply the style of the `StaveLine` to the context\n  applyLineStyle() {\n    const ctx = this.checkContext();\n    const render_options = this.render_options;\n\n    if (render_options.line_dash) {\n      ctx.setLineDash(render_options.line_dash);\n    }\n\n    if (render_options.line_width) {\n      ctx.setLineWidth(render_options.line_width);\n    }\n\n    if (render_options.rounded_end) {\n      ctx.setLineCap('round');\n    } else {\n      ctx.setLineCap('square');\n    }\n  }\n\n  // Apply the text styling to the context\n  applyFontStyle() {\n    const ctx = this.checkContext();\n\n    if (this.font) {\n      ctx.setFont(this.font.family, this.font.size, this.font.weight);\n    }\n\n    if (this.render_options.color) {\n      ctx.setStrokeStyle(this.render_options.color);\n      ctx.setFillStyle(this.render_options.color);\n    }\n  }\n\n  // Renders the `StaveLine` on the context\n  draw() {\n    const ctx = this.checkContext();\n    this.setRendered();\n\n    const first_note = this.first_note;\n    const last_note = this.last_note;\n    const render_options = this.render_options;\n\n    ctx.save();\n    this.applyLineStyle();\n\n    // Cycle through each set of indices and draw lines\n    let start_position;\n    let end_position;\n    this.first_indices.forEach((first_index, i) => {\n      const last_index = this.last_indices[i];\n\n      // Get initial coordinates for the start/end of the line\n      start_position = first_note.getModifierStartXY(2, first_index);\n      end_position = last_note.getModifierStartXY(1, last_index);\n      const upwards_slope = start_position.y > end_position.y;\n\n      // Adjust `x` coordinates for modifiers\n      start_position.x += first_note.getMetrics().modRightPx + render_options.padding_left;\n      end_position.x -= last_note.getMetrics().modLeftPx + render_options.padding_right;\n\n\n      // Adjust first `x` coordinates for displacements\n      const notehead_width = first_note.getGlyph().getWidth();\n      const first_displaced = first_note.getKeyProps()[first_index].displaced;\n      if (first_displaced && first_note.getStemDirection() === 1) {\n        start_position.x += notehead_width + render_options.padding_left;\n      }\n\n      // Adjust last `x` coordinates for displacements\n      const last_displaced = last_note.getKeyProps()[last_index].displaced;\n      if (last_displaced && last_note.getStemDirection() === -1) {\n        end_position.x -= notehead_width + render_options.padding_right;\n      }\n\n      // Adjust y position better if it's not coming from the center of the note\n      start_position.y += upwards_slope ? -3 : 1;\n      end_position.y += upwards_slope ? 2 : 0;\n\n      drawArrowLine(ctx, start_position, end_position, this.render_options);\n    });\n\n    ctx.restore();\n\n    // Determine the x coordinate where to start the text\n    const text_width = ctx.measureText(this.text).width;\n    const justification = render_options.text_justification;\n    let x = 0;\n    if (justification === StaveLine.TextJustification.LEFT) {\n      x = start_position.x;\n    } else if (justification === StaveLine.TextJustification.CENTER) {\n      const delta_x = (end_position.x - start_position.x);\n      const center_x = (delta_x / 2) + start_position.x;\n      x = center_x - (text_width / 2);\n    } else if (justification === StaveLine.TextJustification.RIGHT) {\n      x = end_position.x  -  text_width;\n    }\n\n    // Determine the y value to start the text\n    let y;\n    const vertical_position = render_options.text_position_vertical;\n    if (vertical_position === StaveLine.TextVerticalPosition.TOP) {\n      y = first_note.getStave().getYForTopText();\n    } else if (vertical_position === StaveLine.TextVerticalPosition.BOTTOM) {\n      y = first_note.getStave().getYForBottomText(Flow.TEXT_HEIGHT_OFFSET_HACK);\n    }\n\n    // Draw the text\n    ctx.save();\n    this.applyFontStyle();\n    ctx.fillText(this.text, x, y);\n    ctx.restore();\n\n    return this;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}