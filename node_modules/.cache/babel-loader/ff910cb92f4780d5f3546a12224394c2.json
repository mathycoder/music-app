{"ast":null,"code":"// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\nimport { Vex } from './vex';\nimport { Element } from './element';\nimport { Flow } from './tables';\nimport { Barline } from './stavebarline';\nimport { StaveModifier } from './stavemodifier';\nimport { Repetition } from './staverepetition';\nimport { StaveSection } from './stavesection';\nimport { StaveTempo } from './stavetempo';\nimport { StaveText } from './stavetext';\nimport { BoundingBox } from './boundingbox';\nimport { Clef } from './clef';\nimport { KeySignature } from './keysignature';\nimport { TimeSignature } from './timesignature';\nimport { Volta } from './stavevolta';\nexport class Stave extends Element {\n  constructor(x, y, width, options) {\n    super();\n    this.setAttribute('type', 'Stave');\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.formatted = false;\n    this.start_x = x + 5;\n    this.end_x = x + width;\n    this.modifiers = []; // stave modifiers (clef, key, time, barlines, coda, segno, etc.)\n\n    this.measure = 0;\n    this.clef = 'treble';\n    this.endClef = undefined;\n    this.font = {\n      family: 'sans-serif',\n      size: 8,\n      weight: ''\n    };\n    this.options = {\n      vertical_bar_width: 10,\n      // Width around vertical bar end-marker\n      glyph_spacing_px: 10,\n      num_lines: 5,\n      fill_style: '#999999',\n      left_bar: true,\n      // draw vertical bar on left\n      right_bar: true,\n      // draw vertical bar on right\n      spacing_between_lines_px: 10,\n      // in pixels\n      space_above_staff_ln: 4,\n      // in staff lines\n      space_below_staff_ln: 4,\n      // in staff lines\n      top_text_position: 1 // in staff lines\n\n    };\n    this.bounds = {\n      x: this.x,\n      y: this.y,\n      w: this.width,\n      h: 0\n    };\n    Vex.Merge(this.options, options);\n    this.resetLines();\n    const BARTYPE = Barline.type; // beg bar\n\n    this.addModifier(new Barline(this.options.left_bar ? BARTYPE.SINGLE : BARTYPE.NONE)); // end bar\n\n    this.addEndModifier(new Barline(this.options.right_bar ? BARTYPE.SINGLE : BARTYPE.NONE));\n  }\n\n  space(spacing) {\n    return this.options.spacing_between_lines_px * spacing;\n  }\n\n  resetLines() {\n    this.options.line_config = [];\n\n    for (let i = 0; i < this.options.num_lines; i++) {\n      this.options.line_config.push({\n        visible: true\n      });\n    }\n\n    this.height = (this.options.num_lines + this.options.space_above_staff_ln) * this.options.spacing_between_lines_px;\n    this.options.bottom_text_position = this.options.num_lines;\n  }\n\n  getOptions() {\n    return this.options;\n  }\n\n  setNoteStartX(x) {\n    if (!this.formatted) this.format();\n    this.start_x = x;\n    const begBarline = this.modifiers[0];\n    begBarline.setX(this.start_x - begBarline.getWidth());\n    return this;\n  }\n\n  getNoteStartX() {\n    if (!this.formatted) this.format();\n    return this.start_x;\n  }\n\n  getNoteEndX() {\n    if (!this.formatted) this.format();\n    return this.end_x;\n  }\n\n  getTieStartX() {\n    return this.start_x;\n  }\n\n  getTieEndX() {\n    return this.x + this.width;\n  }\n\n  getX() {\n    return this.x;\n  }\n\n  getNumLines() {\n    return this.options.num_lines;\n  }\n\n  setNumLines(lines) {\n    this.options.num_lines = parseInt(lines, 10);\n    this.resetLines();\n    return this;\n  }\n\n  setY(y) {\n    this.y = y;\n    return this;\n  }\n\n  getTopLineTopY() {\n    return this.getYForLine(0) - Flow.STAVE_LINE_THICKNESS / 2;\n  }\n\n  getBottomLineBottomY() {\n    return this.getYForLine(this.getNumLines() - 1) + Flow.STAVE_LINE_THICKNESS / 2;\n  }\n\n  setX(x) {\n    const shift = x - this.x;\n    this.formatted = false;\n    this.x = x;\n    this.start_x += shift;\n    this.end_x += shift;\n\n    for (let i = 0; i < this.modifiers.length; i++) {\n      const mod = this.modifiers[i];\n\n      if (mod.x !== undefined) {\n        mod.x += shift;\n      }\n    }\n\n    return this;\n  }\n\n  setWidth(width) {\n    this.formatted = false;\n    this.width = width;\n    this.end_x = this.x + width; // reset the x position of the end barline (TODO(0xfe): This makes no sense)\n    // this.modifiers[1].setX(this.end_x);\n\n    return this;\n  }\n\n  getWidth() {\n    return this.width;\n  }\n\n  getStyle() {\n    return {\n      fillStyle: this.options.fill_style,\n      strokeStyle: this.options.fill_style,\n      // yes, this is correct for legacy compatibility\n      lineWidth: Flow.STAVE_LINE_THICKNESS,\n      ...(this.style || {})\n    };\n  }\n\n  setMeasure(measure) {\n    this.measure = measure;\n    return this;\n  }\n  /**\n   * Gets the pixels to shift from the beginning of the stave\n   * following the modifier at the provided index\n   * @param  {Number} index The index from which to determine the shift\n   * @return {Number}       The amount of pixels shifted\n   */\n\n\n  getModifierXShift(index = 0) {\n    if (typeof index !== 'number') {\n      throw new Vex.RERR('InvalidIndex', 'Must be of number type');\n    }\n\n    if (!this.formatted) this.format();\n\n    if (this.getModifiers(StaveModifier.Position.BEGIN).length === 1) {\n      return 0;\n    }\n\n    let start_x = this.start_x - this.x;\n    const begBarline = this.modifiers[0];\n\n    if (begBarline.getType() === Barline.type.REPEAT_BEGIN && start_x > begBarline.getWidth()) {\n      start_x -= begBarline.getWidth();\n    }\n\n    return start_x;\n  } // Coda & Segno Symbol functions\n\n\n  setRepetitionTypeLeft(type, y) {\n    this.modifiers.push(new Repetition(type, this.x, y));\n    return this;\n  }\n\n  setRepetitionTypeRight(type, y) {\n    this.modifiers.push(new Repetition(type, this.x, y));\n    return this;\n  } // Volta functions\n\n\n  setVoltaType(type, number_t, y) {\n    this.modifiers.push(new Volta(type, number_t, this.x, y));\n    return this;\n  } // Section functions\n\n\n  setSection(section, y) {\n    this.modifiers.push(new StaveSection(section, this.x, y));\n    return this;\n  } // Tempo functions\n\n\n  setTempo(tempo, y) {\n    this.modifiers.push(new StaveTempo(tempo, this.x, y));\n    return this;\n  } // Text functions\n\n\n  setText(text, position, options) {\n    this.modifiers.push(new StaveText(text, position, options));\n    return this;\n  }\n\n  getHeight() {\n    return this.height;\n  }\n\n  getSpacingBetweenLines() {\n    return this.options.spacing_between_lines_px;\n  }\n\n  getBoundingBox() {\n    return new BoundingBox(this.x, this.y, this.width, this.getBottomY() - this.y);\n  }\n\n  getBottomY() {\n    const options = this.options;\n    const spacing = options.spacing_between_lines_px;\n    const score_bottom = this.getYForLine(options.num_lines) + options.space_below_staff_ln * spacing;\n    return score_bottom;\n  }\n\n  getBottomLineY() {\n    return this.getYForLine(this.options.num_lines);\n  } // This returns the y for the *center* of a staff line\n\n\n  getYForLine(line) {\n    const options = this.options;\n    const spacing = options.spacing_between_lines_px;\n    const headroom = options.space_above_staff_ln;\n    const y = this.y + line * spacing + headroom * spacing;\n    return y;\n  }\n\n  getLineForY(y) {\n    // Does the reverse of getYForLine - somewhat dumb and just calls\n    // getYForLine until the right value is reaches\n    const options = this.options;\n    const spacing = options.spacing_between_lines_px;\n    const headroom = options.space_above_staff_ln;\n    return (y - this.y) / spacing - headroom;\n  }\n\n  getYForTopText(line) {\n    const l = line || 0;\n    return this.getYForLine(-l - this.options.top_text_position);\n  }\n\n  getYForBottomText(line) {\n    const l = line || 0;\n    return this.getYForLine(this.options.bottom_text_position + l);\n  }\n\n  getYForNote(line) {\n    const options = this.options;\n    const spacing = options.spacing_between_lines_px;\n    const headroom = options.space_above_staff_ln;\n    const y = this.y + headroom * spacing + 5 * spacing - line * spacing;\n    return y;\n  }\n\n  getYForGlyphs() {\n    return this.getYForLine(3);\n  } // This method adds a stave modifier to the stave. Note that the first two\n  // modifiers (BarLines) are automatically added upon construction.\n\n\n  addModifier(modifier, position) {\n    if (position !== undefined) {\n      modifier.setPosition(position);\n    }\n\n    modifier.setStave(this);\n    this.formatted = false;\n    this.modifiers.push(modifier);\n    return this;\n  }\n\n  addEndModifier(modifier) {\n    this.addModifier(modifier, StaveModifier.Position.END);\n    return this;\n  } // Bar Line functions\n\n\n  setBegBarType(type) {\n    // Only valid bar types at beginning of stave is none, single or begin repeat\n    const {\n      SINGLE,\n      REPEAT_BEGIN,\n      NONE\n    } = Barline.type;\n\n    if (type === SINGLE || type === REPEAT_BEGIN || type === NONE) {\n      this.modifiers[0].setType(type);\n      this.formatted = false;\n    }\n\n    return this;\n  }\n\n  setEndBarType(type) {\n    // Repeat end not valid at end of stave\n    if (type !== Barline.type.REPEAT_BEGIN) {\n      this.modifiers[1].setType(type);\n      this.formatted = false;\n    }\n\n    return this;\n  }\n\n  setClef(clefSpec, size, annotation, position) {\n    if (position === undefined) {\n      position = StaveModifier.Position.BEGIN;\n    }\n\n    if (position === StaveModifier.Position.END) {\n      this.endClef = clefSpec;\n    } else {\n      this.clef = clefSpec;\n    }\n\n    const clefs = this.getModifiers(position, Clef.CATEGORY);\n\n    if (clefs.length === 0) {\n      this.addClef(clefSpec, size, annotation, position);\n    } else {\n      clefs[0].setType(clefSpec, size, annotation);\n    }\n\n    return this;\n  }\n\n  setEndClef(clefSpec, size, annotation) {\n    this.setClef(clefSpec, size, annotation, StaveModifier.Position.END);\n    return this;\n  }\n\n  setKeySignature(keySpec, cancelKeySpec, position) {\n    if (position === undefined) {\n      position = StaveModifier.Position.BEGIN;\n    }\n\n    const keySignatures = this.getModifiers(position, KeySignature.CATEGORY);\n\n    if (keySignatures.length === 0) {\n      this.addKeySignature(keySpec, cancelKeySpec, position);\n    } else {\n      keySignatures[0].setKeySig(keySpec, cancelKeySpec);\n    }\n\n    return this;\n  }\n\n  setEndKeySignature(keySpec, cancelKeySpec) {\n    this.setKeySignature(keySpec, cancelKeySpec, StaveModifier.Position.END);\n    return this;\n  }\n\n  setTimeSignature(timeSpec, customPadding, position) {\n    if (position === undefined) {\n      position = StaveModifier.Position.BEGIN;\n    }\n\n    const timeSignatures = this.getModifiers(position, TimeSignature.CATEGORY);\n\n    if (timeSignatures.length === 0) {\n      this.addTimeSignature(timeSpec, customPadding, position);\n    } else {\n      timeSignatures[0].setTimeSig(timeSpec);\n    }\n\n    return this;\n  }\n\n  setEndTimeSignature(timeSpec, customPadding) {\n    this.setTimeSignature(timeSpec, customPadding, StaveModifier.Position.END);\n    return this;\n  }\n\n  addKeySignature(keySpec, cancelKeySpec, position) {\n    if (position === undefined) {\n      position = StaveModifier.Position.BEGIN;\n    }\n\n    this.addModifier(new KeySignature(keySpec, cancelKeySpec).setPosition(position), position);\n    return this;\n  }\n\n  addClef(clef, size, annotation, position) {\n    if (position === undefined || position === StaveModifier.Position.BEGIN) {\n      this.clef = clef;\n    } else if (position === StaveModifier.Position.END) {\n      this.endClef = clef;\n    }\n\n    this.addModifier(new Clef(clef, size, annotation), position);\n    return this;\n  }\n\n  addEndClef(clef, size, annotation) {\n    this.addClef(clef, size, annotation, StaveModifier.Position.END);\n    return this;\n  }\n\n  addTimeSignature(timeSpec, customPadding, position) {\n    this.addModifier(new TimeSignature(timeSpec, customPadding), position);\n    return this;\n  }\n\n  addEndTimeSignature(timeSpec, customPadding) {\n    this.addTimeSignature(timeSpec, customPadding, StaveModifier.Position.END);\n    return this;\n  } // Deprecated\n\n\n  addTrebleGlyph() {\n    this.addClef('treble');\n    return this;\n  }\n\n  getModifiers(position, category) {\n    if (position === undefined && category === undefined) return this.modifiers;\n    return this.modifiers.filter(modifier => (position === undefined || position === modifier.getPosition()) && (category === undefined || category === modifier.getCategory()));\n  }\n\n  sortByCategory(items, order) {\n    for (let i = items.length - 1; i >= 0; i--) {\n      for (let j = 0; j < i; j++) {\n        if (order[items[j].getCategory()] > order[items[j + 1].getCategory()]) {\n          const temp = items[j];\n          items[j] = items[j + 1];\n          items[j + 1] = temp;\n        }\n      }\n    }\n  }\n\n  format() {\n    const begBarline = this.modifiers[0];\n    const endBarline = this.modifiers[1];\n    const begModifiers = this.getModifiers(StaveModifier.Position.BEGIN);\n    const endModifiers = this.getModifiers(StaveModifier.Position.END);\n    this.sortByCategory(begModifiers, {\n      barlines: 0,\n      clefs: 1,\n      keysignatures: 2,\n      timesignatures: 3\n    });\n    this.sortByCategory(endModifiers, {\n      timesignatures: 0,\n      keysignatures: 1,\n      barlines: 2,\n      clefs: 3\n    });\n\n    if (begModifiers.length > 1 && begBarline.getType() === Barline.type.REPEAT_BEGIN) {\n      begModifiers.push(begModifiers.splice(0, 1)[0]);\n      begModifiers.splice(0, 0, new Barline(Barline.type.SINGLE));\n    }\n\n    if (endModifiers.indexOf(endBarline) > 0) {\n      endModifiers.splice(0, 0, new Barline(Barline.type.NONE));\n    }\n\n    let width;\n    let padding;\n    let modifier;\n    let offset = 0;\n    let x = this.x;\n\n    for (let i = 0; i < begModifiers.length; i++) {\n      modifier = begModifiers[i];\n      padding = modifier.getPadding(i + offset);\n      width = modifier.getWidth();\n      x += padding;\n      modifier.setX(x);\n      x += width;\n      if (padding + width === 0) offset--;\n    }\n\n    this.start_x = x;\n    x = this.x + this.width;\n    const widths = {\n      left: 0,\n      right: 0,\n      paddingRight: 0,\n      paddingLeft: 0\n    };\n    let lastBarlineIdx = 0;\n\n    for (let i = 0; i < endModifiers.length; i++) {\n      modifier = endModifiers[i];\n      lastBarlineIdx = modifier.getCategory() === 'barlines' ? i : lastBarlineIdx;\n      widths.right = 0;\n      widths.left = 0;\n      widths.paddingRight = 0;\n      widths.paddingLeft = 0;\n      const layoutMetrics = modifier.getLayoutMetrics();\n\n      if (layoutMetrics) {\n        if (i !== 0) {\n          widths.right = layoutMetrics.xMax || 0;\n          widths.paddingRight = layoutMetrics.paddingRight || 0;\n        }\n\n        widths.left = -layoutMetrics.xMin || 0;\n        widths.paddingLeft = layoutMetrics.paddingLeft || 0;\n\n        if (i === endModifiers.length - 1) {\n          widths.paddingLeft = 0;\n        }\n      } else {\n        widths.paddingRight = modifier.getPadding(i - lastBarlineIdx);\n\n        if (i !== 0) {\n          widths.right = modifier.getWidth();\n        }\n\n        if (i === 0) {\n          widths.left = modifier.getWidth();\n        }\n      }\n\n      x -= widths.paddingRight;\n      x -= widths.right;\n      modifier.setX(x);\n      x -= widths.left;\n      x -= widths.paddingLeft;\n    }\n\n    this.end_x = endModifiers.length === 1 ? this.x + this.width : x;\n    this.formatted = true;\n  }\n  /**\n   * All drawing functions below need the context to be set.\n   */\n\n\n  draw() {\n    this.checkContext();\n    this.setRendered();\n    if (!this.formatted) this.format();\n    const num_lines = this.options.num_lines;\n    const width = this.width;\n    const x = this.x;\n    let y; // Render lines\n\n    for (let line = 0; line < num_lines; line++) {\n      y = this.getYForLine(line);\n      this.applyStyle();\n\n      if (this.options.line_config[line].visible) {\n        this.context.beginPath();\n        this.context.moveTo(x, y);\n        this.context.lineTo(x + width, y);\n        this.context.stroke();\n      }\n\n      this.restoreStyle();\n    } // Draw the modifiers (bar lines, coda, segno, repeat brackets, etc.)\n\n\n    for (let i = 0; i < this.modifiers.length; i++) {\n      // Only draw modifier if it has a draw function\n      if (typeof this.modifiers[i].draw === 'function') {\n        this.modifiers[i].applyStyle(this.context);\n        this.modifiers[i].draw(this, this.getModifierXShift(i));\n        this.modifiers[i].restoreStyle(this.context);\n      }\n    } // Render measure numbers\n\n\n    if (this.measure > 0) {\n      this.context.save();\n      this.context.setFont(this.font.family, this.font.size, this.font.weight);\n      const text_width = this.context.measureText('' + this.measure).width;\n      y = this.getYForTopText(0) + 3;\n      this.context.fillText('' + this.measure, this.x - text_width / 2, y);\n      this.context.restore();\n    }\n\n    return this;\n  } // Draw Simple barlines for backward compatability\n  // Do not delete - draws the beginning bar of the stave\n\n\n  drawVertical(x, isDouble) {\n    this.drawVerticalFixed(this.x + x, isDouble);\n  }\n\n  drawVerticalFixed(x, isDouble) {\n    this.checkContext();\n    const top_line = this.getYForLine(0);\n    const bottom_line = this.getYForLine(this.options.num_lines - 1);\n\n    if (isDouble) {\n      this.context.fillRect(x - 3, top_line, 1, bottom_line - top_line + 1);\n    }\n\n    this.context.fillRect(x, top_line, 1, bottom_line - top_line + 1);\n  }\n\n  drawVerticalBar(x) {\n    this.drawVerticalBarFixed(this.x + x, false);\n  }\n\n  drawVerticalBarFixed(x) {\n    this.checkContext();\n    const top_line = this.getYForLine(0);\n    const bottom_line = this.getYForLine(this.options.num_lines - 1);\n    this.context.fillRect(x, top_line, 1, bottom_line - top_line + 1);\n  }\n  /**\n   * Get the current configuration for the Stave.\n   * @return {Array} An array of configuration objects.\n   */\n\n\n  getConfigForLines() {\n    return this.options.line_config;\n  }\n  /**\n   * Configure properties of the lines in the Stave\n   * @param line_number The index of the line to configure.\n   * @param line_config An configuration object for the specified line.\n   * @throws Vex.RERR \"StaveConfigError\" When the specified line number is out of\n   *   range of the number of lines specified in the constructor.\n   */\n\n\n  setConfigForLine(line_number, line_config) {\n    if (line_number >= this.options.num_lines || line_number < 0) {\n      throw new Vex.RERR('StaveConfigError', 'The line number must be within the range of the number of lines in the Stave.');\n    }\n\n    if (line_config.visible === undefined) {\n      throw new Vex.RERR('StaveConfigError', \"The line configuration object is missing the 'visible' property.\");\n    }\n\n    if (typeof line_config.visible !== 'boolean') {\n      throw new Vex.RERR('StaveConfigError', \"The line configuration objects 'visible' property must be true or false.\");\n    }\n\n    this.options.line_config[line_number] = line_config;\n    return this;\n  }\n  /**\n   * Set the staff line configuration array for all of the lines at once.\n   * @param lines_configuration An array of line configuration objects.  These objects\n   *   are of the same format as the single one passed in to setLineConfiguration().\n   *   The caller can set null for any line config entry if it is desired that the default be used\n   * @throws Vex.RERR \"StaveConfigError\" When the lines_configuration array does not have\n   *   exactly the same number of elements as the num_lines configuration object set in\n   *   the constructor.\n   */\n\n\n  setConfigForLines(lines_configuration) {\n    if (lines_configuration.length !== this.options.num_lines) {\n      throw new Vex.RERR('StaveConfigError', 'The length of the lines configuration array must match the number of lines in the Stave');\n    } // Make sure the defaults are present in case an incomplete set of\n    //  configuration options were supplied.\n    // eslint-disable-next-line\n\n\n    for (const line_config in lines_configuration) {\n      // Allow 'null' to be used if the caller just wants the default for a particular node.\n      if (!lines_configuration[line_config]) {\n        lines_configuration[line_config] = this.options.line_config[line_config];\n      }\n\n      Vex.Merge(this.options.line_config[line_config], lines_configuration[line_config]);\n    }\n\n    this.options.line_config = lines_configuration;\n    return this;\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/stave.js"],"names":["Vex","Element","Flow","Barline","StaveModifier","Repetition","StaveSection","StaveTempo","StaveText","BoundingBox","Clef","KeySignature","TimeSignature","Volta","Stave","constructor","x","y","width","options","setAttribute","formatted","start_x","end_x","modifiers","measure","clef","endClef","undefined","font","family","size","weight","vertical_bar_width","glyph_spacing_px","num_lines","fill_style","left_bar","right_bar","spacing_between_lines_px","space_above_staff_ln","space_below_staff_ln","top_text_position","bounds","w","h","Merge","resetLines","BARTYPE","type","addModifier","SINGLE","NONE","addEndModifier","space","spacing","line_config","i","push","visible","height","bottom_text_position","getOptions","setNoteStartX","format","begBarline","setX","getWidth","getNoteStartX","getNoteEndX","getTieStartX","getTieEndX","getX","getNumLines","setNumLines","lines","parseInt","setY","getTopLineTopY","getYForLine","STAVE_LINE_THICKNESS","getBottomLineBottomY","shift","length","mod","setWidth","getStyle","fillStyle","strokeStyle","lineWidth","style","setMeasure","getModifierXShift","index","RERR","getModifiers","Position","BEGIN","getType","REPEAT_BEGIN","setRepetitionTypeLeft","setRepetitionTypeRight","setVoltaType","number_t","setSection","section","setTempo","tempo","setText","text","position","getHeight","getSpacingBetweenLines","getBoundingBox","getBottomY","score_bottom","getBottomLineY","line","headroom","getLineForY","getYForTopText","l","getYForBottomText","getYForNote","getYForGlyphs","modifier","setPosition","setStave","END","setBegBarType","setType","setEndBarType","setClef","clefSpec","annotation","clefs","CATEGORY","addClef","setEndClef","setKeySignature","keySpec","cancelKeySpec","keySignatures","addKeySignature","setKeySig","setEndKeySignature","setTimeSignature","timeSpec","customPadding","timeSignatures","addTimeSignature","setTimeSig","setEndTimeSignature","addEndClef","addEndTimeSignature","addTrebleGlyph","category","filter","getPosition","getCategory","sortByCategory","items","order","j","temp","endBarline","begModifiers","endModifiers","barlines","keysignatures","timesignatures","splice","indexOf","padding","offset","getPadding","widths","left","right","paddingRight","paddingLeft","lastBarlineIdx","layoutMetrics","getLayoutMetrics","xMax","xMin","draw","checkContext","setRendered","applyStyle","context","beginPath","moveTo","lineTo","stroke","restoreStyle","save","setFont","text_width","measureText","fillText","restore","drawVertical","isDouble","drawVerticalFixed","top_line","bottom_line","fillRect","drawVerticalBar","drawVerticalBarFixed","getConfigForLines","setConfigForLine","line_number","setConfigForLines","lines_configuration"],"mappings":"AAAA;AAEA,SAASA,GAAT,QAAoB,OAApB;AACA,SAASC,OAAT,QAAwB,WAAxB;AACA,SAASC,IAAT,QAAqB,UAArB;AACA,SAASC,OAAT,QAAwB,gBAAxB;AACA,SAASC,aAAT,QAA8B,iBAA9B;AACA,SAASC,UAAT,QAA2B,mBAA3B;AACA,SAASC,YAAT,QAA6B,gBAA7B;AACA,SAASC,UAAT,QAA2B,cAA3B;AACA,SAASC,SAAT,QAA0B,aAA1B;AACA,SAASC,WAAT,QAA4B,eAA5B;AACA,SAASC,IAAT,QAAqB,QAArB;AACA,SAASC,YAAT,QAA6B,gBAA7B;AACA,SAASC,aAAT,QAA8B,iBAA9B;AACA,SAASC,KAAT,QAAsB,cAAtB;AAEA,OAAO,MAAMC,KAAN,SAAoBb,OAApB,CAA4B;AACjCc,EAAAA,WAAW,CAACC,CAAD,EAAIC,CAAJ,EAAOC,KAAP,EAAcC,OAAd,EAAuB;AAChC;AACA,SAAKC,YAAL,CAAkB,MAAlB,EAA0B,OAA1B;AAEA,SAAKJ,CAAL,GAASA,CAAT;AACA,SAAKC,CAAL,GAASA,CAAT;AACA,SAAKC,KAAL,GAAaA,KAAb;AACA,SAAKG,SAAL,GAAiB,KAAjB;AACA,SAAKC,OAAL,GAAeN,CAAC,GAAG,CAAnB;AACA,SAAKO,KAAL,GAAaP,CAAC,GAAGE,KAAjB;AACA,SAAKM,SAAL,GAAiB,EAAjB,CAVgC,CAUV;;AACtB,SAAKC,OAAL,GAAe,CAAf;AACA,SAAKC,IAAL,GAAY,QAAZ;AACA,SAAKC,OAAL,GAAeC,SAAf;AACA,SAAKC,IAAL,GAAY;AACVC,MAAAA,MAAM,EAAE,YADE;AAEVC,MAAAA,IAAI,EAAE,CAFI;AAGVC,MAAAA,MAAM,EAAE;AAHE,KAAZ;AAKA,SAAKb,OAAL,GAAe;AACbc,MAAAA,kBAAkB,EAAE,EADP;AACiB;AAC9BC,MAAAA,gBAAgB,EAAE,EAFL;AAGbC,MAAAA,SAAS,EAAE,CAHE;AAIbC,MAAAA,UAAU,EAAE,SAJC;AAKbC,MAAAA,QAAQ,EAAE,IALG;AAKiB;AAC9BC,MAAAA,SAAS,EAAE,IANE;AAMkB;AAC/BC,MAAAA,wBAAwB,EAAE,EAPb;AAOiB;AAC9BC,MAAAA,oBAAoB,EAAE,CART;AAQiB;AAC9BC,MAAAA,oBAAoB,EAAE,CATT;AASiB;AAC9BC,MAAAA,iBAAiB,EAAE,CAVN,CAUkB;;AAVlB,KAAf;AAYA,SAAKC,MAAL,GAAc;AAAE3B,MAAAA,CAAC,EAAE,KAAKA,CAAV;AAAaC,MAAAA,CAAC,EAAE,KAAKA,CAArB;AAAwB2B,MAAAA,CAAC,EAAE,KAAK1B,KAAhC;AAAuC2B,MAAAA,CAAC,EAAE;AAA1C,KAAd;AACA7C,IAAAA,GAAG,CAAC8C,KAAJ,CAAU,KAAK3B,OAAf,EAAwBA,OAAxB;AAEA,SAAK4B,UAAL;AAEA,UAAMC,OAAO,GAAG7C,OAAO,CAAC8C,IAAxB,CApCgC,CAqChC;;AACA,SAAKC,WAAL,CAAiB,IAAI/C,OAAJ,CAAY,KAAKgB,OAAL,CAAakB,QAAb,GAAwBW,OAAO,CAACG,MAAhC,GAAyCH,OAAO,CAACI,IAA7D,CAAjB,EAtCgC,CAuChC;;AACA,SAAKC,cAAL,CAAoB,IAAIlD,OAAJ,CAAY,KAAKgB,OAAL,CAAamB,SAAb,GAAyBU,OAAO,CAACG,MAAjC,GAA0CH,OAAO,CAACI,IAA9D,CAApB;AACD;;AAEDE,EAAAA,KAAK,CAACC,OAAD,EAAU;AAAE,WAAO,KAAKpC,OAAL,CAAaoB,wBAAb,GAAwCgB,OAA/C;AAAyD;;AAE1ER,EAAAA,UAAU,GAAG;AACX,SAAK5B,OAAL,CAAaqC,WAAb,GAA2B,EAA3B;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKtC,OAAL,CAAagB,SAAjC,EAA4CsB,CAAC,EAA7C,EAAiD;AAC/C,WAAKtC,OAAL,CAAaqC,WAAb,CAAyBE,IAAzB,CAA8B;AAAEC,QAAAA,OAAO,EAAE;AAAX,OAA9B;AACD;;AACD,SAAKC,MAAL,GAAc,CAAC,KAAKzC,OAAL,CAAagB,SAAb,GAAyB,KAAKhB,OAAL,CAAaqB,oBAAvC,IACZ,KAAKrB,OAAL,CAAaoB,wBADf;AAEA,SAAKpB,OAAL,CAAa0C,oBAAb,GAAoC,KAAK1C,OAAL,CAAagB,SAAjD;AACD;;AAED2B,EAAAA,UAAU,GAAG;AAAE,WAAO,KAAK3C,OAAZ;AAAsB;;AAErC4C,EAAAA,aAAa,CAAC/C,CAAD,EAAI;AACf,QAAI,CAAC,KAAKK,SAAV,EAAqB,KAAK2C,MAAL;AAErB,SAAK1C,OAAL,GAAeN,CAAf;AACA,UAAMiD,UAAU,GAAG,KAAKzC,SAAL,CAAe,CAAf,CAAnB;AACAyC,IAAAA,UAAU,CAACC,IAAX,CAAgB,KAAK5C,OAAL,GAAe2C,UAAU,CAACE,QAAX,EAA/B;AACA,WAAO,IAAP;AACD;;AACDC,EAAAA,aAAa,GAAG;AACd,QAAI,CAAC,KAAK/C,SAAV,EAAqB,KAAK2C,MAAL;AAErB,WAAO,KAAK1C,OAAZ;AACD;;AAED+C,EAAAA,WAAW,GAAG;AACZ,QAAI,CAAC,KAAKhD,SAAV,EAAqB,KAAK2C,MAAL;AAErB,WAAO,KAAKzC,KAAZ;AACD;;AACD+C,EAAAA,YAAY,GAAG;AAAE,WAAO,KAAKhD,OAAZ;AAAsB;;AACvCiD,EAAAA,UAAU,GAAG;AAAE,WAAO,KAAKvD,CAAL,GAAS,KAAKE,KAArB;AAA6B;;AAC5CsD,EAAAA,IAAI,GAAG;AAAE,WAAO,KAAKxD,CAAZ;AAAgB;;AACzByD,EAAAA,WAAW,GAAG;AAAE,WAAO,KAAKtD,OAAL,CAAagB,SAApB;AAAgC;;AAChDuC,EAAAA,WAAW,CAACC,KAAD,EAAQ;AACjB,SAAKxD,OAAL,CAAagB,SAAb,GAAyByC,QAAQ,CAACD,KAAD,EAAQ,EAAR,CAAjC;AACA,SAAK5B,UAAL;AACA,WAAO,IAAP;AACD;;AACD8B,EAAAA,IAAI,CAAC5D,CAAD,EAAI;AAAE,SAAKA,CAAL,GAASA,CAAT;AAAY,WAAO,IAAP;AAAc;;AAEpC6D,EAAAA,cAAc,GAAG;AACf,WAAO,KAAKC,WAAL,CAAiB,CAAjB,IAAuB7E,IAAI,CAAC8E,oBAAL,GAA4B,CAA1D;AACD;;AACDC,EAAAA,oBAAoB,GAAG;AACrB,WAAO,KAAKF,WAAL,CAAiB,KAAKN,WAAL,KAAqB,CAAtC,IAA4CvE,IAAI,CAAC8E,oBAAL,GAA4B,CAA/E;AACD;;AAEDd,EAAAA,IAAI,CAAClD,CAAD,EAAI;AACN,UAAMkE,KAAK,GAAGlE,CAAC,GAAG,KAAKA,CAAvB;AACA,SAAKK,SAAL,GAAiB,KAAjB;AACA,SAAKL,CAAL,GAASA,CAAT;AACA,SAAKM,OAAL,IAAgB4D,KAAhB;AACA,SAAK3D,KAAL,IAAc2D,KAAd;;AACA,SAAK,IAAIzB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKjC,SAAL,CAAe2D,MAAnC,EAA2C1B,CAAC,EAA5C,EAAgD;AAC9C,YAAM2B,GAAG,GAAG,KAAK5D,SAAL,CAAeiC,CAAf,CAAZ;;AACA,UAAI2B,GAAG,CAACpE,CAAJ,KAAUY,SAAd,EAAyB;AACvBwD,QAAAA,GAAG,CAACpE,CAAJ,IAASkE,KAAT;AACD;AACF;;AACD,WAAO,IAAP;AACD;;AAEDG,EAAAA,QAAQ,CAACnE,KAAD,EAAQ;AACd,SAAKG,SAAL,GAAiB,KAAjB;AACA,SAAKH,KAAL,GAAaA,KAAb;AACA,SAAKK,KAAL,GAAa,KAAKP,CAAL,GAASE,KAAtB,CAHc,CAKd;AACA;;AACA,WAAO,IAAP;AACD;;AAEDiD,EAAAA,QAAQ,GAAG;AACT,WAAO,KAAKjD,KAAZ;AACD;;AAEDoE,EAAAA,QAAQ,GAAG;AACT,WAAO;AACLC,MAAAA,SAAS,EAAE,KAAKpE,OAAL,CAAaiB,UADnB;AAELoD,MAAAA,WAAW,EAAE,KAAKrE,OAAL,CAAaiB,UAFrB;AAEiC;AACtCqD,MAAAA,SAAS,EAAEvF,IAAI,CAAC8E,oBAHX;AAGiC,UAAG,KAAKU,KAAL,IAAc,EAAjB;AAHjC,KAAP;AAKD;;AAEDC,EAAAA,UAAU,CAAClE,OAAD,EAAU;AAAE,SAAKA,OAAL,GAAeA,OAAf;AAAwB,WAAO,IAAP;AAAc;AAE5D;;;;;;;;AAMAmE,EAAAA,iBAAiB,CAACC,KAAK,GAAG,CAAT,EAAY;AAC3B,QAAI,OAAOA,KAAP,KAAiB,QAArB,EAA+B;AAC7B,YAAM,IAAI7F,GAAG,CAAC8F,IAAR,CAAa,cAAb,EAA6B,wBAA7B,CAAN;AACD;;AAED,QAAI,CAAC,KAAKzE,SAAV,EAAqB,KAAK2C,MAAL;;AAErB,QAAI,KAAK+B,YAAL,CAAkB3F,aAAa,CAAC4F,QAAd,CAAuBC,KAAzC,EAAgDd,MAAhD,KAA2D,CAA/D,EAAkE;AAChE,aAAO,CAAP;AACD;;AAED,QAAI7D,OAAO,GAAG,KAAKA,OAAL,GAAe,KAAKN,CAAlC;AACA,UAAMiD,UAAU,GAAG,KAAKzC,SAAL,CAAe,CAAf,CAAnB;;AACA,QAAIyC,UAAU,CAACiC,OAAX,OAAyB/F,OAAO,CAAC8C,IAAR,CAAakD,YAAtC,IAAsD7E,OAAO,GAAG2C,UAAU,CAACE,QAAX,EAApE,EAA2F;AACzF7C,MAAAA,OAAO,IAAI2C,UAAU,CAACE,QAAX,EAAX;AACD;;AAED,WAAO7C,OAAP;AACD,GA9JgC,CAgKjC;;;AACA8E,EAAAA,qBAAqB,CAACnD,IAAD,EAAOhC,CAAP,EAAU;AAC7B,SAAKO,SAAL,CAAekC,IAAf,CAAoB,IAAIrD,UAAJ,CAAe4C,IAAf,EAAqB,KAAKjC,CAA1B,EAA6BC,CAA7B,CAApB;AACA,WAAO,IAAP;AACD;;AAEDoF,EAAAA,sBAAsB,CAACpD,IAAD,EAAOhC,CAAP,EAAU;AAC9B,SAAKO,SAAL,CAAekC,IAAf,CAAoB,IAAIrD,UAAJ,CAAe4C,IAAf,EAAqB,KAAKjC,CAA1B,EAA6BC,CAA7B,CAApB;AACA,WAAO,IAAP;AACD,GAzKgC,CA2KjC;;;AACAqF,EAAAA,YAAY,CAACrD,IAAD,EAAOsD,QAAP,EAAiBtF,CAAjB,EAAoB;AAC9B,SAAKO,SAAL,CAAekC,IAAf,CAAoB,IAAI7C,KAAJ,CAAUoC,IAAV,EAAgBsD,QAAhB,EAA0B,KAAKvF,CAA/B,EAAkCC,CAAlC,CAApB;AACA,WAAO,IAAP;AACD,GA/KgC,CAiLjC;;;AACAuF,EAAAA,UAAU,CAACC,OAAD,EAAUxF,CAAV,EAAa;AACrB,SAAKO,SAAL,CAAekC,IAAf,CAAoB,IAAIpD,YAAJ,CAAiBmG,OAAjB,EAA0B,KAAKzF,CAA/B,EAAkCC,CAAlC,CAApB;AACA,WAAO,IAAP;AACD,GArLgC,CAuLjC;;;AACAyF,EAAAA,QAAQ,CAACC,KAAD,EAAQ1F,CAAR,EAAW;AACjB,SAAKO,SAAL,CAAekC,IAAf,CAAoB,IAAInD,UAAJ,CAAeoG,KAAf,EAAsB,KAAK3F,CAA3B,EAA8BC,CAA9B,CAApB;AACA,WAAO,IAAP;AACD,GA3LgC,CA6LjC;;;AACA2F,EAAAA,OAAO,CAACC,IAAD,EAAOC,QAAP,EAAiB3F,OAAjB,EAA0B;AAC/B,SAAKK,SAAL,CAAekC,IAAf,CAAoB,IAAIlD,SAAJ,CAAcqG,IAAd,EAAoBC,QAApB,EAA8B3F,OAA9B,CAApB;AACA,WAAO,IAAP;AACD;;AAED4F,EAAAA,SAAS,GAAG;AACV,WAAO,KAAKnD,MAAZ;AACD;;AAEDoD,EAAAA,sBAAsB,GAAG;AACvB,WAAO,KAAK7F,OAAL,CAAaoB,wBAApB;AACD;;AAED0E,EAAAA,cAAc,GAAG;AACf,WAAO,IAAIxG,WAAJ,CAAgB,KAAKO,CAArB,EAAwB,KAAKC,CAA7B,EAAgC,KAAKC,KAArC,EAA4C,KAAKgG,UAAL,KAAoB,KAAKjG,CAArE,CAAP;AACD;;AAEDiG,EAAAA,UAAU,GAAG;AACX,UAAM/F,OAAO,GAAG,KAAKA,OAArB;AACA,UAAMoC,OAAO,GAAGpC,OAAO,CAACoB,wBAAxB;AACA,UAAM4E,YAAY,GAAG,KAAKpC,WAAL,CAAiB5D,OAAO,CAACgB,SAAzB,IAClBhB,OAAO,CAACsB,oBAAR,GAA+Bc,OADlC;AAGA,WAAO4D,YAAP;AACD;;AAEDC,EAAAA,cAAc,GAAG;AACf,WAAO,KAAKrC,WAAL,CAAiB,KAAK5D,OAAL,CAAagB,SAA9B,CAAP;AACD,GA1NgC,CA4NjC;;;AACA4C,EAAAA,WAAW,CAACsC,IAAD,EAAO;AAChB,UAAMlG,OAAO,GAAG,KAAKA,OAArB;AACA,UAAMoC,OAAO,GAAGpC,OAAO,CAACoB,wBAAxB;AACA,UAAM+E,QAAQ,GAAGnG,OAAO,CAACqB,oBAAzB;AAEA,UAAMvB,CAAC,GAAG,KAAKA,CAAL,GAAUoG,IAAI,GAAG9D,OAAjB,GAA6B+D,QAAQ,GAAG/D,OAAlD;AAEA,WAAOtC,CAAP;AACD;;AAEDsG,EAAAA,WAAW,CAACtG,CAAD,EAAI;AACb;AACA;AAEA,UAAME,OAAO,GAAG,KAAKA,OAArB;AACA,UAAMoC,OAAO,GAAGpC,OAAO,CAACoB,wBAAxB;AACA,UAAM+E,QAAQ,GAAGnG,OAAO,CAACqB,oBAAzB;AACA,WAAQ,CAACvB,CAAC,GAAG,KAAKA,CAAV,IAAesC,OAAhB,GAA2B+D,QAAlC;AACD;;AAEDE,EAAAA,cAAc,CAACH,IAAD,EAAO;AACnB,UAAMI,CAAC,GAAGJ,IAAI,IAAI,CAAlB;AACA,WAAO,KAAKtC,WAAL,CAAiB,CAAC0C,CAAD,GAAK,KAAKtG,OAAL,CAAauB,iBAAnC,CAAP;AACD;;AAEDgF,EAAAA,iBAAiB,CAACL,IAAD,EAAO;AACtB,UAAMI,CAAC,GAAGJ,IAAI,IAAI,CAAlB;AACA,WAAO,KAAKtC,WAAL,CAAiB,KAAK5D,OAAL,CAAa0C,oBAAb,GAAoC4D,CAArD,CAAP;AACD;;AAEDE,EAAAA,WAAW,CAACN,IAAD,EAAO;AAChB,UAAMlG,OAAO,GAAG,KAAKA,OAArB;AACA,UAAMoC,OAAO,GAAGpC,OAAO,CAACoB,wBAAxB;AACA,UAAM+E,QAAQ,GAAGnG,OAAO,CAACqB,oBAAzB;AACA,UAAMvB,CAAC,GAAG,KAAKA,CAAL,GAAUqG,QAAQ,GAAG/D,OAArB,GAAiC,IAAIA,OAArC,GAAiD8D,IAAI,GAAG9D,OAAlE;AAEA,WAAOtC,CAAP;AACD;;AAED2G,EAAAA,aAAa,GAAG;AACd,WAAO,KAAK7C,WAAL,CAAiB,CAAjB,CAAP;AACD,GAtQgC,CAwQjC;AACA;;;AACA7B,EAAAA,WAAW,CAAC2E,QAAD,EAAWf,QAAX,EAAqB;AAC9B,QAAIA,QAAQ,KAAKlF,SAAjB,EAA4B;AAC1BiG,MAAAA,QAAQ,CAACC,WAAT,CAAqBhB,QAArB;AACD;;AAEDe,IAAAA,QAAQ,CAACE,QAAT,CAAkB,IAAlB;AACA,SAAK1G,SAAL,GAAiB,KAAjB;AACA,SAAKG,SAAL,CAAekC,IAAf,CAAoBmE,QAApB;AACA,WAAO,IAAP;AACD;;AAEDxE,EAAAA,cAAc,CAACwE,QAAD,EAAW;AACvB,SAAK3E,WAAL,CAAiB2E,QAAjB,EAA2BzH,aAAa,CAAC4F,QAAd,CAAuBgC,GAAlD;AACA,WAAO,IAAP;AACD,GAxRgC,CA0RjC;;;AACAC,EAAAA,aAAa,CAAChF,IAAD,EAAO;AAClB;AACA,UAAM;AAAEE,MAAAA,MAAF;AAAUgD,MAAAA,YAAV;AAAwB/C,MAAAA;AAAxB,QAAiCjD,OAAO,CAAC8C,IAA/C;;AACA,QAAIA,IAAI,KAAKE,MAAT,IAAmBF,IAAI,KAAKkD,YAA5B,IAA4ClD,IAAI,KAAKG,IAAzD,EAA+D;AAC7D,WAAK5B,SAAL,CAAe,CAAf,EAAkB0G,OAAlB,CAA0BjF,IAA1B;AACA,WAAK5B,SAAL,GAAiB,KAAjB;AACD;;AACD,WAAO,IAAP;AACD;;AAED8G,EAAAA,aAAa,CAAClF,IAAD,EAAO;AAClB;AACA,QAAIA,IAAI,KAAK9C,OAAO,CAAC8C,IAAR,CAAakD,YAA1B,EAAwC;AACtC,WAAK3E,SAAL,CAAe,CAAf,EAAkB0G,OAAlB,CAA0BjF,IAA1B;AACA,WAAK5B,SAAL,GAAiB,KAAjB;AACD;;AACD,WAAO,IAAP;AACD;;AAED+G,EAAAA,OAAO,CAACC,QAAD,EAAWtG,IAAX,EAAiBuG,UAAjB,EAA6BxB,QAA7B,EAAuC;AAC5C,QAAIA,QAAQ,KAAKlF,SAAjB,EAA4B;AAC1BkF,MAAAA,QAAQ,GAAG1G,aAAa,CAAC4F,QAAd,CAAuBC,KAAlC;AACD;;AAED,QAAIa,QAAQ,KAAK1G,aAAa,CAAC4F,QAAd,CAAuBgC,GAAxC,EAA6C;AAC3C,WAAKrG,OAAL,GAAe0G,QAAf;AACD,KAFD,MAEO;AACL,WAAK3G,IAAL,GAAY2G,QAAZ;AACD;;AAED,UAAME,KAAK,GAAG,KAAKxC,YAAL,CAAkBe,QAAlB,EAA4BpG,IAAI,CAAC8H,QAAjC,CAAd;;AACA,QAAID,KAAK,CAACpD,MAAN,KAAiB,CAArB,EAAwB;AACtB,WAAKsD,OAAL,CAAaJ,QAAb,EAAuBtG,IAAvB,EAA6BuG,UAA7B,EAAyCxB,QAAzC;AACD,KAFD,MAEO;AACLyB,MAAAA,KAAK,CAAC,CAAD,CAAL,CAASL,OAAT,CAAiBG,QAAjB,EAA2BtG,IAA3B,EAAiCuG,UAAjC;AACD;;AAED,WAAO,IAAP;AACD;;AAEDI,EAAAA,UAAU,CAACL,QAAD,EAAWtG,IAAX,EAAiBuG,UAAjB,EAA6B;AACrC,SAAKF,OAAL,CAAaC,QAAb,EAAuBtG,IAAvB,EAA6BuG,UAA7B,EAAyClI,aAAa,CAAC4F,QAAd,CAAuBgC,GAAhE;AACA,WAAO,IAAP;AACD;;AAEDW,EAAAA,eAAe,CAACC,OAAD,EAAUC,aAAV,EAAyB/B,QAAzB,EAAmC;AAChD,QAAIA,QAAQ,KAAKlF,SAAjB,EAA4B;AAC1BkF,MAAAA,QAAQ,GAAG1G,aAAa,CAAC4F,QAAd,CAAuBC,KAAlC;AACD;;AAED,UAAM6C,aAAa,GAAG,KAAK/C,YAAL,CAAkBe,QAAlB,EAA4BnG,YAAY,CAAC6H,QAAzC,CAAtB;;AACA,QAAIM,aAAa,CAAC3D,MAAd,KAAyB,CAA7B,EAAgC;AAC9B,WAAK4D,eAAL,CAAqBH,OAArB,EAA8BC,aAA9B,EAA6C/B,QAA7C;AACD,KAFD,MAEO;AACLgC,MAAAA,aAAa,CAAC,CAAD,CAAb,CAAiBE,SAAjB,CAA2BJ,OAA3B,EAAoCC,aAApC;AACD;;AAED,WAAO,IAAP;AACD;;AAEDI,EAAAA,kBAAkB,CAACL,OAAD,EAAUC,aAAV,EAAyB;AACzC,SAAKF,eAAL,CAAqBC,OAArB,EAA8BC,aAA9B,EAA6CzI,aAAa,CAAC4F,QAAd,CAAuBgC,GAApE;AACA,WAAO,IAAP;AACD;;AAEDkB,EAAAA,gBAAgB,CAACC,QAAD,EAAWC,aAAX,EAA0BtC,QAA1B,EAAoC;AAClD,QAAIA,QAAQ,KAAKlF,SAAjB,EAA4B;AAC1BkF,MAAAA,QAAQ,GAAG1G,aAAa,CAAC4F,QAAd,CAAuBC,KAAlC;AACD;;AAED,UAAMoD,cAAc,GAAG,KAAKtD,YAAL,CAAkBe,QAAlB,EAA4BlG,aAAa,CAAC4H,QAA1C,CAAvB;;AACA,QAAIa,cAAc,CAAClE,MAAf,KAA0B,CAA9B,EAAiC;AAC/B,WAAKmE,gBAAL,CAAsBH,QAAtB,EAAgCC,aAAhC,EAA+CtC,QAA/C;AACD,KAFD,MAEO;AACLuC,MAAAA,cAAc,CAAC,CAAD,CAAd,CAAkBE,UAAlB,CAA6BJ,QAA7B;AACD;;AAED,WAAO,IAAP;AACD;;AAEDK,EAAAA,mBAAmB,CAACL,QAAD,EAAWC,aAAX,EAA0B;AAC3C,SAAKF,gBAAL,CAAsBC,QAAtB,EAAgCC,aAAhC,EAA+ChJ,aAAa,CAAC4F,QAAd,CAAuBgC,GAAtE;AACA,WAAO,IAAP;AACD;;AAEDe,EAAAA,eAAe,CAACH,OAAD,EAAUC,aAAV,EAAyB/B,QAAzB,EAAmC;AAChD,QAAIA,QAAQ,KAAKlF,SAAjB,EAA4B;AAC1BkF,MAAAA,QAAQ,GAAG1G,aAAa,CAAC4F,QAAd,CAAuBC,KAAlC;AACD;;AACD,SAAK/C,WAAL,CAAiB,IAAIvC,YAAJ,CAAiBiI,OAAjB,EAA0BC,aAA1B,EACdf,WADc,CACFhB,QADE,CAAjB,EAC0BA,QAD1B;AAEA,WAAO,IAAP;AACD;;AAED2B,EAAAA,OAAO,CAAC/G,IAAD,EAAOK,IAAP,EAAauG,UAAb,EAAyBxB,QAAzB,EAAmC;AACxC,QAAIA,QAAQ,KAAKlF,SAAb,IAA0BkF,QAAQ,KAAK1G,aAAa,CAAC4F,QAAd,CAAuBC,KAAlE,EAAyE;AACvE,WAAKvE,IAAL,GAAYA,IAAZ;AACD,KAFD,MAEO,IAAIoF,QAAQ,KAAK1G,aAAa,CAAC4F,QAAd,CAAuBgC,GAAxC,EAA6C;AAClD,WAAKrG,OAAL,GAAeD,IAAf;AACD;;AAED,SAAKwB,WAAL,CAAiB,IAAIxC,IAAJ,CAASgB,IAAT,EAAeK,IAAf,EAAqBuG,UAArB,CAAjB,EAAmDxB,QAAnD;AACA,WAAO,IAAP;AACD;;AAED2C,EAAAA,UAAU,CAAC/H,IAAD,EAAOK,IAAP,EAAauG,UAAb,EAAyB;AACjC,SAAKG,OAAL,CAAa/G,IAAb,EAAmBK,IAAnB,EAAyBuG,UAAzB,EAAqClI,aAAa,CAAC4F,QAAd,CAAuBgC,GAA5D;AACA,WAAO,IAAP;AACD;;AAEDsB,EAAAA,gBAAgB,CAACH,QAAD,EAAWC,aAAX,EAA0BtC,QAA1B,EAAoC;AAClD,SAAK5D,WAAL,CAAiB,IAAItC,aAAJ,CAAkBuI,QAAlB,EAA4BC,aAA5B,CAAjB,EAA6DtC,QAA7D;AACA,WAAO,IAAP;AACD;;AAED4C,EAAAA,mBAAmB,CAACP,QAAD,EAAWC,aAAX,EAA0B;AAC3C,SAAKE,gBAAL,CAAsBH,QAAtB,EAAgCC,aAAhC,EAA+ChJ,aAAa,CAAC4F,QAAd,CAAuBgC,GAAtE;AACA,WAAO,IAAP;AACD,GAjZgC,CAmZjC;;;AACA2B,EAAAA,cAAc,GAAG;AACf,SAAKlB,OAAL,CAAa,QAAb;AACA,WAAO,IAAP;AACD;;AAED1C,EAAAA,YAAY,CAACe,QAAD,EAAW8C,QAAX,EAAqB;AAC/B,QAAI9C,QAAQ,KAAKlF,SAAb,IAA0BgI,QAAQ,KAAKhI,SAA3C,EAAsD,OAAO,KAAKJ,SAAZ;AAEtD,WAAO,KAAKA,SAAL,CAAeqI,MAAf,CAAsBhC,QAAQ,IACnC,CAACf,QAAQ,KAAKlF,SAAb,IAA0BkF,QAAQ,KAAKe,QAAQ,CAACiC,WAAT,EAAxC,MACCF,QAAQ,KAAKhI,SAAb,IAA0BgI,QAAQ,KAAK/B,QAAQ,CAACkC,WAAT,EADxC,CADK,CAAP;AAID;;AAEDC,EAAAA,cAAc,CAACC,KAAD,EAAQC,KAAR,EAAe;AAC3B,SAAK,IAAIzG,CAAC,GAAGwG,KAAK,CAAC9E,MAAN,GAAe,CAA5B,EAA+B1B,CAAC,IAAI,CAApC,EAAuCA,CAAC,EAAxC,EAA4C;AAC1C,WAAK,IAAI0G,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG1G,CAApB,EAAuB0G,CAAC,EAAxB,EAA4B;AAC1B,YAAID,KAAK,CAACD,KAAK,CAACE,CAAD,CAAL,CAASJ,WAAT,EAAD,CAAL,GAAgCG,KAAK,CAACD,KAAK,CAACE,CAAC,GAAG,CAAL,CAAL,CAAaJ,WAAb,EAAD,CAAzC,EAAuE;AACrE,gBAAMK,IAAI,GAAGH,KAAK,CAACE,CAAD,CAAlB;AACAF,UAAAA,KAAK,CAACE,CAAD,CAAL,GAAWF,KAAK,CAACE,CAAC,GAAG,CAAL,CAAhB;AACAF,UAAAA,KAAK,CAACE,CAAC,GAAG,CAAL,CAAL,GAAeC,IAAf;AACD;AACF;AACF;AACF;;AAEDpG,EAAAA,MAAM,GAAG;AACP,UAAMC,UAAU,GAAG,KAAKzC,SAAL,CAAe,CAAf,CAAnB;AACA,UAAM6I,UAAU,GAAG,KAAK7I,SAAL,CAAe,CAAf,CAAnB;AAEA,UAAM8I,YAAY,GAAG,KAAKvE,YAAL,CAAkB3F,aAAa,CAAC4F,QAAd,CAAuBC,KAAzC,CAArB;AACA,UAAMsE,YAAY,GAAG,KAAKxE,YAAL,CAAkB3F,aAAa,CAAC4F,QAAd,CAAuBgC,GAAzC,CAArB;AAEA,SAAKgC,cAAL,CAAoBM,YAApB,EAAkC;AAChCE,MAAAA,QAAQ,EAAE,CADsB;AACnBjC,MAAAA,KAAK,EAAE,CADY;AACTkC,MAAAA,aAAa,EAAE,CADN;AACSC,MAAAA,cAAc,EAAE;AADzB,KAAlC;AAIA,SAAKV,cAAL,CAAoBO,YAApB,EAAkC;AAChCG,MAAAA,cAAc,EAAE,CADgB;AACbD,MAAAA,aAAa,EAAE,CADF;AACKD,MAAAA,QAAQ,EAAE,CADf;AACkBjC,MAAAA,KAAK,EAAE;AADzB,KAAlC;;AAIA,QAAI+B,YAAY,CAACnF,MAAb,GAAsB,CAAtB,IACFlB,UAAU,CAACiC,OAAX,OAAyB/F,OAAO,CAAC8C,IAAR,CAAakD,YADxC,EACsD;AACpDmE,MAAAA,YAAY,CAAC5G,IAAb,CAAkB4G,YAAY,CAACK,MAAb,CAAoB,CAApB,EAAuB,CAAvB,EAA0B,CAA1B,CAAlB;AACAL,MAAAA,YAAY,CAACK,MAAb,CAAoB,CAApB,EAAuB,CAAvB,EAA0B,IAAIxK,OAAJ,CAAYA,OAAO,CAAC8C,IAAR,CAAaE,MAAzB,CAA1B;AACD;;AAED,QAAIoH,YAAY,CAACK,OAAb,CAAqBP,UAArB,IAAmC,CAAvC,EAA0C;AACxCE,MAAAA,YAAY,CAACI,MAAb,CAAoB,CAApB,EAAuB,CAAvB,EAA0B,IAAIxK,OAAJ,CAAYA,OAAO,CAAC8C,IAAR,CAAaG,IAAzB,CAA1B;AACD;;AAED,QAAIlC,KAAJ;AACA,QAAI2J,OAAJ;AACA,QAAIhD,QAAJ;AACA,QAAIiD,MAAM,GAAG,CAAb;AACA,QAAI9J,CAAC,GAAG,KAAKA,CAAb;;AACA,SAAK,IAAIyC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG6G,YAAY,CAACnF,MAAjC,EAAyC1B,CAAC,EAA1C,EAA8C;AAC5CoE,MAAAA,QAAQ,GAAGyC,YAAY,CAAC7G,CAAD,CAAvB;AACAoH,MAAAA,OAAO,GAAGhD,QAAQ,CAACkD,UAAT,CAAoBtH,CAAC,GAAGqH,MAAxB,CAAV;AACA5J,MAAAA,KAAK,GAAG2G,QAAQ,CAAC1D,QAAT,EAAR;AAEAnD,MAAAA,CAAC,IAAI6J,OAAL;AACAhD,MAAAA,QAAQ,CAAC3D,IAAT,CAAclD,CAAd;AACAA,MAAAA,CAAC,IAAIE,KAAL;AAEA,UAAI2J,OAAO,GAAG3J,KAAV,KAAoB,CAAxB,EAA2B4J,MAAM;AAClC;;AAED,SAAKxJ,OAAL,GAAeN,CAAf;AACAA,IAAAA,CAAC,GAAG,KAAKA,CAAL,GAAS,KAAKE,KAAlB;AAEA,UAAM8J,MAAM,GAAG;AACbC,MAAAA,IAAI,EAAE,CADO;AAEbC,MAAAA,KAAK,EAAE,CAFM;AAGbC,MAAAA,YAAY,EAAE,CAHD;AAIbC,MAAAA,WAAW,EAAE;AAJA,KAAf;AAOA,QAAIC,cAAc,GAAG,CAArB;;AAEA,SAAK,IAAI5H,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG8G,YAAY,CAACpF,MAAjC,EAAyC1B,CAAC,EAA1C,EAA8C;AAC5CoE,MAAAA,QAAQ,GAAG0C,YAAY,CAAC9G,CAAD,CAAvB;AACA4H,MAAAA,cAAc,GAAIxD,QAAQ,CAACkC,WAAT,OAA2B,UAA5B,GAA0CtG,CAA1C,GAA8C4H,cAA/D;AAEAL,MAAAA,MAAM,CAACE,KAAP,GAAe,CAAf;AACAF,MAAAA,MAAM,CAACC,IAAP,GAAc,CAAd;AACAD,MAAAA,MAAM,CAACG,YAAP,GAAsB,CAAtB;AACAH,MAAAA,MAAM,CAACI,WAAP,GAAqB,CAArB;AACA,YAAME,aAAa,GAAGzD,QAAQ,CAAC0D,gBAAT,EAAtB;;AAEA,UAAID,aAAJ,EAAmB;AACjB,YAAI7H,CAAC,KAAK,CAAV,EAAa;AACXuH,UAAAA,MAAM,CAACE,KAAP,GAAeI,aAAa,CAACE,IAAd,IAAsB,CAArC;AACAR,UAAAA,MAAM,CAACG,YAAP,GAAsBG,aAAa,CAACH,YAAd,IAA8B,CAApD;AACD;;AACDH,QAAAA,MAAM,CAACC,IAAP,GAAe,CAACK,aAAa,CAACG,IAAhB,IAAyB,CAAvC;AACAT,QAAAA,MAAM,CAACI,WAAP,GAAqBE,aAAa,CAACF,WAAd,IAA6B,CAAlD;;AAEA,YAAI3H,CAAC,KAAK8G,YAAY,CAACpF,MAAb,GAAsB,CAAhC,EAAmC;AACjC6F,UAAAA,MAAM,CAACI,WAAP,GAAqB,CAArB;AACD;AACF,OAXD,MAWO;AACLJ,QAAAA,MAAM,CAACG,YAAP,GAAsBtD,QAAQ,CAACkD,UAAT,CAAoBtH,CAAC,GAAG4H,cAAxB,CAAtB;;AACA,YAAI5H,CAAC,KAAK,CAAV,EAAa;AACXuH,UAAAA,MAAM,CAACE,KAAP,GAAerD,QAAQ,CAAC1D,QAAT,EAAf;AACD;;AACD,YAAIV,CAAC,KAAK,CAAV,EAAa;AACXuH,UAAAA,MAAM,CAACC,IAAP,GAAcpD,QAAQ,CAAC1D,QAAT,EAAd;AACD;AACF;;AACDnD,MAAAA,CAAC,IAAIgK,MAAM,CAACG,YAAZ;AACAnK,MAAAA,CAAC,IAAIgK,MAAM,CAACE,KAAZ;AAEArD,MAAAA,QAAQ,CAAC3D,IAAT,CAAclD,CAAd;AAEAA,MAAAA,CAAC,IAAIgK,MAAM,CAACC,IAAZ;AACAjK,MAAAA,CAAC,IAAIgK,MAAM,CAACI,WAAZ;AACD;;AAED,SAAK7J,KAAL,GAAagJ,YAAY,CAACpF,MAAb,KAAwB,CAAxB,GAA4B,KAAKnE,CAAL,GAAS,KAAKE,KAA1C,GAAkDF,CAA/D;AACA,SAAKK,SAAL,GAAiB,IAAjB;AACD;AAED;;;;;AAGAqK,EAAAA,IAAI,GAAG;AACL,SAAKC,YAAL;AACA,SAAKC,WAAL;AAEA,QAAI,CAAC,KAAKvK,SAAV,EAAqB,KAAK2C,MAAL;AAErB,UAAM7B,SAAS,GAAG,KAAKhB,OAAL,CAAagB,SAA/B;AACA,UAAMjB,KAAK,GAAG,KAAKA,KAAnB;AACA,UAAMF,CAAC,GAAG,KAAKA,CAAf;AACA,QAAIC,CAAJ,CATK,CAWL;;AACA,SAAK,IAAIoG,IAAI,GAAG,CAAhB,EAAmBA,IAAI,GAAGlF,SAA1B,EAAqCkF,IAAI,EAAzC,EAA6C;AAC3CpG,MAAAA,CAAC,GAAG,KAAK8D,WAAL,CAAiBsC,IAAjB,CAAJ;AAEA,WAAKwE,UAAL;;AACA,UAAI,KAAK1K,OAAL,CAAaqC,WAAb,CAAyB6D,IAAzB,EAA+B1D,OAAnC,EAA4C;AAC1C,aAAKmI,OAAL,CAAaC,SAAb;AACA,aAAKD,OAAL,CAAaE,MAAb,CAAoBhL,CAApB,EAAuBC,CAAvB;AACA,aAAK6K,OAAL,CAAaG,MAAb,CAAoBjL,CAAC,GAAGE,KAAxB,EAA+BD,CAA/B;AACA,aAAK6K,OAAL,CAAaI,MAAb;AACD;;AACD,WAAKC,YAAL;AACD,KAvBI,CAyBL;;;AACA,SAAK,IAAI1I,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,KAAKjC,SAAL,CAAe2D,MAAnC,EAA2C1B,CAAC,EAA5C,EAAgD;AAC9C;AACA,UAAI,OAAO,KAAKjC,SAAL,CAAeiC,CAAf,EAAkBiI,IAAzB,KAAkC,UAAtC,EAAkD;AAChD,aAAKlK,SAAL,CAAeiC,CAAf,EAAkBoI,UAAlB,CAA6B,KAAKC,OAAlC;AACA,aAAKtK,SAAL,CAAeiC,CAAf,EAAkBiI,IAAlB,CAAuB,IAAvB,EAA6B,KAAK9F,iBAAL,CAAuBnC,CAAvB,CAA7B;AACA,aAAKjC,SAAL,CAAeiC,CAAf,EAAkB0I,YAAlB,CAA+B,KAAKL,OAApC;AACD;AACF,KAjCI,CAmCL;;;AACA,QAAI,KAAKrK,OAAL,GAAe,CAAnB,EAAsB;AACpB,WAAKqK,OAAL,CAAaM,IAAb;AACA,WAAKN,OAAL,CAAaO,OAAb,CAAqB,KAAKxK,IAAL,CAAUC,MAA/B,EAAuC,KAAKD,IAAL,CAAUE,IAAjD,EAAuD,KAAKF,IAAL,CAAUG,MAAjE;AACA,YAAMsK,UAAU,GAAG,KAAKR,OAAL,CAAaS,WAAb,CAAyB,KAAK,KAAK9K,OAAnC,EAA4CP,KAA/D;AACAD,MAAAA,CAAC,GAAG,KAAKuG,cAAL,CAAoB,CAApB,IAAyB,CAA7B;AACA,WAAKsE,OAAL,CAAaU,QAAb,CAAsB,KAAK,KAAK/K,OAAhC,EAAyC,KAAKT,CAAL,GAASsL,UAAU,GAAG,CAA/D,EAAkErL,CAAlE;AACA,WAAK6K,OAAL,CAAaW,OAAb;AACD;;AAED,WAAO,IAAP;AACD,GAhkBgC,CAkkBjC;AACA;;;AACAC,EAAAA,YAAY,CAAC1L,CAAD,EAAI2L,QAAJ,EAAc;AACxB,SAAKC,iBAAL,CAAuB,KAAK5L,CAAL,GAASA,CAAhC,EAAmC2L,QAAnC;AACD;;AAEDC,EAAAA,iBAAiB,CAAC5L,CAAD,EAAI2L,QAAJ,EAAc;AAC7B,SAAKhB,YAAL;AAEA,UAAMkB,QAAQ,GAAG,KAAK9H,WAAL,CAAiB,CAAjB,CAAjB;AACA,UAAM+H,WAAW,GAAG,KAAK/H,WAAL,CAAiB,KAAK5D,OAAL,CAAagB,SAAb,GAAyB,CAA1C,CAApB;;AACA,QAAIwK,QAAJ,EAAc;AACZ,WAAKb,OAAL,CAAaiB,QAAb,CAAsB/L,CAAC,GAAG,CAA1B,EAA6B6L,QAA7B,EAAuC,CAAvC,EAA0CC,WAAW,GAAGD,QAAd,GAAyB,CAAnE;AACD;;AACD,SAAKf,OAAL,CAAaiB,QAAb,CAAsB/L,CAAtB,EAAyB6L,QAAzB,EAAmC,CAAnC,EAAsCC,WAAW,GAAGD,QAAd,GAAyB,CAA/D;AACD;;AAEDG,EAAAA,eAAe,CAAChM,CAAD,EAAI;AACjB,SAAKiM,oBAAL,CAA0B,KAAKjM,CAAL,GAASA,CAAnC,EAAsC,KAAtC;AACD;;AAEDiM,EAAAA,oBAAoB,CAACjM,CAAD,EAAI;AACtB,SAAK2K,YAAL;AAEA,UAAMkB,QAAQ,GAAG,KAAK9H,WAAL,CAAiB,CAAjB,CAAjB;AACA,UAAM+H,WAAW,GAAG,KAAK/H,WAAL,CAAiB,KAAK5D,OAAL,CAAagB,SAAb,GAAyB,CAA1C,CAApB;AACA,SAAK2J,OAAL,CAAaiB,QAAb,CAAsB/L,CAAtB,EAAyB6L,QAAzB,EAAmC,CAAnC,EAAsCC,WAAW,GAAGD,QAAd,GAAyB,CAA/D;AACD;AAED;;;;;;AAIAK,EAAAA,iBAAiB,GAAG;AAClB,WAAO,KAAK/L,OAAL,CAAaqC,WAApB;AACD;AAED;;;;;;;;;AAOA2J,EAAAA,gBAAgB,CAACC,WAAD,EAAc5J,WAAd,EAA2B;AACzC,QAAI4J,WAAW,IAAI,KAAKjM,OAAL,CAAagB,SAA5B,IAAyCiL,WAAW,GAAG,CAA3D,EAA8D;AAC5D,YAAM,IAAIpN,GAAG,CAAC8F,IAAR,CACJ,kBADI,EAEJ,+EAFI,CAAN;AAID;;AAED,QAAItC,WAAW,CAACG,OAAZ,KAAwB/B,SAA5B,EAAuC;AACrC,YAAM,IAAI5B,GAAG,CAAC8F,IAAR,CACJ,kBADI,EAEJ,kEAFI,CAAN;AAID;;AAED,QAAI,OAAQtC,WAAW,CAACG,OAApB,KAAiC,SAArC,EAAgD;AAC9C,YAAM,IAAI3D,GAAG,CAAC8F,IAAR,CACJ,kBADI,EAEJ,0EAFI,CAAN;AAID;;AAED,SAAK3E,OAAL,CAAaqC,WAAb,CAAyB4J,WAAzB,IAAwC5J,WAAxC;AAEA,WAAO,IAAP;AACD;AAED;;;;;;;;;;;AASA6J,EAAAA,iBAAiB,CAACC,mBAAD,EAAsB;AACrC,QAAIA,mBAAmB,CAACnI,MAApB,KAA+B,KAAKhE,OAAL,CAAagB,SAAhD,EAA2D;AACzD,YAAM,IAAInC,GAAG,CAAC8F,IAAR,CACJ,kBADI,EAEJ,yFAFI,CAAN;AAID,KANoC,CAQrC;AACA;AACA;;;AACA,SAAK,MAAMtC,WAAX,IAA0B8J,mBAA1B,EAA+C;AAC7C;AACA,UAAI,CAACA,mBAAmB,CAAC9J,WAAD,CAAxB,EAAuC;AACrC8J,QAAAA,mBAAmB,CAAC9J,WAAD,CAAnB,GAAmC,KAAKrC,OAAL,CAAaqC,WAAb,CAAyBA,WAAzB,CAAnC;AACD;;AACDxD,MAAAA,GAAG,CAAC8C,KAAJ,CAAU,KAAK3B,OAAL,CAAaqC,WAAb,CAAyBA,WAAzB,CAAV,EAAiD8J,mBAAmB,CAAC9J,WAAD,CAApE;AACD;;AAED,SAAKrC,OAAL,CAAaqC,WAAb,GAA2B8J,mBAA3B;AAEA,WAAO,IAAP;AACD;;AAxqBgC","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n\nimport { Vex } from './vex';\nimport { Element } from './element';\nimport { Flow } from './tables';\nimport { Barline } from './stavebarline';\nimport { StaveModifier } from './stavemodifier';\nimport { Repetition } from './staverepetition';\nimport { StaveSection } from './stavesection';\nimport { StaveTempo } from './stavetempo';\nimport { StaveText } from './stavetext';\nimport { BoundingBox } from './boundingbox';\nimport { Clef } from './clef';\nimport { KeySignature } from './keysignature';\nimport { TimeSignature } from './timesignature';\nimport { Volta } from './stavevolta';\n\nexport class Stave extends Element {\n  constructor(x, y, width, options) {\n    super();\n    this.setAttribute('type', 'Stave');\n\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.formatted = false;\n    this.start_x = x + 5;\n    this.end_x = x + width;\n    this.modifiers = [];  // stave modifiers (clef, key, time, barlines, coda, segno, etc.)\n    this.measure = 0;\n    this.clef = 'treble';\n    this.endClef = undefined;\n    this.font = {\n      family: 'sans-serif',\n      size: 8,\n      weight: '',\n    };\n    this.options = {\n      vertical_bar_width: 10,       // Width around vertical bar end-marker\n      glyph_spacing_px: 10,\n      num_lines: 5,\n      fill_style: '#999999',\n      left_bar: true,               // draw vertical bar on left\n      right_bar: true,               // draw vertical bar on right\n      spacing_between_lines_px: 10, // in pixels\n      space_above_staff_ln: 4,      // in staff lines\n      space_below_staff_ln: 4,      // in staff lines\n      top_text_position: 1,          // in staff lines\n    };\n    this.bounds = { x: this.x, y: this.y, w: this.width, h: 0 };\n    Vex.Merge(this.options, options);\n\n    this.resetLines();\n\n    const BARTYPE = Barline.type;\n    // beg bar\n    this.addModifier(new Barline(this.options.left_bar ? BARTYPE.SINGLE : BARTYPE.NONE));\n    // end bar\n    this.addEndModifier(new Barline(this.options.right_bar ? BARTYPE.SINGLE : BARTYPE.NONE));\n  }\n\n  space(spacing) { return this.options.spacing_between_lines_px * spacing; }\n\n  resetLines() {\n    this.options.line_config = [];\n    for (let i = 0; i < this.options.num_lines; i++) {\n      this.options.line_config.push({ visible: true });\n    }\n    this.height = (this.options.num_lines + this.options.space_above_staff_ln) *\n      this.options.spacing_between_lines_px;\n    this.options.bottom_text_position = this.options.num_lines;\n  }\n\n  getOptions() { return this.options; }\n\n  setNoteStartX(x) {\n    if (!this.formatted) this.format();\n\n    this.start_x = x;\n    const begBarline = this.modifiers[0];\n    begBarline.setX(this.start_x - begBarline.getWidth());\n    return this;\n  }\n  getNoteStartX() {\n    if (!this.formatted) this.format();\n\n    return this.start_x;\n  }\n\n  getNoteEndX() {\n    if (!this.formatted) this.format();\n\n    return this.end_x;\n  }\n  getTieStartX() { return this.start_x; }\n  getTieEndX() { return this.x + this.width; }\n  getX() { return this.x; }\n  getNumLines() { return this.options.num_lines; }\n  setNumLines(lines) {\n    this.options.num_lines = parseInt(lines, 10);\n    this.resetLines();\n    return this;\n  }\n  setY(y) { this.y = y; return this; }\n\n  getTopLineTopY() {\n    return this.getYForLine(0) - (Flow.STAVE_LINE_THICKNESS / 2);\n  }\n  getBottomLineBottomY() {\n    return this.getYForLine(this.getNumLines() - 1) + (Flow.STAVE_LINE_THICKNESS / 2);\n  }\n\n  setX(x) {\n    const shift = x - this.x;\n    this.formatted = false;\n    this.x = x;\n    this.start_x += shift;\n    this.end_x += shift;\n    for (let i = 0; i < this.modifiers.length; i++) {\n      const mod = this.modifiers[i];\n      if (mod.x !== undefined) {\n        mod.x += shift;\n      }\n    }\n    return this;\n  }\n\n  setWidth(width) {\n    this.formatted = false;\n    this.width = width;\n    this.end_x = this.x + width;\n\n    // reset the x position of the end barline (TODO(0xfe): This makes no sense)\n    // this.modifiers[1].setX(this.end_x);\n    return this;\n  }\n\n  getWidth() {\n    return this.width;\n  }\n\n  getStyle() {\n    return {\n      fillStyle: this.options.fill_style,\n      strokeStyle: this.options.fill_style, // yes, this is correct for legacy compatibility\n      lineWidth: Flow.STAVE_LINE_THICKNESS, ...this.style || {}\n    };\n  }\n\n  setMeasure(measure) { this.measure = measure; return this; }\n\n  /**\n   * Gets the pixels to shift from the beginning of the stave\n   * following the modifier at the provided index\n   * @param  {Number} index The index from which to determine the shift\n   * @return {Number}       The amount of pixels shifted\n   */\n  getModifierXShift(index = 0) {\n    if (typeof index !== 'number') {\n      throw new Vex.RERR('InvalidIndex', 'Must be of number type');\n    }\n\n    if (!this.formatted) this.format();\n\n    if (this.getModifiers(StaveModifier.Position.BEGIN).length === 1) {\n      return 0;\n    }\n\n    let start_x = this.start_x - this.x;\n    const begBarline = this.modifiers[0];\n    if (begBarline.getType() === Barline.type.REPEAT_BEGIN && start_x > begBarline.getWidth()) {\n      start_x -= begBarline.getWidth();\n    }\n\n    return start_x;\n  }\n\n  // Coda & Segno Symbol functions\n  setRepetitionTypeLeft(type, y) {\n    this.modifiers.push(new Repetition(type, this.x, y));\n    return this;\n  }\n\n  setRepetitionTypeRight(type, y) {\n    this.modifiers.push(new Repetition(type, this.x, y));\n    return this;\n  }\n\n  // Volta functions\n  setVoltaType(type, number_t, y) {\n    this.modifiers.push(new Volta(type, number_t, this.x, y));\n    return this;\n  }\n\n  // Section functions\n  setSection(section, y) {\n    this.modifiers.push(new StaveSection(section, this.x, y));\n    return this;\n  }\n\n  // Tempo functions\n  setTempo(tempo, y) {\n    this.modifiers.push(new StaveTempo(tempo, this.x, y));\n    return this;\n  }\n\n  // Text functions\n  setText(text, position, options) {\n    this.modifiers.push(new StaveText(text, position, options));\n    return this;\n  }\n\n  getHeight() {\n    return this.height;\n  }\n\n  getSpacingBetweenLines() {\n    return this.options.spacing_between_lines_px;\n  }\n\n  getBoundingBox() {\n    return new BoundingBox(this.x, this.y, this.width, this.getBottomY() - this.y);\n  }\n\n  getBottomY() {\n    const options = this.options;\n    const spacing = options.spacing_between_lines_px;\n    const score_bottom = this.getYForLine(options.num_lines) +\n      (options.space_below_staff_ln * spacing);\n\n    return score_bottom;\n  }\n\n  getBottomLineY() {\n    return this.getYForLine(this.options.num_lines);\n  }\n\n  // This returns the y for the *center* of a staff line\n  getYForLine(line) {\n    const options = this.options;\n    const spacing = options.spacing_between_lines_px;\n    const headroom = options.space_above_staff_ln;\n\n    const y = this.y + (line * spacing) + (headroom * spacing);\n\n    return y;\n  }\n\n  getLineForY(y) {\n    // Does the reverse of getYForLine - somewhat dumb and just calls\n    // getYForLine until the right value is reaches\n\n    const options = this.options;\n    const spacing = options.spacing_between_lines_px;\n    const headroom = options.space_above_staff_ln;\n    return ((y - this.y) / spacing) - headroom;\n  }\n\n  getYForTopText(line) {\n    const l = line || 0;\n    return this.getYForLine(-l - this.options.top_text_position);\n  }\n\n  getYForBottomText(line) {\n    const l = line || 0;\n    return this.getYForLine(this.options.bottom_text_position + l);\n  }\n\n  getYForNote(line) {\n    const options = this.options;\n    const spacing = options.spacing_between_lines_px;\n    const headroom = options.space_above_staff_ln;\n    const y = this.y + (headroom * spacing) + (5 * spacing) - (line * spacing);\n\n    return y;\n  }\n\n  getYForGlyphs() {\n    return this.getYForLine(3);\n  }\n\n  // This method adds a stave modifier to the stave. Note that the first two\n  // modifiers (BarLines) are automatically added upon construction.\n  addModifier(modifier, position) {\n    if (position !== undefined) {\n      modifier.setPosition(position);\n    }\n\n    modifier.setStave(this);\n    this.formatted = false;\n    this.modifiers.push(modifier);\n    return this;\n  }\n\n  addEndModifier(modifier) {\n    this.addModifier(modifier, StaveModifier.Position.END);\n    return this;\n  }\n\n  // Bar Line functions\n  setBegBarType(type) {\n    // Only valid bar types at beginning of stave is none, single or begin repeat\n    const { SINGLE, REPEAT_BEGIN, NONE } = Barline.type;\n    if (type === SINGLE || type === REPEAT_BEGIN || type === NONE) {\n      this.modifiers[0].setType(type);\n      this.formatted = false;\n    }\n    return this;\n  }\n\n  setEndBarType(type) {\n    // Repeat end not valid at end of stave\n    if (type !== Barline.type.REPEAT_BEGIN) {\n      this.modifiers[1].setType(type);\n      this.formatted = false;\n    }\n    return this;\n  }\n\n  setClef(clefSpec, size, annotation, position) {\n    if (position === undefined) {\n      position = StaveModifier.Position.BEGIN;\n    }\n\n    if (position === StaveModifier.Position.END) {\n      this.endClef = clefSpec;\n    } else {\n      this.clef = clefSpec;\n    }\n\n    const clefs = this.getModifiers(position, Clef.CATEGORY);\n    if (clefs.length === 0) {\n      this.addClef(clefSpec, size, annotation, position);\n    } else {\n      clefs[0].setType(clefSpec, size, annotation);\n    }\n\n    return this;\n  }\n\n  setEndClef(clefSpec, size, annotation) {\n    this.setClef(clefSpec, size, annotation, StaveModifier.Position.END);\n    return this;\n  }\n\n  setKeySignature(keySpec, cancelKeySpec, position) {\n    if (position === undefined) {\n      position = StaveModifier.Position.BEGIN;\n    }\n\n    const keySignatures = this.getModifiers(position, KeySignature.CATEGORY);\n    if (keySignatures.length === 0) {\n      this.addKeySignature(keySpec, cancelKeySpec, position);\n    } else {\n      keySignatures[0].setKeySig(keySpec, cancelKeySpec);\n    }\n\n    return this;\n  }\n\n  setEndKeySignature(keySpec, cancelKeySpec) {\n    this.setKeySignature(keySpec, cancelKeySpec, StaveModifier.Position.END);\n    return this;\n  }\n\n  setTimeSignature(timeSpec, customPadding, position) {\n    if (position === undefined) {\n      position = StaveModifier.Position.BEGIN;\n    }\n\n    const timeSignatures = this.getModifiers(position, TimeSignature.CATEGORY);\n    if (timeSignatures.length === 0) {\n      this.addTimeSignature(timeSpec, customPadding, position);\n    } else {\n      timeSignatures[0].setTimeSig(timeSpec);\n    }\n\n    return this;\n  }\n\n  setEndTimeSignature(timeSpec, customPadding) {\n    this.setTimeSignature(timeSpec, customPadding, StaveModifier.Position.END);\n    return this;\n  }\n\n  addKeySignature(keySpec, cancelKeySpec, position) {\n    if (position === undefined) {\n      position = StaveModifier.Position.BEGIN;\n    }\n    this.addModifier(new KeySignature(keySpec, cancelKeySpec)\n      .setPosition(position), position);\n    return this;\n  }\n\n  addClef(clef, size, annotation, position) {\n    if (position === undefined || position === StaveModifier.Position.BEGIN) {\n      this.clef = clef;\n    } else if (position === StaveModifier.Position.END) {\n      this.endClef = clef;\n    }\n\n    this.addModifier(new Clef(clef, size, annotation), position);\n    return this;\n  }\n\n  addEndClef(clef, size, annotation) {\n    this.addClef(clef, size, annotation, StaveModifier.Position.END);\n    return this;\n  }\n\n  addTimeSignature(timeSpec, customPadding, position) {\n    this.addModifier(new TimeSignature(timeSpec, customPadding), position);\n    return this;\n  }\n\n  addEndTimeSignature(timeSpec, customPadding) {\n    this.addTimeSignature(timeSpec, customPadding, StaveModifier.Position.END);\n    return this;\n  }\n\n  // Deprecated\n  addTrebleGlyph() {\n    this.addClef('treble');\n    return this;\n  }\n\n  getModifiers(position, category) {\n    if (position === undefined && category === undefined) return this.modifiers;\n\n    return this.modifiers.filter(modifier =>\n      (position === undefined || position === modifier.getPosition()) &&\n      (category === undefined || category === modifier.getCategory())\n    );\n  }\n\n  sortByCategory(items, order) {\n    for (let i = items.length - 1; i >= 0; i--) {\n      for (let j = 0; j < i; j++) {\n        if (order[items[j].getCategory()] > order[items[j + 1].getCategory()]) {\n          const temp = items[j];\n          items[j] = items[j + 1];\n          items[j + 1] = temp;\n        }\n      }\n    }\n  }\n\n  format() {\n    const begBarline = this.modifiers[0];\n    const endBarline = this.modifiers[1];\n\n    const begModifiers = this.getModifiers(StaveModifier.Position.BEGIN);\n    const endModifiers = this.getModifiers(StaveModifier.Position.END);\n\n    this.sortByCategory(begModifiers, {\n      barlines: 0, clefs: 1, keysignatures: 2, timesignatures: 3,\n    });\n\n    this.sortByCategory(endModifiers, {\n      timesignatures: 0, keysignatures: 1, barlines: 2, clefs: 3,\n    });\n\n    if (begModifiers.length > 1 &&\n      begBarline.getType() === Barline.type.REPEAT_BEGIN) {\n      begModifiers.push(begModifiers.splice(0, 1)[0]);\n      begModifiers.splice(0, 0, new Barline(Barline.type.SINGLE));\n    }\n\n    if (endModifiers.indexOf(endBarline) > 0) {\n      endModifiers.splice(0, 0, new Barline(Barline.type.NONE));\n    }\n\n    let width;\n    let padding;\n    let modifier;\n    let offset = 0;\n    let x = this.x;\n    for (let i = 0; i < begModifiers.length; i++) {\n      modifier = begModifiers[i];\n      padding = modifier.getPadding(i + offset);\n      width = modifier.getWidth();\n\n      x += padding;\n      modifier.setX(x);\n      x += width;\n\n      if (padding + width === 0) offset--;\n    }\n\n    this.start_x = x;\n    x = this.x + this.width;\n\n    const widths = {\n      left: 0,\n      right: 0,\n      paddingRight: 0,\n      paddingLeft: 0,\n    };\n\n    let lastBarlineIdx = 0;\n\n    for (let i = 0; i < endModifiers.length; i++) {\n      modifier = endModifiers[i];\n      lastBarlineIdx = (modifier.getCategory() === 'barlines') ? i : lastBarlineIdx;\n\n      widths.right = 0;\n      widths.left = 0;\n      widths.paddingRight = 0;\n      widths.paddingLeft = 0;\n      const layoutMetrics = modifier.getLayoutMetrics();\n\n      if (layoutMetrics) {\n        if (i !== 0) {\n          widths.right = layoutMetrics.xMax || 0;\n          widths.paddingRight = layoutMetrics.paddingRight || 0;\n        }\n        widths.left = (-layoutMetrics.xMin) || 0;\n        widths.paddingLeft = layoutMetrics.paddingLeft || 0;\n\n        if (i === endModifiers.length - 1) {\n          widths.paddingLeft = 0;\n        }\n      } else {\n        widths.paddingRight = modifier.getPadding(i - lastBarlineIdx);\n        if (i !== 0) {\n          widths.right = modifier.getWidth();\n        }\n        if (i === 0) {\n          widths.left = modifier.getWidth();\n        }\n      }\n      x -= widths.paddingRight;\n      x -= widths.right;\n\n      modifier.setX(x);\n\n      x -= widths.left;\n      x -= widths.paddingLeft;\n    }\n\n    this.end_x = endModifiers.length === 1 ? this.x + this.width : x;\n    this.formatted = true;\n  }\n\n  /**\n   * All drawing functions below need the context to be set.\n   */\n  draw() {\n    this.checkContext();\n    this.setRendered();\n\n    if (!this.formatted) this.format();\n\n    const num_lines = this.options.num_lines;\n    const width = this.width;\n    const x = this.x;\n    let y;\n\n    // Render lines\n    for (let line = 0; line < num_lines; line++) {\n      y = this.getYForLine(line);\n\n      this.applyStyle();\n      if (this.options.line_config[line].visible) {\n        this.context.beginPath();\n        this.context.moveTo(x, y);\n        this.context.lineTo(x + width, y);\n        this.context.stroke();\n      }\n      this.restoreStyle();\n    }\n\n    // Draw the modifiers (bar lines, coda, segno, repeat brackets, etc.)\n    for (let i = 0; i < this.modifiers.length; i++) {\n      // Only draw modifier if it has a draw function\n      if (typeof this.modifiers[i].draw === 'function') {\n        this.modifiers[i].applyStyle(this.context);\n        this.modifiers[i].draw(this, this.getModifierXShift(i));\n        this.modifiers[i].restoreStyle(this.context);\n      }\n    }\n\n    // Render measure numbers\n    if (this.measure > 0) {\n      this.context.save();\n      this.context.setFont(this.font.family, this.font.size, this.font.weight);\n      const text_width = this.context.measureText('' + this.measure).width;\n      y = this.getYForTopText(0) + 3;\n      this.context.fillText('' + this.measure, this.x - text_width / 2, y);\n      this.context.restore();\n    }\n\n    return this;\n  }\n\n  // Draw Simple barlines for backward compatability\n  // Do not delete - draws the beginning bar of the stave\n  drawVertical(x, isDouble) {\n    this.drawVerticalFixed(this.x + x, isDouble);\n  }\n\n  drawVerticalFixed(x, isDouble) {\n    this.checkContext();\n\n    const top_line = this.getYForLine(0);\n    const bottom_line = this.getYForLine(this.options.num_lines - 1);\n    if (isDouble) {\n      this.context.fillRect(x - 3, top_line, 1, bottom_line - top_line + 1);\n    }\n    this.context.fillRect(x, top_line, 1, bottom_line - top_line + 1);\n  }\n\n  drawVerticalBar(x) {\n    this.drawVerticalBarFixed(this.x + x, false);\n  }\n\n  drawVerticalBarFixed(x) {\n    this.checkContext();\n\n    const top_line = this.getYForLine(0);\n    const bottom_line = this.getYForLine(this.options.num_lines - 1);\n    this.context.fillRect(x, top_line, 1, bottom_line - top_line + 1);\n  }\n\n  /**\n   * Get the current configuration for the Stave.\n   * @return {Array} An array of configuration objects.\n   */\n  getConfigForLines() {\n    return this.options.line_config;\n  }\n\n  /**\n   * Configure properties of the lines in the Stave\n   * @param line_number The index of the line to configure.\n   * @param line_config An configuration object for the specified line.\n   * @throws Vex.RERR \"StaveConfigError\" When the specified line number is out of\n   *   range of the number of lines specified in the constructor.\n   */\n  setConfigForLine(line_number, line_config) {\n    if (line_number >= this.options.num_lines || line_number < 0) {\n      throw new Vex.RERR(\n        'StaveConfigError',\n        'The line number must be within the range of the number of lines in the Stave.'\n      );\n    }\n\n    if (line_config.visible === undefined) {\n      throw new Vex.RERR(\n        'StaveConfigError',\n        \"The line configuration object is missing the 'visible' property.\"\n      );\n    }\n\n    if (typeof (line_config.visible) !== 'boolean') {\n      throw new Vex.RERR(\n        'StaveConfigError',\n        \"The line configuration objects 'visible' property must be true or false.\"\n      );\n    }\n\n    this.options.line_config[line_number] = line_config;\n\n    return this;\n  }\n\n  /**\n   * Set the staff line configuration array for all of the lines at once.\n   * @param lines_configuration An array of line configuration objects.  These objects\n   *   are of the same format as the single one passed in to setLineConfiguration().\n   *   The caller can set null for any line config entry if it is desired that the default be used\n   * @throws Vex.RERR \"StaveConfigError\" When the lines_configuration array does not have\n   *   exactly the same number of elements as the num_lines configuration object set in\n   *   the constructor.\n   */\n  setConfigForLines(lines_configuration) {\n    if (lines_configuration.length !== this.options.num_lines) {\n      throw new Vex.RERR(\n        'StaveConfigError',\n        'The length of the lines configuration array must match the number of lines in the Stave'\n      );\n    }\n\n    // Make sure the defaults are present in case an incomplete set of\n    //  configuration options were supplied.\n    // eslint-disable-next-line\n    for (const line_config in lines_configuration) {\n      // Allow 'null' to be used if the caller just wants the default for a particular node.\n      if (!lines_configuration[line_config]) {\n        lines_configuration[line_config] = this.options.line_config[line_config];\n      }\n      Vex.Merge(this.options.line_config[line_config], lines_configuration[line_config]);\n    }\n\n    this.options.line_config = lines_configuration;\n\n    return this;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}