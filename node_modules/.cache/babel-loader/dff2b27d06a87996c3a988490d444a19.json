{"ast":null,"code":"// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n//\n// This file implements the main Voice class. It's mainly a container\n// object to group `Tickables` for formatting.\nimport { Vex } from './vex';\nimport { Element } from './element';\nimport { Flow } from './tables';\nimport { Fraction } from './fraction';\nexport class Voice extends Element {\n  // Modes allow the addition of ticks in three different ways:\n  //\n  // STRICT: This is the default. Ticks must fill the voice.\n  // SOFT:   Ticks can be added without restrictions.\n  // FULL:   Ticks do not need to fill the voice, but can't exceed the maximum\n  //         tick length.\n  static get Mode() {\n    return {\n      STRICT: 1,\n      SOFT: 2,\n      FULL: 3\n    };\n  }\n\n  constructor(time, options) {\n    super();\n    this.setAttribute('type', 'Voice');\n    this.options = {\n      softmaxFactor: 100,\n      ...options\n    }; // Time signature shortcut: \"4/4\", \"3/8\", etc.\n\n    if (typeof time === 'string') {\n      const match = time.match(/(\\d+)\\/(\\d+)/);\n\n      if (match) {\n        time = {\n          num_beats: match[1],\n          beat_value: match[2],\n          resolution: Flow.RESOLUTION\n        };\n      }\n    } // Default time sig is 4/4\n\n\n    this.time = Vex.Merge({\n      num_beats: 4,\n      beat_value: 4,\n      resolution: Flow.RESOLUTION\n    }, time); // Recalculate total ticks.\n\n    this.totalTicks = new Fraction(this.time.num_beats * (this.time.resolution / this.time.beat_value), 1);\n    this.resolutionMultiplier = 1; // Set defaults\n\n    this.tickables = [];\n    this.ticksUsed = new Fraction(0, 1);\n    this.smallestTickCount = this.totalTicks.clone();\n    this.largestTickWidth = 0;\n    this.stave = null; // Do we care about strictly timed notes\n\n    this.mode = Voice.Mode.STRICT; // This must belong to a VoiceGroup\n\n    this.voiceGroup = null;\n  } // Get the total ticks in the voice\n\n\n  getTotalTicks() {\n    return this.totalTicks;\n  } // Get the total ticks used in the voice by all the tickables\n\n\n  getTicksUsed() {\n    return this.ticksUsed;\n  } // Get the largest width of all the tickables\n\n\n  getLargestTickWidth() {\n    return this.largestTickWidth;\n  } // Get the tick count for the shortest tickable\n\n\n  getSmallestTickCount() {\n    return this.smallestTickCount;\n  } // Get the tickables in the voice\n\n\n  getTickables() {\n    return this.tickables;\n  } // Get/set the voice mode, use a value from `Voice.Mode`\n\n\n  getMode() {\n    return this.mode;\n  }\n\n  setMode(mode) {\n    this.mode = mode;\n    return this;\n  } // Get the resolution multiplier for the voice\n\n\n  getResolutionMultiplier() {\n    return this.resolutionMultiplier;\n  } // Get the actual tick resolution for the voice\n\n\n  getActualResolution() {\n    return this.resolutionMultiplier * this.time.resolution;\n  } // Set the voice's stave\n\n\n  setStave(stave) {\n    this.stave = stave;\n    this.boundingBox = null; // Reset bounding box so we can reformat\n\n    return this;\n  } // Get the bounding box for the voice\n\n\n  getBoundingBox() {\n    let stave;\n    let boundingBox;\n    let bb;\n    let i;\n\n    if (!this.boundingBox) {\n      if (!this.stave) throw new Vex.RERR('NoStave', \"Can't get bounding box without stave.\");\n      stave = this.stave;\n      boundingBox = null;\n\n      for (i = 0; i < this.tickables.length; ++i) {\n        this.tickables[i].setStave(stave);\n        bb = this.tickables[i].getBoundingBox();\n        if (!bb) continue;\n        boundingBox = boundingBox ? boundingBox.mergeWith(bb) : bb;\n      }\n\n      this.boundingBox = boundingBox;\n    }\n\n    return this.boundingBox;\n  } // Every tickable must be associated with a voiceGroup. This allows formatters\n  // and preformatters to associate them with the right modifierContexts.\n\n\n  getVoiceGroup() {\n    if (!this.voiceGroup) {\n      throw new Vex.RERR('NoVoiceGroup', 'No voice group for voice.');\n    }\n\n    return this.voiceGroup;\n  } // Set the voice group\n\n\n  setVoiceGroup(g) {\n    this.voiceGroup = g;\n    return this;\n  } // Set the voice mode to strict or soft\n\n\n  setStrict(strict) {\n    this.mode = strict ? Voice.Mode.STRICT : Voice.Mode.SOFT;\n    return this;\n  } // Determine if the voice is complete according to the voice mode\n\n\n  isComplete() {\n    if (this.mode === Voice.Mode.STRICT || this.mode === Voice.Mode.FULL) {\n      return this.ticksUsed.equals(this.totalTicks);\n    } else {\n      return true;\n    }\n  } // We use softmax to layout the tickables proportional to the exponent of\n  // their duration. The softmax factor is used to determine the 'linearness' of\n  // the layout.\n  //\n  // The softmax of all the tickables in this voice should sum to 1.\n\n\n  setSoftmaxFactor(factor) {\n    this.options.softmaxFactor = factor;\n    return this;\n  } // Calculate the sum of the exponents of all the ticks in this voice to use as the denominator\n  // of softmax.\n\n\n  reCalculateExpTicksUsed() {\n    const totalTicks = this.ticksUsed.value();\n\n    const exp = tickable => Math.pow(this.options.softmaxFactor, tickable.getTicks().value() / totalTicks);\n\n    this.expTicksUsed = this.tickables.map(exp).reduce((a, b) => a + b);\n    return this.expTicksUsed;\n  } // Get the softmax-scaled value of a tick duration. 'tickValue' is a number.\n\n\n  softmax(tickValue) {\n    if (!this.expTicksUsed) {\n      this.reCalculateExpTicksUsed();\n    }\n\n    const totalTicks = this.ticksUsed.value();\n\n    const exp = v => Math.pow(this.options.softmaxFactor, v / totalTicks);\n\n    return exp(tickValue) / this.expTicksUsed;\n  } // Add a tickable to the voice\n\n\n  addTickable(tickable) {\n    if (!tickable.shouldIgnoreTicks()) {\n      const ticks = tickable.getTicks(); // Update the total ticks for this line.\n\n      this.ticksUsed.add(ticks);\n\n      if ((this.mode === Voice.Mode.STRICT || this.mode === Voice.Mode.FULL) && this.ticksUsed.greaterThan(this.totalTicks)) {\n        this.ticksUsed.subtract(ticks);\n        throw new Vex.RERR('BadArgument', 'Too many ticks.');\n      } // Track the smallest tickable for formatting.\n\n\n      if (ticks.lessThan(this.smallestTickCount)) {\n        this.smallestTickCount = ticks.clone();\n      }\n\n      this.resolutionMultiplier = this.ticksUsed.denominator; // Expand total ticks using denominator from ticks used.\n\n      this.totalTicks.add(0, this.ticksUsed.denominator);\n    } // Add the tickable to the line.\n\n\n    this.tickables.push(tickable);\n    tickable.setVoice(this);\n    return this;\n  } // Add an array of tickables to the voice.\n\n\n  addTickables(tickables) {\n    for (let i = 0; i < tickables.length; ++i) {\n      this.addTickable(tickables[i]);\n    }\n\n    return this;\n  } // Preformats the voice by applying the voice's stave to each note.\n\n\n  preFormat() {\n    if (this.preFormatted) return this;\n    this.tickables.forEach(tickable => {\n      if (!tickable.getStave()) {\n        tickable.setStave(this.stave);\n      }\n    });\n    this.preFormatted = true;\n    return this;\n  } // Render the voice onto the canvas `context` and an optional `stave`.\n  // If `stave` is omitted, it is expected that the notes have staves\n  // already set.\n\n\n  draw(context = this.context, stave = this.stave) {\n    this.setRendered();\n    let boundingBox = null;\n\n    for (let i = 0; i < this.tickables.length; ++i) {\n      const tickable = this.tickables[i]; // Set the stave if provided\n\n      if (stave) tickable.setStave(stave);\n\n      if (!tickable.getStave()) {\n        throw new Vex.RuntimeError('MissingStave', 'The voice cannot draw tickables without staves.');\n      }\n\n      if (i === 0) boundingBox = tickable.getBoundingBox();\n\n      if (i > 0 && boundingBox) {\n        const tickable_bb = tickable.getBoundingBox();\n        if (tickable_bb) boundingBox.mergeWith(tickable_bb);\n      }\n\n      tickable.setContext(context);\n      tickable.drawWithStyle();\n    }\n\n    this.boundingBox = boundingBox;\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/voice.js"],"names":["Vex","Element","Flow","Fraction","Voice","Mode","STRICT","SOFT","FULL","constructor","time","options","setAttribute","softmaxFactor","match","num_beats","beat_value","resolution","RESOLUTION","Merge","totalTicks","resolutionMultiplier","tickables","ticksUsed","smallestTickCount","clone","largestTickWidth","stave","mode","voiceGroup","getTotalTicks","getTicksUsed","getLargestTickWidth","getSmallestTickCount","getTickables","getMode","setMode","getResolutionMultiplier","getActualResolution","setStave","boundingBox","getBoundingBox","bb","i","RERR","length","mergeWith","getVoiceGroup","setVoiceGroup","g","setStrict","strict","isComplete","equals","setSoftmaxFactor","factor","reCalculateExpTicksUsed","value","exp","tickable","Math","pow","getTicks","expTicksUsed","map","reduce","a","b","softmax","tickValue","v","addTickable","shouldIgnoreTicks","ticks","add","greaterThan","subtract","lessThan","denominator","push","setVoice","addTickables","preFormat","preFormatted","forEach","getStave","draw","context","setRendered","RuntimeError","tickable_bb","setContext","drawWithStyle"],"mappings":"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","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n//\n// This file implements the main Voice class. It's mainly a container\n// object to group `Tickables` for formatting.\n\nimport { Vex } from './vex';\nimport { Element } from './element';\nimport { Flow } from './tables';\nimport { Fraction } from './fraction';\n\nexport class Voice extends Element {\n  // Modes allow the addition of ticks in three different ways:\n  //\n  // STRICT: This is the default. Ticks must fill the voice.\n  // SOFT:   Ticks can be added without restrictions.\n  // FULL:   Ticks do not need to fill the voice, but can't exceed the maximum\n  //         tick length.\n  static get Mode() {\n    return {\n      STRICT: 1,\n      SOFT: 2,\n      FULL: 3,\n    };\n  }\n\n  constructor(time, options) {\n    super();\n    this.setAttribute('type', 'Voice');\n\n    this.options = {\n      softmaxFactor: 100,\n      ...options,\n    };\n\n    // Time signature shortcut: \"4/4\", \"3/8\", etc.\n    if (typeof(time) === 'string') {\n      const match = time.match(/(\\d+)\\/(\\d+)/);\n      if (match) {\n        time = {\n          num_beats: match[1],\n          beat_value: match[2],\n          resolution: Flow.RESOLUTION,\n        };\n      }\n    }\n\n    // Default time sig is 4/4\n    this.time = Vex.Merge({\n      num_beats: 4,\n      beat_value: 4,\n      resolution: Flow.RESOLUTION,\n    }, time);\n\n    // Recalculate total ticks.\n    this.totalTicks = new Fraction(\n      this.time.num_beats * (this.time.resolution / this.time.beat_value), 1);\n\n    this.resolutionMultiplier = 1;\n\n    // Set defaults\n    this.tickables = [];\n    this.ticksUsed = new Fraction(0, 1);\n    this.smallestTickCount = this.totalTicks.clone();\n    this.largestTickWidth = 0;\n    this.stave = null;\n    // Do we care about strictly timed notes\n    this.mode = Voice.Mode.STRICT;\n\n    // This must belong to a VoiceGroup\n    this.voiceGroup = null;\n  }\n\n  // Get the total ticks in the voice\n  getTotalTicks() { return this.totalTicks; }\n\n  // Get the total ticks used in the voice by all the tickables\n  getTicksUsed() { return this.ticksUsed; }\n\n  // Get the largest width of all the tickables\n  getLargestTickWidth() { return this.largestTickWidth; }\n\n  // Get the tick count for the shortest tickable\n  getSmallestTickCount() { return this.smallestTickCount; }\n\n  // Get the tickables in the voice\n  getTickables() { return this.tickables; }\n\n  // Get/set the voice mode, use a value from `Voice.Mode`\n  getMode() { return this.mode; }\n  setMode(mode) { this.mode = mode; return this; }\n\n  // Get the resolution multiplier for the voice\n  getResolutionMultiplier() { return this.resolutionMultiplier; }\n\n  // Get the actual tick resolution for the voice\n  getActualResolution() { return this.resolutionMultiplier * this.time.resolution; }\n\n  // Set the voice's stave\n  setStave(stave) {\n    this.stave = stave;\n    this.boundingBox = null; // Reset bounding box so we can reformat\n    return this;\n  }\n\n  // Get the bounding box for the voice\n  getBoundingBox() {\n    let stave;\n    let boundingBox;\n    let bb;\n    let i;\n\n    if (!this.boundingBox) {\n      if (!this.stave) throw new Vex.RERR('NoStave', \"Can't get bounding box without stave.\");\n      stave = this.stave;\n      boundingBox = null;\n\n      for (i = 0; i < this.tickables.length; ++i) {\n        this.tickables[i].setStave(stave);\n\n        bb = this.tickables[i].getBoundingBox();\n        if (!bb) continue;\n\n        boundingBox = boundingBox ? boundingBox.mergeWith(bb) : bb;\n      }\n\n      this.boundingBox = boundingBox;\n    }\n    return this.boundingBox;\n  }\n\n  // Every tickable must be associated with a voiceGroup. This allows formatters\n  // and preformatters to associate them with the right modifierContexts.\n  getVoiceGroup() {\n    if (!this.voiceGroup) {\n      throw new Vex.RERR('NoVoiceGroup', 'No voice group for voice.');\n    }\n\n    return this.voiceGroup;\n  }\n\n  // Set the voice group\n  setVoiceGroup(g) { this.voiceGroup = g; return this; }\n\n  // Set the voice mode to strict or soft\n  setStrict(strict) {\n    this.mode = strict ? Voice.Mode.STRICT : Voice.Mode.SOFT;\n    return this;\n  }\n\n  // Determine if the voice is complete according to the voice mode\n  isComplete() {\n    if (this.mode === Voice.Mode.STRICT || this.mode === Voice.Mode.FULL) {\n      return this.ticksUsed.equals(this.totalTicks);\n    } else {\n      return true;\n    }\n  }\n\n  // We use softmax to layout the tickables proportional to the exponent of\n  // their duration. The softmax factor is used to determine the 'linearness' of\n  // the layout.\n  //\n  // The softmax of all the tickables in this voice should sum to 1.\n  setSoftmaxFactor(factor) {\n    this.options.softmaxFactor = factor;\n    return this;\n  }\n\n  // Calculate the sum of the exponents of all the ticks in this voice to use as the denominator\n  // of softmax.\n  reCalculateExpTicksUsed() {\n    const totalTicks = this.ticksUsed.value();\n    const exp = (tickable) => Math.pow(this.options.softmaxFactor, tickable.getTicks().value() / totalTicks);\n    this.expTicksUsed = this.tickables.map(exp).reduce((a, b) => a + b);\n    return this.expTicksUsed;\n  }\n\n  // Get the softmax-scaled value of a tick duration. 'tickValue' is a number.\n  softmax(tickValue) {\n    if (!this.expTicksUsed) {\n      this.reCalculateExpTicksUsed();\n    }\n\n    const totalTicks = this.ticksUsed.value();\n    const exp = (v) => Math.pow(this.options.softmaxFactor, v / totalTicks);\n    return exp(tickValue) / this.expTicksUsed;\n  }\n\n  // Add a tickable to the voice\n  addTickable(tickable) {\n    if (!tickable.shouldIgnoreTicks()) {\n      const ticks = tickable.getTicks();\n\n      // Update the total ticks for this line.\n      this.ticksUsed.add(ticks);\n\n      if (\n        (this.mode === Voice.Mode.STRICT || this.mode === Voice.Mode.FULL) &&\n        this.ticksUsed.greaterThan(this.totalTicks)\n      ) {\n        this.ticksUsed.subtract(ticks);\n        throw new Vex.RERR('BadArgument', 'Too many ticks.');\n      }\n\n      // Track the smallest tickable for formatting.\n      if (ticks.lessThan(this.smallestTickCount)) {\n        this.smallestTickCount = ticks.clone();\n      }\n\n      this.resolutionMultiplier = this.ticksUsed.denominator;\n\n      // Expand total ticks using denominator from ticks used.\n      this.totalTicks.add(0, this.ticksUsed.denominator);\n    }\n\n    // Add the tickable to the line.\n    this.tickables.push(tickable);\n    tickable.setVoice(this);\n    return this;\n  }\n\n  // Add an array of tickables to the voice.\n  addTickables(tickables) {\n    for (let i = 0; i < tickables.length; ++i) {\n      this.addTickable(tickables[i]);\n    }\n\n    return this;\n  }\n\n  // Preformats the voice by applying the voice's stave to each note.\n  preFormat() {\n    if (this.preFormatted) return this;\n\n    this.tickables.forEach((tickable) => {\n      if (!tickable.getStave()) {\n        tickable.setStave(this.stave);\n      }\n    });\n\n    this.preFormatted = true;\n    return this;\n  }\n\n  // Render the voice onto the canvas `context` and an optional `stave`.\n  // If `stave` is omitted, it is expected that the notes have staves\n  // already set.\n  draw(context = this.context, stave = this.stave) {\n    this.setRendered();\n    let boundingBox = null;\n    for (let i = 0; i < this.tickables.length; ++i) {\n      const tickable = this.tickables[i];\n\n      // Set the stave if provided\n      if (stave) tickable.setStave(stave);\n\n      if (!tickable.getStave()) {\n        throw new Vex.RuntimeError(\n          'MissingStave', 'The voice cannot draw tickables without staves.'\n        );\n      }\n\n      if (i === 0) boundingBox = tickable.getBoundingBox();\n\n      if (i > 0 && boundingBox) {\n        const tickable_bb = tickable.getBoundingBox();\n        if (tickable_bb) boundingBox.mergeWith(tickable_bb);\n      }\n\n      tickable.setContext(context);\n      tickable.drawWithStyle();\n    }\n\n    this.boundingBox = boundingBox;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}