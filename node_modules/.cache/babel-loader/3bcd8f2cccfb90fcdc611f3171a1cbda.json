{"ast":null,"code":"// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n// This class by Raffaele Viglianti, 2012 http://itisnotsound.wordpress.com/\n//\n// This class implements hairpins between notes.\n// Hairpins can be either Crescendo or Descrescendo.\nimport { Vex } from './vex';\nimport { Element } from './element';\nimport { Modifier } from './modifier';\nexport class StaveHairpin extends Element {\n  static get type() {\n    return {\n      CRESC: 1,\n      DECRESC: 2\n    };\n  }\n  /* Helper function to convert ticks into pixels.\n   * Requires a Formatter with voices joined and formatted (to\n   * get pixels per tick)\n   *\n   * options is struct that has:\n   *\n   *  {\n   *   height: px,\n   *   y_shift: px, //vertical offset\n   *   left_shift_ticks: 0, //left horizontal offset expressed in ticks\n   *   right_shift_ticks: 0 // right horizontal offset expressed in ticks\n   *  }\n   *\n   **/\n\n\n  static FormatByTicksAndDraw(ctx, formatter, notes, type, position, options) {\n    const ppt = formatter.pixelsPerTick;\n\n    if (ppt == null) {\n      throw new Vex.RuntimeError('BadArguments', 'A valid Formatter must be provide to draw offsets by ticks.');\n    }\n\n    const l_shift_px = ppt * options.left_shift_ticks;\n    const r_shift_px = ppt * options.right_shift_ticks;\n    const hairpin_options = {\n      height: options.height,\n      y_shift: options.y_shift,\n      left_shift_px: l_shift_px,\n      right_shift_px: r_shift_px\n    };\n    new StaveHairpin({\n      first_note: notes.first_note,\n      last_note: notes.last_note\n    }, type).setContext(ctx).setRenderOptions(hairpin_options).setPosition(position).draw();\n  }\n  /**\n   * Create a new hairpin from the specified notes.\n   *\n   * @constructor\n   * @param {!Object} notes The notes to tie up.\n   * @param {!Object} type The type of hairpin\n   */\n\n\n  constructor(notes, type) {\n    /**\n     * Notes is a struct that has:\n     *\n     *  {\n     *    first_note: Note,\n     *    last_note: Note,\n     *  }\n     *\n     **/\n    super();\n    this.setAttribute('type', 'StaveHairpin');\n    this.notes = notes;\n    this.hairpin = type;\n    this.position = Modifier.Position.BELOW;\n    this.render_options = {\n      height: 10,\n      y_shift: 0,\n      // vertical offset\n      left_shift_px: 0,\n      // left horizontal offset\n      right_shift_px: 0 // right horizontal offset\n\n    };\n    this.setNotes(notes);\n  }\n\n  setPosition(position) {\n    if (position === Modifier.Position.ABOVE || position === Modifier.Position.BELOW) {\n      this.position = position;\n    }\n\n    return this;\n  }\n\n  setRenderOptions(options) {\n    if (options.height != null && options.y_shift != null && options.left_shift_px != null && options.right_shift_px != null) {\n      this.render_options = options;\n    }\n\n    return this;\n  }\n  /**\n   * Set the notes to attach this hairpin to.\n   *\n   * @param {!Object} notes The start and end notes.\n   */\n\n\n  setNotes(notes) {\n    if (!notes.first_note && !notes.last_note) {\n      throw new Vex.RuntimeError('BadArguments', 'Hairpin needs to have either first_note or last_note set.');\n    } // Success. Lets grab 'em notes.\n\n\n    this.first_note = notes.first_note;\n    this.last_note = notes.last_note;\n    return this;\n  }\n\n  renderHairpin(params) {\n    const ctx = this.checkContext();\n    let dis = this.render_options.y_shift + 20;\n    let y_shift = params.first_y;\n\n    if (this.position === Modifier.Position.ABOVE) {\n      dis = -dis + 30;\n      y_shift = params.first_y - params.staff_height;\n    }\n\n    const l_shift = this.render_options.left_shift_px;\n    const r_shift = this.render_options.right_shift_px;\n    ctx.beginPath();\n\n    switch (this.hairpin) {\n      case StaveHairpin.type.CRESC:\n        ctx.moveTo(params.last_x + r_shift, y_shift + dis);\n        ctx.lineTo(params.first_x + l_shift, y_shift + this.render_options.height / 2 + dis);\n        ctx.lineTo(params.last_x + r_shift, y_shift + this.render_options.height + dis);\n        break;\n\n      case StaveHairpin.type.DECRESC:\n        ctx.moveTo(params.first_x + l_shift, y_shift + dis);\n        ctx.lineTo(params.last_x + r_shift, y_shift + this.render_options.height / 2 + dis);\n        ctx.lineTo(params.first_x + l_shift, y_shift + this.render_options.height + dis);\n        break;\n\n      default:\n        // Default is NONE, so nothing to draw\n        break;\n    }\n\n    ctx.stroke();\n    ctx.closePath();\n  }\n\n  draw() {\n    this.checkContext();\n    this.setRendered();\n    const firstNote = this.first_note;\n    const lastNote = this.last_note;\n    const start = firstNote.getModifierStartXY(this.position, 0);\n    const end = lastNote.getModifierStartXY(this.position, 0);\n    this.renderHairpin({\n      first_x: start.x,\n      last_x: end.x,\n      first_y: firstNote.getStave().y + firstNote.getStave().height,\n      last_y: lastNote.getStave().y + lastNote.getStave().height,\n      staff_height: firstNote.getStave().height\n    });\n    return true;\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/stavehairpin.js"],"names":["Vex","Element","Modifier","StaveHairpin","type","CRESC","DECRESC","FormatByTicksAndDraw","ctx","formatter","notes","position","options","ppt","pixelsPerTick","RuntimeError","l_shift_px","left_shift_ticks","r_shift_px","right_shift_ticks","hairpin_options","height","y_shift","left_shift_px","right_shift_px","first_note","last_note","setContext","setRenderOptions","setPosition","draw","constructor","setAttribute","hairpin","Position","BELOW","render_options","setNotes","ABOVE","renderHairpin","params","checkContext","dis","first_y","staff_height","l_shift","r_shift","beginPath","moveTo","last_x","lineTo","first_x","stroke","closePath","setRendered","firstNote","lastNote","start","getModifierStartXY","end","x","getStave","y","last_y"],"mappings":"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","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n// This class by Raffaele Viglianti, 2012 http://itisnotsound.wordpress.com/\n//\n// This class implements hairpins between notes.\n// Hairpins can be either Crescendo or Descrescendo.\n\nimport { Vex } from './vex';\nimport { Element } from './element';\nimport { Modifier } from './modifier';\n\nexport class StaveHairpin extends Element {\n  static get type() {\n    return {\n      CRESC: 1,\n      DECRESC: 2,\n    };\n  }\n\n  /* Helper function to convert ticks into pixels.\n   * Requires a Formatter with voices joined and formatted (to\n   * get pixels per tick)\n   *\n   * options is struct that has:\n   *\n   *  {\n   *   height: px,\n   *   y_shift: px, //vertical offset\n   *   left_shift_ticks: 0, //left horizontal offset expressed in ticks\n   *   right_shift_ticks: 0 // right horizontal offset expressed in ticks\n   *  }\n   *\n   **/\n  static FormatByTicksAndDraw(ctx, formatter, notes, type, position, options) {\n    const ppt = formatter.pixelsPerTick;\n\n    if (ppt == null) {\n      throw new Vex.RuntimeError(\n        'BadArguments',\n        'A valid Formatter must be provide to draw offsets by ticks.'\n      );\n    }\n\n    const l_shift_px = ppt * options.left_shift_ticks;\n    const r_shift_px = ppt * options.right_shift_ticks;\n\n    const hairpin_options = {\n      height: options.height,\n      y_shift: options.y_shift,\n      left_shift_px: l_shift_px,\n      right_shift_px: r_shift_px };\n\n    new StaveHairpin({\n      first_note: notes.first_note,\n      last_note: notes.last_note,\n    }, type)\n      .setContext(ctx)\n      .setRenderOptions(hairpin_options)\n      .setPosition(position)\n      .draw();\n  }\n\n  /**\n   * Create a new hairpin from the specified notes.\n   *\n   * @constructor\n   * @param {!Object} notes The notes to tie up.\n   * @param {!Object} type The type of hairpin\n   */\n  constructor(notes, type) {\n    /**\n     * Notes is a struct that has:\n     *\n     *  {\n     *    first_note: Note,\n     *    last_note: Note,\n     *  }\n     *\n     **/\n    super();\n    this.setAttribute('type', 'StaveHairpin');\n    this.notes = notes;\n    this.hairpin = type;\n    this.position = Modifier.Position.BELOW;\n\n    this.render_options = {\n      height: 10,\n      y_shift: 0, // vertical offset\n      left_shift_px: 0, // left horizontal offset\n      right_shift_px: 0, // right horizontal offset\n    };\n\n    this.setNotes(notes);\n  }\n\n  setPosition(position) {\n    if (position === Modifier.Position.ABOVE || position === Modifier.Position.BELOW) {\n      this.position = position;\n    }\n    return this;\n  }\n\n  setRenderOptions(options) {\n    if (\n      options.height != null &&\n      options.y_shift != null &&\n      options.left_shift_px != null &&\n      options.right_shift_px != null\n    ) {\n      this.render_options = options;\n    }\n    return this;\n  }\n\n  /**\n   * Set the notes to attach this hairpin to.\n   *\n   * @param {!Object} notes The start and end notes.\n   */\n  setNotes(notes) {\n    if (!notes.first_note && !notes.last_note) {\n      throw new Vex.RuntimeError(\n        'BadArguments',\n        'Hairpin needs to have either first_note or last_note set.'\n      );\n    }\n\n    // Success. Lets grab 'em notes.\n    this.first_note = notes.first_note;\n    this.last_note = notes.last_note;\n    return this;\n  }\n\n  renderHairpin(params) {\n    const ctx = this.checkContext();\n    let dis = this.render_options.y_shift + 20;\n    let y_shift = params.first_y;\n\n    if (this.position === Modifier.Position.ABOVE) {\n      dis = -dis + 30;\n      y_shift = params.first_y - params.staff_height;\n    }\n\n    const l_shift = this.render_options.left_shift_px;\n    const r_shift = this.render_options.right_shift_px;\n\n    ctx.beginPath();\n\n    switch (this.hairpin) {\n      case StaveHairpin.type.CRESC:\n        ctx.moveTo(params.last_x + r_shift, y_shift + dis);\n        ctx.lineTo(params.first_x + l_shift, y_shift + (this.render_options.height / 2) + dis);\n        ctx.lineTo(params.last_x + r_shift, y_shift + this.render_options.height + dis);\n        break;\n      case StaveHairpin.type.DECRESC:\n        ctx.moveTo(params.first_x + l_shift, y_shift + dis);\n        ctx.lineTo(params.last_x + r_shift, y_shift + (this.render_options.height / 2) + dis);\n        ctx.lineTo(params.first_x + l_shift, y_shift + this.render_options.height + dis);\n        break;\n      default:\n        // Default is NONE, so nothing to draw\n        break;\n    }\n\n    ctx.stroke();\n    ctx.closePath();\n  }\n\n  draw() {\n    this.checkContext();\n    this.setRendered();\n\n    const firstNote = this.first_note;\n    const lastNote = this.last_note;\n\n    const start = firstNote.getModifierStartXY(this.position, 0);\n    const end = lastNote.getModifierStartXY(this.position, 0);\n\n    this.renderHairpin({\n      first_x: start.x,\n      last_x: end.x,\n      first_y: firstNote.getStave().y + firstNote.getStave().height,\n      last_y: lastNote.getStave().y + lastNote.getStave().height,\n      staff_height: firstNote.getStave().height,\n    });\n    return true;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}