{"ast":null,"code":"// VexFlow - Music Engraving for HTML5\n// Copyright Mohit Muthanna 2010\n//\n// This class implements dot modifiers for notes.\nimport { Vex } from './vex';\nimport { Modifier } from './modifier';\nexport class Dot extends Modifier {\n  static get CATEGORY() {\n    return 'dots';\n  } // Arrange dots inside a ModifierContext.\n\n\n  static format(dots, state) {\n    const right_shift = state.right_shift;\n    const dot_spacing = 1;\n    if (!dots || dots.length === 0) return false;\n    const dot_list = [];\n    const max_shift_map = {};\n\n    for (let i = 0; i < dots.length; ++i) {\n      const dot = dots[i];\n      const note = dot.getNote();\n      let props;\n      let shift; // Only StaveNote has .getKeyProps()\n\n      if (typeof note.getKeyProps === 'function') {\n        props = note.getKeyProps()[dot.getIndex()];\n        shift = note.getRightDisplacedHeadPx();\n      } else {\n        // Else it's a TabNote\n        props = {\n          line: 0.5\n        }; // Shim key props for dot placement\n\n        shift = 0;\n      }\n\n      const note_id = note.getAttribute('id');\n      dot_list.push({\n        line: props.line,\n        note,\n        note_id,\n        dot\n      });\n      max_shift_map[note_id] = Math.max(max_shift_map[note_id] || shift, shift);\n    } // Sort dots by line number.\n\n\n    dot_list.sort((a, b) => b.line - a.line);\n    let dot_shift = right_shift;\n    let x_width = 0;\n    let last_line = null;\n    let last_note = null;\n    let prev_dotted_space = null;\n    let half_shiftY = 0;\n\n    for (let i = 0; i < dot_list.length; ++i) {\n      const {\n        dot,\n        note,\n        note_id,\n        line\n      } = dot_list[i]; // Reset the position of the dot every line.\n\n      if (line !== last_line || note !== last_note) {\n        dot_shift = max_shift_map[note_id];\n      }\n\n      if (!note.isRest() && line !== last_line) {\n        if (Math.abs(line % 1) === 0.5) {\n          // note is on a space, so no dot shift\n          half_shiftY = 0;\n        } else {\n          // note is on a line, so shift dot to space above the line\n          half_shiftY = 0.5;\n\n          if (last_note != null && !last_note.isRest() && last_line - line === 0.5) {\n            // previous note on a space, so shift dot to space below the line\n            half_shiftY = -0.5;\n          } else if (line + half_shiftY === prev_dotted_space) {\n            // previous space is dotted, so shift dot to space below the line\n            half_shiftY = -0.5;\n          }\n        }\n      } // convert half_shiftY to a multiplier for dots.draw()\n\n\n      if (note.isRest()) {\n        dot.dot_shiftY += -half_shiftY;\n      } else {\n        dot.dot_shiftY = -half_shiftY;\n      }\n\n      prev_dotted_space = line + half_shiftY;\n      dot.setXShift(dot_shift);\n      dot_shift += dot.getWidth() + dot_spacing; // spacing\n\n      x_width = dot_shift > x_width ? dot_shift : x_width;\n      last_line = line;\n      last_note = note;\n    } // Update state.\n\n\n    state.right_shift += x_width;\n    return true;\n  }\n  /**\n   * @constructor\n   */\n\n\n  constructor() {\n    super();\n    this.setAttribute('type', 'Dot');\n    this.note = null;\n    this.index = null;\n    this.position = Modifier.Position.RIGHT;\n    this.radius = 2;\n    this.setWidth(5);\n    this.dot_shiftY = 0;\n  }\n\n  getCategory() {\n    return Dot.CATEGORY;\n  }\n\n  setNote(note) {\n    this.note = note;\n\n    if (this.note.getCategory() === 'gracenotes') {\n      this.radius *= 0.50;\n      this.setWidth(3);\n    }\n  }\n\n  setDotShiftY(y) {\n    this.dot_shiftY = y;\n    return this;\n  }\n\n  draw() {\n    this.checkContext();\n    this.setRendered();\n\n    if (!this.note || this.index === null) {\n      throw new Vex.RERR('NoAttachedNote', \"Can't draw dot without a note and index.\");\n    }\n\n    const lineSpace = this.note.stave.options.spacing_between_lines_px;\n    const start = this.note.getModifierStartXY(this.position, this.index, {\n      forceFlagRight: true\n    }); // Set the starting y coordinate to the base of the stem for TabNotes\n\n    if (this.note.getCategory() === 'tabnotes') {\n      start.y = this.note.getStemExtents().baseY;\n    }\n\n    const x = start.x + this.x_shift + this.width - this.radius;\n    const y = start.y + this.y_shift + this.dot_shiftY * lineSpace;\n    const ctx = this.context;\n    ctx.beginPath();\n    ctx.arc(x, y, this.radius, 0, Math.PI * 2, false);\n    ctx.fill();\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/dot.js"],"names":["Vex","Modifier","Dot","CATEGORY","format","dots","state","right_shift","dot_spacing","length","dot_list","max_shift_map","i","dot","note","getNote","props","shift","getKeyProps","getIndex","getRightDisplacedHeadPx","line","note_id","getAttribute","push","Math","max","sort","a","b","dot_shift","x_width","last_line","last_note","prev_dotted_space","half_shiftY","isRest","abs","dot_shiftY","setXShift","getWidth","constructor","setAttribute","index","position","Position","RIGHT","radius","setWidth","getCategory","setNote","setDotShiftY","y","draw","checkContext","setRendered","RERR","lineSpace","stave","options","spacing_between_lines_px","start","getModifierStartXY","forceFlagRight","getStemExtents","baseY","x","x_shift","width","y_shift","ctx","context","beginPath","arc","PI","fill"],"mappings":"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","sourcesContent":["// VexFlow - Music Engraving for HTML5\n// Copyright Mohit Muthanna 2010\n//\n// This class implements dot modifiers for notes.\n\nimport { Vex } from './vex';\nimport { Modifier } from './modifier';\n\nexport class Dot extends Modifier {\n  static get CATEGORY() { return 'dots'; }\n\n  // Arrange dots inside a ModifierContext.\n  static format(dots, state) {\n    const right_shift = state.right_shift;\n    const dot_spacing = 1;\n\n    if (!dots || dots.length === 0) return false;\n\n    const dot_list = [];\n    const max_shift_map = {};\n    for (let i = 0; i < dots.length; ++i) {\n      const dot = dots[i];\n      const note = dot.getNote();\n\n      let props;\n      let shift;\n\n      // Only StaveNote has .getKeyProps()\n      if (typeof note.getKeyProps === 'function') {\n        props = note.getKeyProps()[dot.getIndex()];\n        shift = note.getRightDisplacedHeadPx();\n      } else { // Else it's a TabNote\n        props = { line: 0.5 }; // Shim key props for dot placement\n        shift = 0;\n      }\n\n      const note_id = note.getAttribute('id');\n      dot_list.push({ line: props.line, note, note_id, dot });\n      max_shift_map[note_id] = Math.max(max_shift_map[note_id] || shift, shift);\n    }\n\n    // Sort dots by line number.\n    dot_list.sort((a, b) => b.line - a.line);\n\n    let dot_shift = right_shift;\n    let x_width = 0;\n    let last_line = null;\n    let last_note = null;\n    let prev_dotted_space = null;\n    let half_shiftY = 0;\n\n    for (let i = 0; i < dot_list.length; ++i) {\n      const { dot, note, note_id, line } = dot_list[i];\n\n      // Reset the position of the dot every line.\n      if (line !== last_line || note !== last_note) {\n        dot_shift = max_shift_map[note_id];\n      }\n\n      if (!note.isRest() && line !== last_line) {\n        if (Math.abs(line % 1) === 0.5) {\n          // note is on a space, so no dot shift\n          half_shiftY = 0;\n        } else {\n          // note is on a line, so shift dot to space above the line\n          half_shiftY = 0.5;\n          if (last_note != null &&\n              !last_note.isRest() && last_line - line === 0.5) {\n            // previous note on a space, so shift dot to space below the line\n            half_shiftY = -0.5;\n          } else if (line + half_shiftY === prev_dotted_space) {\n            // previous space is dotted, so shift dot to space below the line\n            half_shiftY = -0.5;\n          }\n        }\n      }\n\n      // convert half_shiftY to a multiplier for dots.draw()\n      if (note.isRest()) {\n        dot.dot_shiftY += -half_shiftY;\n      } else {\n        dot.dot_shiftY = -half_shiftY;\n      }\n      prev_dotted_space = line + half_shiftY;\n\n      dot.setXShift(dot_shift);\n      dot_shift += dot.getWidth() + dot_spacing; // spacing\n      x_width = (dot_shift > x_width) ? dot_shift : x_width;\n      last_line = line;\n      last_note = note;\n    }\n\n    // Update state.\n    state.right_shift += x_width;\n    return true;\n  }\n\n  /**\n   * @constructor\n   */\n  constructor() {\n    super();\n    this.setAttribute('type', 'Dot');\n\n    this.note = null;\n    this.index = null;\n    this.position = Modifier.Position.RIGHT;\n\n    this.radius = 2;\n    this.setWidth(5);\n    this.dot_shiftY = 0;\n  }\n\n  getCategory() { return Dot.CATEGORY; }\n\n  setNote(note) {\n    this.note = note;\n\n    if (this.note.getCategory() === 'gracenotes') {\n      this.radius *= 0.50;\n      this.setWidth(3);\n    }\n  }\n\n  setDotShiftY(y) { this.dot_shiftY = y; return this; }\n\n  draw() {\n    this.checkContext();\n    this.setRendered();\n\n    if (!this.note || this.index === null) {\n      throw new Vex.RERR('NoAttachedNote', \"Can't draw dot without a note and index.\");\n    }\n\n    const lineSpace = this.note.stave.options.spacing_between_lines_px;\n\n    const start = this.note.getModifierStartXY(this.position, this.index,\n      { forceFlagRight: true });\n\n    // Set the starting y coordinate to the base of the stem for TabNotes\n    if (this.note.getCategory() === 'tabnotes') {\n      start.y = this.note.getStemExtents().baseY;\n    }\n\n    const x = (start.x + this.x_shift) + this.width - this.radius;\n    const y = start.y + this.y_shift + (this.dot_shiftY * lineSpace);\n    const ctx = this.context;\n\n    ctx.beginPath();\n    ctx.arc(x, y, this.radius, 0, Math.PI * 2, false);\n    ctx.fill();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}