{"ast":null,"code":"// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n// @author Mohit Cheppudira\n// @author Greg Ristow (modifications)\n//\n// ## Description\n//\n// This file implements accidentals as modifiers that can be attached to\n// notes. Support is included for both western and microtonal accidentals.\n//\n// See `tests/accidental_tests.js` for usage examples.\nimport { Vex } from './vex';\nimport { Fraction } from './fraction';\nimport { Flow } from './tables';\nimport { Music } from './music';\nimport { Modifier } from './modifier';\nimport { Glyph } from './glyph'; // To enable logging for this class. Set `Vex.Flow.Accidental.DEBUG` to `true`.\n\nfunction L(...args) {\n  if (Accidental.DEBUG) Vex.L('Vex.Flow.Accidental', args);\n}\n\nconst getGlyphWidth = glyph => glyph.getMetrics().width; // An `Accidental` inherits from `Modifier`, and is formatted within a\n// `ModifierContext`.\n\n\nexport class Accidental extends Modifier {\n  static get CATEGORY() {\n    return 'accidentals';\n  } // Arrange accidentals inside a ModifierContext.\n\n\n  static format(accidentals, state) {\n    const noteheadAccidentalPadding = 1;\n    const leftShift = state.left_shift + noteheadAccidentalPadding;\n    const accidentalSpacing = 3; // If there are no accidentals, we needn't format their positions\n\n    if (!accidentals || accidentals.length === 0) return;\n    const accList = [];\n    let prevNote = null;\n    let shiftL = 0; // First determine the accidentals' Y positions from the note.keys\n\n    for (let i = 0; i < accidentals.length; ++i) {\n      const acc = accidentals[i];\n      const note = acc.getNote();\n      const stave = note.getStave();\n      const props = note.getKeyProps()[acc.getIndex()];\n\n      if (note !== prevNote) {\n        // Iterate through all notes to get the displaced pixels\n        for (let n = 0; n < note.keys.length; ++n) {\n          shiftL = Math.max(note.getLeftDisplacedHeadPx(), shiftL);\n        }\n\n        prevNote = note;\n      }\n\n      if (stave !== null) {\n        const lineSpace = stave.options.spacing_between_lines_px;\n        const y = stave.getYForLine(props.line);\n        const accLine = Math.round(y / lineSpace * 2) / 2;\n        accList.push({\n          y,\n          line: accLine,\n          shift: shiftL,\n          acc,\n          lineSpace\n        });\n      } else {\n        accList.push({\n          line: props.line,\n          shift: shiftL,\n          acc\n        });\n      }\n    } // Sort accidentals by line number.\n\n\n    accList.sort((a, b) => b.line - a.line); // FIXME: Confusing name. Each object in this array has a property called `line`.\n    // So if this is a list of lines, you end up with: `line.line` which is very awkward.\n\n    const lineList = []; // amount by which all accidentals must be shifted right or left for\n    // stem flipping, notehead shifting concerns.\n\n    let accShift = 0;\n    let previousLine = null; // Create an array of unique line numbers (lineList) from accList\n\n    for (let i = 0; i < accList.length; i++) {\n      const acc = accList[i]; // if this is the first line, or a new line, add a lineList\n\n      if (previousLine === null || previousLine !== acc.line) {\n        lineList.push({\n          line: acc.line,\n          flatLine: true,\n          dblSharpLine: true,\n          numAcc: 0,\n          width: 0\n        });\n      } // if this accidental is not a flat, the accidental needs 3.0 lines lower\n      // clearance instead of 2.5 lines for b or bb.\n      // FIXME: Naming could use work. acc.acc is very awkward\n\n\n      if (acc.acc.type !== 'b' && acc.acc.type !== 'bb') {\n        lineList[lineList.length - 1].flatLine = false;\n      } // if this accidental is not a double sharp, the accidental needs 3.0 lines above\n\n\n      if (acc.acc.type !== '##') {\n        lineList[lineList.length - 1].dblSharpLine = false;\n      } // Track how many accidentals are on this line:\n\n\n      lineList[lineList.length - 1].numAcc++; // Track the total x_offset needed for this line which will be needed\n      // for formatting lines w/ multiple accidentals:\n      // width = accidental width + universal spacing between accidentals\n\n      lineList[lineList.length - 1].width += acc.acc.getWidth() + accidentalSpacing; // if this accShift is larger, use it to keep first column accidentals in the same line\n\n      accShift = acc.shift > accShift ? acc.shift : accShift;\n      previousLine = acc.line;\n    } // ### Place Accidentals in Columns\n    //\n    // Default to a classic triangular layout (middle accidental farthest left),\n    // but follow exceptions as outlined in G. Read's _Music Notation_ and\n    // Elaine Gould's _Behind Bars_.\n    //\n    // Additionally, this implements different vertical collision rules for\n    // flats (only need 2.5 lines clearance below) and double sharps (only\n    // need 2.5 lines of clearance above or below).\n    //\n    // Classic layouts and exception patterns are found in the 'tables.js'\n    // in 'Vex.Flow.accidentalColumnsTable'\n    //\n    // Beyond 6 vertical accidentals, default to the parallel ascending lines approach,\n    // using as few columns as possible for the verticle structure.\n    //\n    // TODO (?): Allow column to be specified for an accidental at run-time?\n\n\n    let totalColumns = 0; // establish the boundaries for a group of notes with clashing accidentals:\n\n    for (let i = 0; i < lineList.length; i++) {\n      let noFurtherConflicts = false;\n      const groupStart = i;\n      let groupEnd = i;\n\n      while (groupEnd + 1 < lineList.length && !noFurtherConflicts) {\n        // if this note conflicts with the next:\n        if (this.checkCollision(lineList[groupEnd], lineList[groupEnd + 1])) {\n          // include the next note in the group:\n          groupEnd++;\n        } else {\n          noFurtherConflicts = true;\n        }\n      } // Gets an a line from the `lineList`, relative to the current group\n\n\n      const getGroupLine = index => lineList[groupStart + index];\n\n      const getGroupLines = indexes => indexes.map(getGroupLine);\n\n      const lineDifference = (indexA, indexB) => {\n        const [a, b] = getGroupLines([indexA, indexB]).map(item => item.line);\n        return a - b;\n      };\n\n      const notColliding = (...indexPairs) => indexPairs.map(getGroupLines).every(lines => !this.checkCollision(...lines)); // Set columns for the lines in this group:\n\n\n      const groupLength = groupEnd - groupStart + 1; // Set the accidental column for each line of the group\n\n      let endCase = this.checkCollision(lineList[groupStart], lineList[groupEnd]) ? 'a' : 'b';\n\n      switch (groupLength) {\n        case 3:\n          if (endCase === 'a' && lineDifference(1, 2) === 0.5 && lineDifference(0, 1) !== 0.5) {\n            endCase = 'second_on_bottom';\n          }\n\n          break;\n\n        case 4:\n          if (notColliding([0, 2], [1, 3])) {\n            endCase = 'spaced_out_tetrachord';\n          }\n\n          break;\n\n        case 5:\n          if (endCase === 'b' && notColliding([1, 3])) {\n            endCase = 'spaced_out_pentachord';\n\n            if (notColliding([0, 2], [2, 4])) {\n              endCase = 'very_spaced_out_pentachord';\n            }\n          }\n\n          break;\n\n        case 6:\n          if (notColliding([0, 3], [1, 4], [2, 5])) {\n            endCase = 'spaced_out_hexachord';\n          }\n\n          if (notColliding([0, 2], [2, 4], [1, 3], [3, 5])) {\n            endCase = 'very_spaced_out_hexachord';\n          }\n\n          break;\n\n        default:\n          break;\n      }\n\n      let groupMember;\n      let column; // If the group contains more than seven members, use ascending parallel lines\n      // of accidentals, using as few columns as possible while avoiding collisions.\n\n      if (groupLength >= 7) {\n        // First, determine how many columns to use:\n        let patternLength = 2;\n        let collisionDetected = true;\n\n        while (collisionDetected === true) {\n          collisionDetected = false;\n\n          for (let line = 0; line + patternLength < lineList.length; line++) {\n            if (this.checkCollision(lineList[line], lineList[line + patternLength])) {\n              collisionDetected = true;\n              patternLength++;\n              break;\n            }\n          }\n        } // Then, assign a column to each line of accidentals\n\n\n        for (groupMember = i; groupMember <= groupEnd; groupMember++) {\n          column = (groupMember - i) % patternLength + 1;\n          lineList[groupMember].column = column;\n          totalColumns = totalColumns > column ? totalColumns : column;\n        } // Otherwise, if the group contains fewer than seven members, use the layouts from\n        // the accidentalsColumnsTable housed in tables.js.\n\n      } else {\n        for (groupMember = i; groupMember <= groupEnd; groupMember++) {\n          column = Flow.accidentalColumnsTable[groupLength][endCase][groupMember - i];\n          lineList[groupMember].column = column;\n          totalColumns = totalColumns > column ? totalColumns : column;\n        }\n      } // Increment i to the last note that was set, so that if a lower set of notes\n      // does not conflict at all with this group, it can have its own classic shape.\n\n\n      i = groupEnd;\n    } // ### Convert Columns to x_offsets\n    //\n    // This keeps columns aligned, even if they have different accidentals within them\n    // which sometimes results in a larger x_offset than is an accidental might need\n    // to preserve the symmetry of the accidental shape.\n    //\n    // Neither A.C. Vinci nor G. Read address this, and it typically only happens in\n    // music with complex chord clusters.\n    //\n    // TODO (?): Optionally allow closer compression of accidentals, instead of forcing\n    // parallel columns.\n    // track each column's max width, which will be used as initial shift of later columns:\n\n\n    const columnWidths = [];\n    const columnXOffsets = [];\n\n    for (let i = 0; i <= totalColumns; i++) {\n      columnWidths[i] = 0;\n      columnXOffsets[i] = 0;\n    }\n\n    columnWidths[0] = accShift + leftShift;\n    columnXOffsets[0] = accShift + leftShift; // Fill columnWidths with widest needed x-space;\n    // this is what keeps the columns parallel.\n\n    lineList.forEach(line => {\n      if (line.width > columnWidths[line.column]) columnWidths[line.column] = line.width;\n    });\n\n    for (let i = 1; i < columnWidths.length; i++) {\n      // this column's offset = this column's width + previous column's offset\n      columnXOffsets[i] = columnWidths[i] + columnXOffsets[i - 1];\n    }\n\n    const totalShift = columnXOffsets[columnXOffsets.length - 1]; // Set the xShift for each accidental according to column offsets:\n\n    let accCount = 0;\n    lineList.forEach(line => {\n      let lineWidth = 0;\n      const lastAccOnLine = accCount + line.numAcc; // handle all of the accidentals on a given line:\n\n      for (accCount; accCount < lastAccOnLine; accCount++) {\n        const xShift = columnXOffsets[line.column - 1] + lineWidth;\n        accList[accCount].acc.setXShift(xShift); // keep track of the width of accidentals we've added so far, so that when\n        // we loop, we add space for them.\n\n        lineWidth += accList[accCount].acc.getWidth() + accidentalSpacing;\n        L('Line, accCount, shift: ', line.line, accCount, xShift);\n      }\n    }); // update the overall layout with the full width of the accidental shapes:\n\n    state.left_shift += totalShift;\n  } // Helper function to determine whether two lines of accidentals collide vertically\n\n\n  static checkCollision(line1, line2) {\n    let clearance = line2.line - line1.line;\n    let clearanceRequired = 3; // But less clearance is required for certain accidentals: b, bb and ##.\n\n    if (clearance > 0) {\n      // then line 2 is on top\n      clearanceRequired = line2.flatLine || line2.dblSharpLine ? 2.5 : 3.0;\n      if (line1.dblSharpLine) clearance -= 0.5;\n    } else {\n      // line 1 is on top\n      clearanceRequired = line1.flatLine || line1.dblSharpLine ? 2.5 : 3.0;\n      if (line2.dblSharpLine) clearance -= 0.5;\n    }\n\n    const collision = Math.abs(clearance) < clearanceRequired;\n    L('Line_1, Line_2, Collision: ', line1.line, line2.line, collision);\n    return collision;\n  } // Use this method to automatically apply accidentals to a set of `voices`.\n  // The accidentals will be remembered between all the voices provided.\n  // Optionally, you can also provide an initial `keySignature`.\n\n\n  static applyAccidentals(voices, keySignature) {\n    const tickPositions = [];\n    const tickNoteMap = {}; // Sort the tickables in each voice by their tick position in the voice\n\n    voices.forEach(voice => {\n      const tickPosition = new Fraction(0, 1);\n      const notes = voice.getTickables();\n      notes.forEach(note => {\n        if (note.shouldIgnoreTicks()) return;\n        const notesAtPosition = tickNoteMap[tickPosition.value()];\n\n        if (!notesAtPosition) {\n          tickPositions.push(tickPosition.value());\n          tickNoteMap[tickPosition.value()] = [note];\n        } else {\n          notesAtPosition.push(note);\n        }\n\n        tickPosition.add(note.getTicks());\n      });\n    });\n    const music = new Music(); // Default key signature is C major\n\n    if (!keySignature) keySignature = 'C'; // Get the scale map, which represents the current state of each pitch\n\n    const scaleMap = music.createScaleMap(keySignature);\n    tickPositions.forEach(tick => {\n      const notes = tickNoteMap[tick]; // Array to store all pitches that modified accidental states\n      // at this tick position\n\n      const modifiedPitches = [];\n\n      const processNote = note => {\n        if (note.isRest() || note.shouldIgnoreTicks()) return; // Go through each key and determine if an accidental should be\n        // applied\n\n        note.keys.forEach((keyString, keyIndex) => {\n          const key = music.getNoteParts(keyString.split('/')[0]); // Force a natural for every key without an accidental\n\n          const accidentalString = key.accidental || 'n';\n          const pitch = key.root + accidentalString; // Determine if the current pitch has the same accidental\n          // as the scale state\n\n          const sameAccidental = scaleMap[key.root] === pitch; // Determine if an identical pitch in the chord already\n          // modified the accidental state\n\n          const previouslyModified = modifiedPitches.indexOf(pitch) > -1; // Add the accidental to the StaveNote\n\n          if (!sameAccidental || sameAccidental && previouslyModified) {\n            // Modify the scale map so that the root pitch has an\n            // updated state\n            scaleMap[key.root] = pitch; // Create the accidental\n\n            const accidental = new Accidental(accidentalString); // Attach the accidental to the StaveNote\n\n            note.addAccidental(keyIndex, accidental); // Add the pitch to list of pitches that modified accidentals\n\n            modifiedPitches.push(pitch);\n          }\n        }); // process grace notes\n\n        note.getModifiers().forEach(modifier => {\n          if (modifier.getCategory() === 'gracenotegroups') {\n            modifier.getGraceNotes().forEach(processNote);\n          }\n        });\n      };\n\n      notes.forEach(processNote);\n    });\n  } // Create accidental. `type` can be a value from the\n  // `Vex.Flow.accidentalCodes.accidentals` table in `tables.js`. For\n  // example: `#`, `##`, `b`, `n`, etc.\n\n\n  constructor(type = null) {\n    super();\n    this.setAttribute('type', 'Accidental');\n    L('New accidental: ', type);\n    this.note = null; // The `index` points to a specific note in a chord.\n\n    this.index = null;\n    this.type = type;\n    this.position = Modifier.Position.LEFT;\n    this.render_options = {\n      // Font size for glyphs\n      font_scale: 38,\n      // Length of stroke across heads above or below the stave.\n      stroke_px: 3,\n      // Padding between accidental and parentheses on each side\n      parenLeftPadding: 2,\n      parenRightPadding: 2\n    };\n    this.accidental = Flow.accidentalCodes(this.type);\n\n    if (!this.accidental) {\n      throw new Vex.RERR('ArgumentError', `Unknown accidental type: ${type}`);\n    } // Cautionary accidentals have parentheses around them\n\n\n    this.cautionary = false;\n    this.parenLeft = null;\n    this.parenRight = null;\n    this.reset();\n  }\n\n  reset() {\n    const fontScale = this.render_options.font_scale;\n    this.glyph = new Glyph(this.accidental.code, fontScale);\n    this.glyph.setOriginX(1.0);\n\n    if (this.cautionary) {\n      this.parenLeft = new Glyph(Flow.accidentalCodes('{').code, fontScale);\n      this.parenRight = new Glyph(Flow.accidentalCodes('}').code, fontScale);\n      this.parenLeft.setOriginX(1.0);\n      this.parenRight.setOriginX(1.0);\n    }\n  }\n\n  getCategory() {\n    return Accidental.CATEGORY;\n  }\n\n  getWidth() {\n    const parenWidth = this.cautionary ? getGlyphWidth(this.parenLeft) + getGlyphWidth(this.parenRight) + this.render_options.parenLeftPadding + this.render_options.parenRightPadding : 0;\n    return getGlyphWidth(this.glyph) + parenWidth;\n  } // Attach this accidental to `note`, which must be a `StaveNote`.\n\n\n  setNote(note) {\n    if (!note) {\n      throw new Vex.RERR('ArgumentError', `Bad note value: ${note}`);\n    }\n\n    this.note = note; // Accidentals attached to grace notes are rendered smaller.\n\n    if (this.note.getCategory() === 'gracenotes') {\n      this.render_options.font_scale = 25;\n      this.reset();\n    }\n  } // If called, draws parenthesis around accidental.\n\n\n  setAsCautionary() {\n    this.cautionary = true;\n    this.render_options.font_scale = 28;\n    this.reset();\n    return this;\n  } // Render accidental onto canvas.\n\n\n  draw() {\n    const {\n      context,\n      type,\n      position,\n      note,\n      index,\n      cautionary,\n      x_shift,\n      y_shift,\n      glyph,\n      parenLeft,\n      parenRight,\n      render_options: {\n        parenLeftPadding,\n        parenRightPadding\n      }\n    } = this;\n    this.checkContext();\n\n    if (!(note && index != null)) {\n      throw new Vex.RERR('NoAttachedNote', \"Can't draw accidental without a note and index.\");\n    } // Figure out the start `x` and `y` coordinates for note and index.\n\n\n    const start = note.getModifierStartXY(position, index);\n    let accX = start.x + x_shift;\n    const accY = start.y + y_shift;\n    L('Rendering: ', type, accX, accY);\n\n    if (!cautionary) {\n      glyph.render(context, accX, accY);\n    } else {\n      // Render the accidental in parentheses.\n      parenRight.render(context, accX, accY);\n      accX -= getGlyphWidth(parenRight);\n      accX -= parenRightPadding;\n      accX -= this.accidental.parenRightPaddingAdjustment;\n      glyph.render(context, accX, accY);\n      accX -= getGlyphWidth(glyph);\n      accX -= parenLeftPadding;\n      parenLeft.render(context, accX, accY);\n    }\n\n    this.setRendered();\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/accidental.js"],"names":["Vex","Fraction","Flow","Music","Modifier","Glyph","L","args","Accidental","DEBUG","getGlyphWidth","glyph","getMetrics","width","CATEGORY","format","accidentals","state","noteheadAccidentalPadding","leftShift","left_shift","accidentalSpacing","length","accList","prevNote","shiftL","i","acc","note","getNote","stave","getStave","props","getKeyProps","getIndex","n","keys","Math","max","getLeftDisplacedHeadPx","lineSpace","options","spacing_between_lines_px","y","getYForLine","line","accLine","round","push","shift","sort","a","b","lineList","accShift","previousLine","flatLine","dblSharpLine","numAcc","type","getWidth","totalColumns","noFurtherConflicts","groupStart","groupEnd","checkCollision","getGroupLine","index","getGroupLines","indexes","map","lineDifference","indexA","indexB","item","notColliding","indexPairs","every","lines","groupLength","endCase","groupMember","column","patternLength","collisionDetected","accidentalColumnsTable","columnWidths","columnXOffsets","forEach","totalShift","accCount","lineWidth","lastAccOnLine","xShift","setXShift","line1","line2","clearance","clearanceRequired","collision","abs","applyAccidentals","voices","keySignature","tickPositions","tickNoteMap","voice","tickPosition","notes","getTickables","shouldIgnoreTicks","notesAtPosition","value","add","getTicks","music","scaleMap","createScaleMap","tick","modifiedPitches","processNote","isRest","keyString","keyIndex","key","getNoteParts","split","accidentalString","accidental","pitch","root","sameAccidental","previouslyModified","indexOf","addAccidental","getModifiers","modifier","getCategory","getGraceNotes","constructor","setAttribute","position","Position","LEFT","render_options","font_scale","stroke_px","parenLeftPadding","parenRightPadding","accidentalCodes","RERR","cautionary","parenLeft","parenRight","reset","fontScale","code","setOriginX","parenWidth","setNote","setAsCautionary","draw","context","x_shift","y_shift","checkContext","start","getModifierStartXY","accX","x","accY","render","parenRightPaddingAdjustment","setRendered"],"mappings":"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","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n// @author Mohit Cheppudira\n// @author Greg Ristow (modifications)\n//\n// ## Description\n//\n// This file implements accidentals as modifiers that can be attached to\n// notes. Support is included for both western and microtonal accidentals.\n//\n// See `tests/accidental_tests.js` for usage examples.\n\nimport { Vex } from './vex';\nimport { Fraction } from './fraction';\nimport { Flow } from './tables';\nimport { Music } from './music';\nimport { Modifier } from './modifier';\nimport { Glyph } from './glyph';\n\n// To enable logging for this class. Set `Vex.Flow.Accidental.DEBUG` to `true`.\nfunction L(...args) { if (Accidental.DEBUG) Vex.L('Vex.Flow.Accidental', args); }\n\nconst getGlyphWidth = glyph => glyph.getMetrics().width;\n\n// An `Accidental` inherits from `Modifier`, and is formatted within a\n// `ModifierContext`.\nexport class Accidental extends Modifier {\n  static get CATEGORY() { return 'accidentals'; }\n\n  // Arrange accidentals inside a ModifierContext.\n  static format(accidentals, state) {\n    const noteheadAccidentalPadding = 1;\n    const leftShift = state.left_shift + noteheadAccidentalPadding;\n    const accidentalSpacing = 3;\n\n    // If there are no accidentals, we needn't format their positions\n    if (!accidentals || accidentals.length === 0) return;\n\n    const accList = [];\n    let prevNote = null;\n    let shiftL = 0;\n\n    // First determine the accidentals' Y positions from the note.keys\n    for (let i = 0; i < accidentals.length; ++i) {\n      const acc = accidentals[i];\n      const note = acc.getNote();\n      const stave = note.getStave();\n      const props = note.getKeyProps()[acc.getIndex()];\n      if (note !== prevNote) {\n        // Iterate through all notes to get the displaced pixels\n        for (let n = 0; n < note.keys.length; ++n) {\n          shiftL = Math.max(note.getLeftDisplacedHeadPx(), shiftL);\n        }\n        prevNote = note;\n      }\n      if (stave !== null) {\n        const lineSpace = stave.options.spacing_between_lines_px;\n        const y = stave.getYForLine(props.line);\n        const accLine = Math.round(y / lineSpace * 2) / 2;\n        accList.push({ y, line: accLine, shift: shiftL, acc, lineSpace });\n      } else {\n        accList.push({ line: props.line, shift: shiftL, acc });\n      }\n    }\n\n    // Sort accidentals by line number.\n    accList.sort((a, b) => b.line - a.line);\n\n    // FIXME: Confusing name. Each object in this array has a property called `line`.\n    // So if this is a list of lines, you end up with: `line.line` which is very awkward.\n    const lineList = [];\n\n    // amount by which all accidentals must be shifted right or left for\n    // stem flipping, notehead shifting concerns.\n    let accShift = 0;\n    let previousLine = null;\n\n    // Create an array of unique line numbers (lineList) from accList\n    for (let i = 0; i < accList.length; i++) {\n      const acc = accList[i];\n\n      // if this is the first line, or a new line, add a lineList\n      if (previousLine === null || previousLine !== acc.line) {\n        lineList.push({\n          line: acc.line,\n          flatLine: true,\n          dblSharpLine: true,\n          numAcc: 0,\n          width: 0,\n        });\n      }\n      // if this accidental is not a flat, the accidental needs 3.0 lines lower\n      // clearance instead of 2.5 lines for b or bb.\n      // FIXME: Naming could use work. acc.acc is very awkward\n      if (acc.acc.type !== 'b' && acc.acc.type !== 'bb') {\n        lineList[lineList.length - 1].flatLine = false;\n      }\n\n      // if this accidental is not a double sharp, the accidental needs 3.0 lines above\n      if (acc.acc.type !== '##') {\n        lineList[lineList.length - 1].dblSharpLine = false;\n      }\n\n      // Track how many accidentals are on this line:\n      lineList[lineList.length - 1].numAcc++;\n\n      // Track the total x_offset needed for this line which will be needed\n      // for formatting lines w/ multiple accidentals:\n\n      // width = accidental width + universal spacing between accidentals\n      lineList[lineList.length - 1].width += acc.acc.getWidth() + accidentalSpacing;\n\n      // if this accShift is larger, use it to keep first column accidentals in the same line\n      accShift = acc.shift > accShift ? acc.shift : accShift;\n\n      previousLine = acc.line;\n    }\n\n    // ### Place Accidentals in Columns\n    //\n    // Default to a classic triangular layout (middle accidental farthest left),\n    // but follow exceptions as outlined in G. Read's _Music Notation_ and\n    // Elaine Gould's _Behind Bars_.\n    //\n    // Additionally, this implements different vertical collision rules for\n    // flats (only need 2.5 lines clearance below) and double sharps (only\n    // need 2.5 lines of clearance above or below).\n    //\n    // Classic layouts and exception patterns are found in the 'tables.js'\n    // in 'Vex.Flow.accidentalColumnsTable'\n    //\n    // Beyond 6 vertical accidentals, default to the parallel ascending lines approach,\n    // using as few columns as possible for the verticle structure.\n    //\n    // TODO (?): Allow column to be specified for an accidental at run-time?\n\n    let totalColumns = 0;\n\n    // establish the boundaries for a group of notes with clashing accidentals:\n    for (let i = 0; i < lineList.length; i++) {\n      let noFurtherConflicts = false;\n      const groupStart = i;\n      let groupEnd = i;\n\n      while (groupEnd + 1 < lineList.length && !noFurtherConflicts) {\n        // if this note conflicts with the next:\n        if (this.checkCollision(lineList[groupEnd], lineList[groupEnd + 1])) {\n          // include the next note in the group:\n          groupEnd++;\n        } else {\n          noFurtherConflicts = true;\n        }\n      }\n\n      // Gets an a line from the `lineList`, relative to the current group\n      const getGroupLine = (index) => lineList[groupStart + index];\n      const getGroupLines = (indexes) => indexes.map(getGroupLine);\n      const lineDifference = (indexA, indexB) => {\n        const [a, b] = getGroupLines([indexA, indexB]).map(item => item.line);\n        return a - b;\n      };\n\n      const notColliding = (...indexPairs) =>\n        indexPairs\n          .map(getGroupLines)\n          .every(lines => !this.checkCollision(...lines));\n\n      // Set columns for the lines in this group:\n      const groupLength = groupEnd - groupStart + 1;\n\n      // Set the accidental column for each line of the group\n      let endCase = this.checkCollision(lineList[groupStart], lineList[groupEnd]) ? 'a' : 'b';\n\n      switch (groupLength) {\n        case 3:\n          if (endCase === 'a' && lineDifference(1, 2) === 0.5 && lineDifference(0, 1) !== 0.5) {\n            endCase = 'second_on_bottom';\n          }\n          break;\n        case 4:\n          if (notColliding([0, 2], [1, 3])) {\n            endCase = 'spaced_out_tetrachord';\n          }\n          break;\n        case 5:\n          if (endCase === 'b' && notColliding([1, 3])) {\n            endCase = 'spaced_out_pentachord';\n            if (notColliding([0, 2], [2, 4])) {\n              endCase = 'very_spaced_out_pentachord';\n            }\n          }\n          break;\n        case 6:\n          if (notColliding([0, 3], [1, 4], [2, 5])) {\n            endCase = 'spaced_out_hexachord';\n          }\n          if (notColliding([0, 2], [2, 4], [1, 3], [3, 5])) {\n            endCase = 'very_spaced_out_hexachord';\n          }\n          break;\n        default:\n          break;\n      }\n\n      let groupMember;\n      let column;\n      // If the group contains more than seven members, use ascending parallel lines\n      // of accidentals, using as few columns as possible while avoiding collisions.\n      if (groupLength >= 7) {\n        // First, determine how many columns to use:\n        let patternLength = 2;\n        let collisionDetected = true;\n        while (collisionDetected === true) {\n          collisionDetected = false;\n          for (let line = 0; line + patternLength < lineList.length; line++) {\n            if (this.checkCollision(lineList[line], lineList[line + patternLength])) {\n              collisionDetected = true;\n              patternLength++;\n              break;\n            }\n          }\n        }\n        // Then, assign a column to each line of accidentals\n        for (groupMember = i; groupMember <= groupEnd; groupMember++) {\n          column = ((groupMember - i) % patternLength) + 1;\n          lineList[groupMember].column = column;\n          totalColumns = (totalColumns > column) ? totalColumns : column;\n        }\n\n        // Otherwise, if the group contains fewer than seven members, use the layouts from\n        // the accidentalsColumnsTable housed in tables.js.\n      } else {\n        for (groupMember = i; groupMember <= groupEnd; groupMember++) {\n          column = Flow.accidentalColumnsTable[groupLength][endCase][groupMember - i];\n          lineList[groupMember].column = column;\n          totalColumns = (totalColumns > column) ? totalColumns : column;\n        }\n      }\n\n      // Increment i to the last note that was set, so that if a lower set of notes\n      // does not conflict at all with this group, it can have its own classic shape.\n      i = groupEnd;\n    }\n\n    // ### Convert Columns to x_offsets\n    //\n    // This keeps columns aligned, even if they have different accidentals within them\n    // which sometimes results in a larger x_offset than is an accidental might need\n    // to preserve the symmetry of the accidental shape.\n    //\n    // Neither A.C. Vinci nor G. Read address this, and it typically only happens in\n    // music with complex chord clusters.\n    //\n    // TODO (?): Optionally allow closer compression of accidentals, instead of forcing\n    // parallel columns.\n\n    // track each column's max width, which will be used as initial shift of later columns:\n    const columnWidths = [];\n    const columnXOffsets = [];\n    for (let i = 0; i <= totalColumns; i++) {\n      columnWidths[i] = 0;\n      columnXOffsets[i] = 0;\n    }\n\n    columnWidths[0] = accShift + leftShift;\n    columnXOffsets[0] = accShift + leftShift;\n\n    // Fill columnWidths with widest needed x-space;\n    // this is what keeps the columns parallel.\n    lineList.forEach(line => {\n      if (line.width > columnWidths[line.column]) columnWidths[line.column] = line.width;\n    });\n\n    for (let i = 1; i < columnWidths.length; i++) {\n      // this column's offset = this column's width + previous column's offset\n      columnXOffsets[i] = columnWidths[i] + columnXOffsets[i - 1];\n    }\n\n    const totalShift = columnXOffsets[columnXOffsets.length - 1];\n    // Set the xShift for each accidental according to column offsets:\n    let accCount = 0;\n    lineList.forEach(line => {\n      let lineWidth = 0;\n      const lastAccOnLine = accCount + line.numAcc;\n      // handle all of the accidentals on a given line:\n      for (accCount; accCount < lastAccOnLine; accCount++) {\n        const xShift = (columnXOffsets[line.column - 1] + lineWidth);\n        accList[accCount].acc.setXShift(xShift);\n        // keep track of the width of accidentals we've added so far, so that when\n        // we loop, we add space for them.\n        lineWidth += accList[accCount].acc.getWidth() + accidentalSpacing;\n        L('Line, accCount, shift: ', line.line, accCount, xShift);\n      }\n    });\n\n    // update the overall layout with the full width of the accidental shapes:\n    state.left_shift += totalShift;\n  }\n\n  // Helper function to determine whether two lines of accidentals collide vertically\n  static checkCollision(line1, line2) {\n    let clearance = line2.line - line1.line;\n    let clearanceRequired = 3;\n    // But less clearance is required for certain accidentals: b, bb and ##.\n    if (clearance > 0) { // then line 2 is on top\n      clearanceRequired = (line2.flatLine || line2.dblSharpLine) ? 2.5 : 3.0;\n      if (line1.dblSharpLine) clearance -= 0.5;\n    } else { // line 1 is on top\n      clearanceRequired = (line1.flatLine || line1.dblSharpLine) ? 2.5 : 3.0;\n      if (line2.dblSharpLine) clearance -= 0.5;\n    }\n    const collision = Math.abs(clearance) < clearanceRequired;\n    L('Line_1, Line_2, Collision: ', line1.line, line2.line, collision);\n    return collision;\n  }\n\n  // Use this method to automatically apply accidentals to a set of `voices`.\n  // The accidentals will be remembered between all the voices provided.\n  // Optionally, you can also provide an initial `keySignature`.\n  static applyAccidentals(voices, keySignature) {\n    const tickPositions = [];\n    const tickNoteMap = {};\n\n    // Sort the tickables in each voice by their tick position in the voice\n    voices.forEach(voice => {\n      const tickPosition = new Fraction(0, 1);\n      const notes = voice.getTickables();\n      notes.forEach(note => {\n        if (note.shouldIgnoreTicks()) return;\n\n        const notesAtPosition = tickNoteMap[tickPosition.value()];\n\n        if (!notesAtPosition) {\n          tickPositions.push(tickPosition.value());\n          tickNoteMap[tickPosition.value()] = [note];\n        } else {\n          notesAtPosition.push(note);\n        }\n\n        tickPosition.add(note.getTicks());\n      });\n    });\n\n    const music = new Music();\n\n    // Default key signature is C major\n    if (!keySignature) keySignature = 'C';\n\n    // Get the scale map, which represents the current state of each pitch\n    const scaleMap = music.createScaleMap(keySignature);\n\n    tickPositions.forEach(tick => {\n      const notes = tickNoteMap[tick];\n\n      // Array to store all pitches that modified accidental states\n      // at this tick position\n      const modifiedPitches = [];\n\n      const processNote = (note) => {\n        if (note.isRest() || note.shouldIgnoreTicks()) return;\n\n        // Go through each key and determine if an accidental should be\n        // applied\n        note.keys.forEach((keyString, keyIndex) => {\n          const key = music.getNoteParts(keyString.split('/')[0]);\n\n          // Force a natural for every key without an accidental\n          const accidentalString = key.accidental || 'n';\n          const pitch = key.root + accidentalString;\n\n          // Determine if the current pitch has the same accidental\n          // as the scale state\n          const sameAccidental = scaleMap[key.root] === pitch;\n\n          // Determine if an identical pitch in the chord already\n          // modified the accidental state\n          const previouslyModified = modifiedPitches.indexOf(pitch) > -1;\n\n          // Add the accidental to the StaveNote\n          if (!sameAccidental || (sameAccidental && previouslyModified)) {\n            // Modify the scale map so that the root pitch has an\n            // updated state\n            scaleMap[key.root] = pitch;\n\n            // Create the accidental\n            const accidental = new Accidental(accidentalString);\n\n            // Attach the accidental to the StaveNote\n            note.addAccidental(keyIndex, accidental);\n\n            // Add the pitch to list of pitches that modified accidentals\n            modifiedPitches.push(pitch);\n          }\n        });\n\n        // process grace notes\n        note.getModifiers().forEach(modifier => {\n          if (modifier.getCategory() === 'gracenotegroups') {\n            modifier.getGraceNotes().forEach(processNote);\n          }\n        });\n      };\n\n      notes.forEach(processNote);\n    });\n  }\n\n  // Create accidental. `type` can be a value from the\n  // `Vex.Flow.accidentalCodes.accidentals` table in `tables.js`. For\n  // example: `#`, `##`, `b`, `n`, etc.\n  constructor(type = null) {\n    super();\n    this.setAttribute('type', 'Accidental');\n\n    L('New accidental: ', type);\n\n    this.note = null;\n    // The `index` points to a specific note in a chord.\n    this.index = null;\n    this.type = type;\n    this.position = Modifier.Position.LEFT;\n\n    this.render_options = {\n      // Font size for glyphs\n      font_scale: 38,\n\n      // Length of stroke across heads above or below the stave.\n      stroke_px: 3,\n\n      // Padding between accidental and parentheses on each side\n      parenLeftPadding: 2,\n      parenRightPadding: 2,\n    };\n\n    this.accidental = Flow.accidentalCodes(this.type);\n    if (!this.accidental) {\n      throw new Vex.RERR('ArgumentError', `Unknown accidental type: ${type}`);\n    }\n\n    // Cautionary accidentals have parentheses around them\n    this.cautionary = false;\n    this.parenLeft = null;\n    this.parenRight = null;\n\n    this.reset();\n  }\n\n  reset() {\n    const fontScale = this.render_options.font_scale;\n    this.glyph = new Glyph(this.accidental.code, fontScale);\n    this.glyph.setOriginX(1.0);\n\n    if (this.cautionary) {\n      this.parenLeft = new Glyph(Flow.accidentalCodes('{').code, fontScale);\n      this.parenRight = new Glyph(Flow.accidentalCodes('}').code, fontScale);\n      this.parenLeft.setOriginX(1.0);\n      this.parenRight.setOriginX(1.0);\n    }\n  }\n\n  getCategory() { return Accidental.CATEGORY; }\n\n  getWidth() {\n    const parenWidth = this.cautionary\n      ? (\n        getGlyphWidth(this.parenLeft) +\n        getGlyphWidth(this.parenRight) +\n        this.render_options.parenLeftPadding +\n        this.render_options.parenRightPadding\n      )\n      : 0;\n\n    return getGlyphWidth(this.glyph) + parenWidth;\n  }\n\n  // Attach this accidental to `note`, which must be a `StaveNote`.\n  setNote(note) {\n    if (!note) {\n      throw new Vex.RERR('ArgumentError', `Bad note value: ${note}`);\n    }\n\n    this.note = note;\n\n    // Accidentals attached to grace notes are rendered smaller.\n    if (this.note.getCategory() === 'gracenotes') {\n      this.render_options.font_scale = 25;\n      this.reset();\n    }\n  }\n\n  // If called, draws parenthesis around accidental.\n  setAsCautionary() {\n    this.cautionary = true;\n    this.render_options.font_scale = 28;\n    this.reset();\n    return this;\n  }\n\n  // Render accidental onto canvas.\n  draw() {\n    const {\n      context,\n      type, position, note, index, cautionary,\n      x_shift, y_shift,\n      glyph, parenLeft, parenRight,\n      render_options: { parenLeftPadding, parenRightPadding },\n    } = this;\n\n    this.checkContext();\n\n    if (!(note && (index != null))) {\n      throw new Vex.RERR('NoAttachedNote', \"Can't draw accidental without a note and index.\");\n    }\n\n    // Figure out the start `x` and `y` coordinates for note and index.\n    const start = note.getModifierStartXY(position, index);\n    let accX = start.x + x_shift;\n    const accY = start.y + y_shift;\n    L('Rendering: ', type, accX, accY);\n\n    if (!cautionary) {\n      glyph.render(context, accX, accY);\n    } else {\n      // Render the accidental in parentheses.\n      parenRight.render(context, accX, accY);\n      accX -= getGlyphWidth(parenRight);\n      accX -= parenRightPadding;\n      accX -= this.accidental.parenRightPaddingAdjustment;\n      glyph.render(context, accX, accY);\n      accX -= getGlyphWidth(glyph);\n      accX -= parenLeftPadding;\n      parenLeft.render(context, accX, accY);\n    }\n\n    this.setRendered();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}