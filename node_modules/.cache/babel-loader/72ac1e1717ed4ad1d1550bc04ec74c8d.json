{"ast":null,"code":"// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n// Author: Cyril Silverman\n//\n// ## Description\n//\n// This file implements key signatures. A key signature sits on a stave\n// and indicates the notes with implicit accidentals.\nimport { Vex } from './vex';\nimport { Flow } from './tables';\nimport { StaveModifier } from './stavemodifier';\nimport { Glyph } from './glyph';\nexport class KeySignature extends StaveModifier {\n  static get CATEGORY() {\n    return 'keysignatures';\n  } // Space between natural and following accidental depending\n  // on vertical position\n\n\n  static get accidentalSpacing() {\n    return {\n      '#': {\n        above: 6,\n        below: 4\n      },\n      'b': {\n        above: 4,\n        below: 7\n      },\n      'n': {\n        above: 4,\n        below: 1\n      },\n      '##': {\n        above: 6,\n        below: 4\n      },\n      'bb': {\n        above: 4,\n        below: 7\n      },\n      'db': {\n        above: 4,\n        below: 7\n      },\n      'd': {\n        above: 4,\n        below: 7\n      },\n      'bbs': {\n        above: 4,\n        below: 7\n      },\n      '++': {\n        above: 6,\n        below: 4\n      },\n      '+': {\n        above: 6,\n        below: 4\n      },\n      '+-': {\n        above: 6,\n        below: 4\n      },\n      '++-': {\n        above: 6,\n        below: 4\n      },\n      'bs': {\n        above: 4,\n        below: 10\n      },\n      'bss': {\n        above: 4,\n        below: 10\n      }\n    };\n  } // Create a new Key Signature based on a `key_spec`\n\n\n  constructor(keySpec, cancelKeySpec, alterKeySpec) {\n    super();\n    this.setAttribute('type', 'KeySignature');\n    this.setKeySig(keySpec, cancelKeySpec, alterKeySpec);\n    this.setPosition(StaveModifier.Position.BEGIN);\n    this.glyphFontScale = 38; // TODO(0xFE): Should this match StaveNote?\n\n    this.glyphs = [];\n    this.xPositions = []; // relative to this.x\n\n    this.paddingForced = false;\n  }\n\n  getCategory() {\n    return KeySignature.CATEGORY;\n  } // Add an accidental glyph to the `KeySignature` instance which represents\n  // the provided `acc`. If `nextAcc` is also provided, the appropriate\n  // spacing will be included in the glyph's position\n\n\n  convertToGlyph(acc, nextAcc) {\n    const accGlyphData = Flow.accidentalCodes(acc.type);\n    const glyph = new Glyph(accGlyphData.code, this.glyphFontScale); // Determine spacing between current accidental and the next accidental\n\n    let extraWidth = 1;\n\n    if (acc.type === 'n' && nextAcc) {\n      const spacing = KeySignature.accidentalSpacing[nextAcc.type];\n\n      if (spacing) {\n        const isAbove = nextAcc.line >= acc.line;\n        extraWidth = isAbove ? spacing.above : spacing.below;\n      }\n    } // Place the glyph on the stave\n\n\n    this.placeGlyphOnLine(glyph, this.stave, acc.line);\n    this.glyphs.push(glyph);\n    const xPosition = this.xPositions[this.xPositions.length - 1];\n    const glyphWidth = glyph.getMetrics().width + extraWidth; // Store the next accidental's x position\n\n    this.xPositions.push(xPosition + glyphWidth); // Expand size of key signature\n\n    this.width += glyphWidth;\n  } // Cancel out a key signature provided in the `spec` parameter. This will\n  // place appropriate natural accidentals before the key signature.\n\n\n  cancelKey(spec) {\n    this.formatted = false;\n    this.cancelKeySpec = spec;\n    return this;\n  }\n\n  convertToCancelAccList(spec) {\n    // Get the accidental list for the cancelled key signature\n    const cancel_accList = Flow.keySignature(spec); // If the cancelled key has a different accidental type, ie: # vs b\n\n    const different_types = this.accList.length > 0 && cancel_accList.length > 0 && cancel_accList[0].type !== this.accList[0].type; // Determine how many naturals needed to add\n\n    const naturals = different_types ? cancel_accList.length : cancel_accList.length - this.accList.length; // Return if no naturals needed\n\n    if (naturals < 1) return undefined; // Get the line position for each natural\n\n    const cancelled = [];\n\n    for (let i = 0; i < naturals; i++) {\n      let index = i;\n\n      if (!different_types) {\n        index = cancel_accList.length - naturals + i;\n      }\n\n      const acc = cancel_accList[index];\n      cancelled.push({\n        type: 'n',\n        line: acc.line\n      });\n    } // Combine naturals with main accidental list for the key signature\n\n\n    this.accList = cancelled.concat(this.accList);\n    return {\n      accList: cancelled,\n      type: cancel_accList[0].type\n    };\n  } // Deprecated\n\n\n  addToStave(stave) {\n    this.paddingForced = true;\n    stave.addModifier(this);\n    return this;\n  } // Apply the accidental staff line placement based on the `clef` and\n  // the  accidental `type` for the key signature ('# or 'b').\n\n\n  convertAccLines(clef, type, accList = this.accList) {\n    let offset = 0.0; // if clef === \"treble\"\n\n    let customLines; // when clef doesn't follow treble key sig shape\n\n    switch (clef) {\n      // Treble & Subbass both have offsets of 0, so are not included.\n      case 'soprano':\n        if (type === '#') customLines = [2.5, 0.5, 2, 0, 1.5, -0.5, 1];else offset = -1;\n        break;\n\n      case 'mezzo-soprano':\n        if (type === 'b') customLines = [0, 2, 0.5, 2.5, 1, 3, 1.5];else offset = 1.5;\n        break;\n\n      case 'alto':\n        offset = 0.5;\n        break;\n\n      case 'tenor':\n        if (type === '#') customLines = [3, 1, 2.5, 0.5, 2, 0, 1.5];else offset = -0.5;\n        break;\n\n      case 'baritone-f':\n      case 'baritone-c':\n        if (type === 'b') customLines = [0.5, 2.5, 1, 3, 1.5, 3.5, 2];else offset = 2;\n        break;\n\n      case 'bass':\n      case 'french':\n        offset = 1;\n        break;\n\n      default:\n        break;\n    } // If there's a special case, assign those lines/spaces:\n\n\n    let i;\n\n    if (typeof customLines !== 'undefined') {\n      for (i = 0; i < accList.length; ++i) {\n        accList[i].line = customLines[i];\n      }\n    } else if (offset !== 0) {\n      for (i = 0; i < accList.length; ++i) {\n        accList[i].line += offset;\n      }\n    }\n  }\n\n  getPadding(index) {\n    if (!this.formatted) this.format();\n    return this.glyphs.length === 0 || !this.paddingForced && index < 2 ? 0 : this.padding;\n  }\n\n  getWidth() {\n    if (!this.formatted) this.format();\n    return this.width;\n  }\n\n  setKeySig(keySpec, cancelKeySpec, alterKeySpec) {\n    this.formatted = false;\n    this.keySpec = keySpec;\n    this.cancelKeySpec = cancelKeySpec;\n    this.alterKeySpec = alterKeySpec;\n    return this;\n  } // Alter the accidentals of a key spec one by one.\n  // Each alteration is a new accidental that replaces the\n  // original accidental (or the canceled one).\n\n\n  alterKey(alterKeySpec) {\n    this.formatted = false;\n    this.alterKeySpec = alterKeySpec;\n    return this;\n  }\n\n  convertToAlterAccList(alterKeySpec) {\n    const max = Math.min(alterKeySpec.length, this.accList.length);\n\n    for (let i = 0; i < max; ++i) {\n      if (alterKeySpec[i]) {\n        this.accList[i].type = alterKeySpec[i];\n      }\n    }\n  }\n\n  format() {\n    if (!this.stave) {\n      throw new Vex.RERR('KeySignatureError', \"Can't draw key signature without stave.\");\n    }\n\n    this.width = 0;\n    this.glyphs = [];\n    this.xPositions = [0]; // initialize with initial x position\n\n    this.accList = Flow.keySignature(this.keySpec);\n    const accList = this.accList;\n    const firstAccidentalType = accList.length > 0 ? accList[0].type : null;\n    let cancelAccList;\n\n    if (this.cancelKeySpec) {\n      cancelAccList = this.convertToCancelAccList(this.cancelKeySpec);\n    }\n\n    if (this.alterKeySpec) {\n      this.convertToAlterAccList(this.alterKeySpec);\n    }\n\n    if (this.accList.length > 0) {\n      const clef = (this.position === StaveModifier.Position.END ? this.stave.endClef : this.stave.clef) || this.stave.clef;\n\n      if (cancelAccList) {\n        this.convertAccLines(clef, cancelAccList.type, cancelAccList.accList);\n      }\n\n      this.convertAccLines(clef, firstAccidentalType, accList);\n\n      for (let i = 0; i < this.accList.length; ++i) {\n        this.convertToGlyph(this.accList[i], this.accList[i + 1]);\n      }\n    }\n\n    this.formatted = true;\n  }\n\n  draw() {\n    if (!this.x) {\n      throw new Vex.RERR('KeySignatureError', \"Can't draw key signature without x.\");\n    }\n\n    if (!this.stave) {\n      throw new Vex.RERR('KeySignatureError', \"Can't draw key signature without stave.\");\n    }\n\n    if (!this.formatted) this.format();\n    this.setRendered();\n\n    for (let i = 0; i < this.glyphs.length; i++) {\n      const glyph = this.glyphs[i];\n      const x = this.x + this.xPositions[i];\n      glyph.setStave(this.stave);\n      glyph.setContext(this.stave.context);\n      glyph.renderToStave(x);\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/keysignature.js"],"names":["Vex","Flow","StaveModifier","Glyph","KeySignature","CATEGORY","accidentalSpacing","above","below","constructor","keySpec","cancelKeySpec","alterKeySpec","setAttribute","setKeySig","setPosition","Position","BEGIN","glyphFontScale","glyphs","xPositions","paddingForced","getCategory","convertToGlyph","acc","nextAcc","accGlyphData","accidentalCodes","type","glyph","code","extraWidth","spacing","isAbove","line","placeGlyphOnLine","stave","push","xPosition","length","glyphWidth","getMetrics","width","cancelKey","spec","formatted","convertToCancelAccList","cancel_accList","keySignature","different_types","accList","naturals","undefined","cancelled","i","index","concat","addToStave","addModifier","convertAccLines","clef","offset","customLines","getPadding","format","padding","getWidth","alterKey","convertToAlterAccList","max","Math","min","RERR","firstAccidentalType","cancelAccList","position","END","endClef","draw","x","setRendered","setStave","setContext","context","renderToStave"],"mappings":"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","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n// Author: Cyril Silverman\n//\n// ## Description\n//\n// This file implements key signatures. A key signature sits on a stave\n// and indicates the notes with implicit accidentals.\n\nimport { Vex } from './vex';\nimport { Flow } from './tables';\nimport { StaveModifier } from './stavemodifier';\nimport { Glyph } from './glyph';\n\nexport class KeySignature extends StaveModifier {\n  static get CATEGORY() { return 'keysignatures'; }\n\n  // Space between natural and following accidental depending\n  // on vertical position\n  static get accidentalSpacing() {\n    return {\n      '#': {\n        above: 6,\n        below: 4,\n      },\n      'b': {\n        above: 4,\n        below: 7,\n      },\n      'n': {\n        above: 4,\n        below: 1,\n      },\n      '##': {\n        above: 6,\n        below: 4,\n      },\n      'bb': {\n        above: 4,\n        below: 7,\n      },\n      'db': {\n        above: 4,\n        below: 7,\n      },\n      'd': {\n        above: 4,\n        below: 7,\n      },\n      'bbs': {\n        above: 4,\n        below: 7,\n      },\n      '++': {\n        above: 6,\n        below: 4,\n      },\n      '+': {\n        above: 6,\n        below: 4,\n      },\n      '+-': {\n        above: 6,\n        below: 4,\n      },\n      '++-': {\n        above: 6,\n        below: 4,\n      },\n      'bs': {\n        above: 4,\n        below: 10,\n      },\n      'bss': {\n        above: 4,\n        below: 10,\n      },\n    };\n  }\n\n  // Create a new Key Signature based on a `key_spec`\n  constructor(keySpec, cancelKeySpec, alterKeySpec) {\n    super();\n    this.setAttribute('type', 'KeySignature');\n\n    this.setKeySig(keySpec, cancelKeySpec, alterKeySpec);\n    this.setPosition(StaveModifier.Position.BEGIN);\n    this.glyphFontScale = 38; // TODO(0xFE): Should this match StaveNote?\n    this.glyphs = [];\n    this.xPositions = []; // relative to this.x\n    this.paddingForced = false;\n  }\n\n  getCategory() { return KeySignature.CATEGORY; }\n\n  // Add an accidental glyph to the `KeySignature` instance which represents\n  // the provided `acc`. If `nextAcc` is also provided, the appropriate\n  // spacing will be included in the glyph's position\n  convertToGlyph(acc, nextAcc) {\n    const accGlyphData = Flow.accidentalCodes(acc.type);\n    const glyph = new Glyph(accGlyphData.code, this.glyphFontScale);\n\n    // Determine spacing between current accidental and the next accidental\n    let extraWidth = 1;\n    if (acc.type === 'n' && nextAcc) {\n      const spacing = KeySignature.accidentalSpacing[nextAcc.type];\n      if (spacing) {\n        const isAbove = nextAcc.line >= acc.line;\n        extraWidth = isAbove ? spacing.above : spacing.below;\n      }\n    }\n\n    // Place the glyph on the stave\n    this.placeGlyphOnLine(glyph, this.stave, acc.line);\n    this.glyphs.push(glyph);\n\n    const xPosition = this.xPositions[this.xPositions.length - 1];\n    const glyphWidth = glyph.getMetrics().width + extraWidth;\n    // Store the next accidental's x position\n    this.xPositions.push(xPosition + glyphWidth);\n    // Expand size of key signature\n    this.width += glyphWidth;\n  }\n\n  // Cancel out a key signature provided in the `spec` parameter. This will\n  // place appropriate natural accidentals before the key signature.\n  cancelKey(spec) {\n    this.formatted = false;\n    this.cancelKeySpec = spec;\n\n    return this;\n  }\n\n  convertToCancelAccList(spec) {\n    // Get the accidental list for the cancelled key signature\n    const cancel_accList = Flow.keySignature(spec);\n\n    // If the cancelled key has a different accidental type, ie: # vs b\n    const different_types = this.accList.length > 0\n      && cancel_accList.length > 0\n      && cancel_accList[0].type !== this.accList[0].type;\n\n    // Determine how many naturals needed to add\n    const naturals = different_types\n      ? cancel_accList.length\n      : cancel_accList.length - this.accList.length;\n\n    // Return if no naturals needed\n    if (naturals < 1) return undefined;\n\n    // Get the line position for each natural\n    const cancelled = [];\n    for (let i = 0; i < naturals; i++) {\n      let index = i;\n      if (!different_types) {\n        index = cancel_accList.length - naturals + i;\n      }\n\n      const acc = cancel_accList[index];\n      cancelled.push({ type: 'n', line: acc.line });\n    }\n\n    // Combine naturals with main accidental list for the key signature\n    this.accList = cancelled.concat(this.accList);\n\n    return {\n      accList: cancelled,\n      type: cancel_accList[0].type\n    };\n  }\n\n  // Deprecated\n  addToStave(stave) {\n    this.paddingForced = true;\n    stave.addModifier(this);\n\n    return this;\n  }\n\n  // Apply the accidental staff line placement based on the `clef` and\n  // the  accidental `type` for the key signature ('# or 'b').\n  convertAccLines(clef, type, accList = this.accList) {\n    let offset = 0.0; // if clef === \"treble\"\n    let customLines; // when clef doesn't follow treble key sig shape\n\n    switch (clef) {\n      // Treble & Subbass both have offsets of 0, so are not included.\n      case 'soprano':\n        if (type === '#') customLines = [2.5, 0.5, 2, 0, 1.5, -0.5, 1];\n        else offset = -1;\n        break;\n      case 'mezzo-soprano':\n        if (type === 'b') customLines = [0, 2, 0.5, 2.5, 1, 3, 1.5];\n        else offset = 1.5;\n        break;\n      case 'alto':\n        offset = 0.5;\n        break;\n      case 'tenor':\n        if (type === '#') customLines = [3, 1, 2.5, 0.5, 2, 0, 1.5];\n        else offset = -0.5;\n        break;\n      case 'baritone-f':\n      case 'baritone-c':\n        if (type === 'b') customLines = [0.5, 2.5, 1, 3, 1.5, 3.5, 2];\n        else offset = 2;\n        break;\n      case 'bass':\n      case 'french':\n        offset = 1;\n        break;\n      default:\n        break;\n    }\n\n    // If there's a special case, assign those lines/spaces:\n    let i;\n    if (typeof customLines !== 'undefined') {\n      for (i = 0; i < accList.length; ++i) {\n        accList[i].line = customLines[i];\n      }\n    } else if (offset !== 0) {\n      for (i = 0; i < accList.length; ++i) {\n        accList[i].line += offset;\n      }\n    }\n  }\n\n  getPadding(index) {\n    if (!this.formatted) this.format();\n\n    return (\n      this.glyphs.length === 0 || (!this.paddingForced && index < 2) ?\n        0 : this.padding\n    );\n  }\n\n  getWidth() {\n    if (!this.formatted) this.format();\n\n    return this.width;\n  }\n\n  setKeySig(keySpec, cancelKeySpec, alterKeySpec) {\n    this.formatted = false;\n    this.keySpec = keySpec;\n    this.cancelKeySpec = cancelKeySpec;\n    this.alterKeySpec = alterKeySpec;\n\n    return this;\n  }\n\n  // Alter the accidentals of a key spec one by one.\n  // Each alteration is a new accidental that replaces the\n  // original accidental (or the canceled one).\n  alterKey(alterKeySpec) {\n    this.formatted = false;\n    this.alterKeySpec = alterKeySpec;\n\n    return this;\n  }\n\n  convertToAlterAccList(alterKeySpec) {\n    const max = Math.min(alterKeySpec.length, this.accList.length);\n    for (let i = 0; i < max; ++i) {\n      if (alterKeySpec[i]) {\n        this.accList[i].type = alterKeySpec[i];\n      }\n    }\n  }\n\n  format() {\n    if (!this.stave) {\n      throw new Vex.RERR('KeySignatureError', \"Can't draw key signature without stave.\");\n    }\n\n    this.width = 0;\n    this.glyphs = [];\n    this.xPositions = [0]; // initialize with initial x position\n    this.accList = Flow.keySignature(this.keySpec);\n    const accList = this.accList;\n    const firstAccidentalType = accList.length > 0 ? accList[0].type : null;\n    let cancelAccList;\n    if (this.cancelKeySpec) {\n      cancelAccList = this.convertToCancelAccList(this.cancelKeySpec);\n    }\n    if (this.alterKeySpec) {\n      this.convertToAlterAccList(this.alterKeySpec);\n    }\n\n    if (this.accList.length > 0) {\n      const clef = ((this.position === StaveModifier.Position.END) ?\n        this.stave.endClef : this.stave.clef) || this.stave.clef;\n      if (cancelAccList) {\n        this.convertAccLines(clef, cancelAccList.type, cancelAccList.accList);\n      }\n      this.convertAccLines(clef, firstAccidentalType, accList);\n      for (let i = 0; i < this.accList.length; ++i) {\n        this.convertToGlyph(this.accList[i], this.accList[i + 1]);\n      }\n    }\n\n    this.formatted = true;\n  }\n\n  draw() {\n    if (!this.x) {\n      throw new Vex.RERR('KeySignatureError', \"Can't draw key signature without x.\");\n    }\n\n    if (!this.stave) {\n      throw new Vex.RERR('KeySignatureError', \"Can't draw key signature without stave.\");\n    }\n\n    if (!this.formatted) this.format();\n    this.setRendered();\n\n    for (let i = 0; i < this.glyphs.length; i++) {\n      const glyph = this.glyphs[i];\n      const x = this.x + this.xPositions[i];\n      glyph.setStave(this.stave);\n      glyph.setContext(this.stave.context);\n      glyph.renderToStave(x);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}