{"ast":null,"code":"// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n// Author: Larry Kuhns\n//\n// ## Description\n// This file implements the `Stroke` class which renders chord strokes\n// that can be arpeggiated, brushed, rasquedo, etc.\nimport { Vex } from './vex';\nimport { Modifier } from './modifier';\nimport { StaveNote } from './stavenote';\nimport { Glyph } from './glyph';\nexport class Stroke extends Modifier {\n  static get CATEGORY() {\n    return 'strokes';\n  }\n\n  static get Type() {\n    return {\n      BRUSH_DOWN: 1,\n      BRUSH_UP: 2,\n      ROLL_DOWN: 3,\n      // Arpeggiated chord\n      ROLL_UP: 4,\n      // Arpeggiated chord\n      RASQUEDO_DOWN: 5,\n      RASQUEDO_UP: 6,\n      ARPEGGIO_DIRECTIONLESS: 7 // Arpeggiated chord without upwards or downwards arrow\n\n    };\n  } // Arrange strokes inside `ModifierContext`\n\n\n  static format(strokes, state) {\n    const left_shift = state.left_shift;\n    const stroke_spacing = 0;\n    if (!strokes || strokes.length === 0) return this;\n    const strokeList = strokes.map(stroke => {\n      const note = stroke.getNote();\n\n      if (note instanceof StaveNote) {\n        const {\n          line\n        } = note.getKeyProps()[stroke.getIndex()];\n        const shift = note.getLeftDisplacedHeadPx();\n        return {\n          line,\n          shift,\n          stroke\n        };\n      } else {\n        const {\n          str: string\n        } = note.getPositions()[stroke.getIndex()];\n        return {\n          line: string,\n          shift: 0,\n          stroke\n        };\n      }\n    });\n    const strokeShift = left_shift; // There can only be one stroke .. if more than one, they overlay each other\n\n    const xShift = strokeList.reduce((xShift, {\n      stroke,\n      shift\n    }) => {\n      stroke.setXShift(strokeShift + shift);\n      return Math.max(stroke.getWidth() + stroke_spacing, xShift);\n    }, 0);\n    state.left_shift += xShift;\n    return true;\n  }\n\n  constructor(type, options) {\n    super();\n    this.setAttribute('type', 'Stroke');\n    this.note = null;\n    this.options = Vex.Merge({}, options); // multi voice - span stroke across all voices if true\n\n    this.all_voices = 'all_voices' in this.options ? this.options.all_voices : true; // multi voice - end note of stroke, set in draw()\n\n    this.note_end = null;\n    this.index = null;\n    this.type = type;\n    this.position = Modifier.Position.LEFT;\n    this.render_options = {\n      font_scale: 38,\n      stroke_px: 3,\n      stroke_spacing: 10\n    };\n    this.font = {\n      family: 'serif',\n      size: 10,\n      weight: 'bold italic'\n    };\n    this.setXShift(0);\n    this.setWidth(10);\n  }\n\n  getCategory() {\n    return Stroke.CATEGORY;\n  }\n\n  getPosition() {\n    return this.position;\n  }\n\n  addEndNote(note) {\n    this.note_end = note;\n    return this;\n  }\n\n  draw() {\n    this.checkContext();\n    this.setRendered();\n\n    if (!(this.note && this.index != null)) {\n      throw new Vex.RERR('NoAttachedNote', \"Can't draw stroke without a note and index.\");\n    }\n\n    const start = this.note.getModifierStartXY(this.position, this.index);\n    let ys = this.note.getYs();\n    let topY = start.y;\n    let botY = start.y;\n    const x = start.x - 5;\n    const line_space = this.note.stave.options.spacing_between_lines_px;\n    const notes = this.getModifierContext().getModifiers(this.note.getCategory());\n\n    for (let i = 0; i < notes.length; i++) {\n      ys = notes[i].getYs();\n\n      for (let n = 0; n < ys.length; n++) {\n        if (this.note === notes[i] || this.all_voices) {\n          topY = Vex.Min(topY, ys[n]);\n          botY = Vex.Max(botY, ys[n]);\n        }\n      }\n    }\n\n    let arrow;\n    let arrow_shift_x;\n    let arrow_y;\n    let text_shift_x;\n    let text_y;\n\n    switch (this.type) {\n      case Stroke.Type.BRUSH_DOWN:\n        arrow = 'arrowheadBlackUp';\n        arrow_shift_x = -3;\n        arrow_y = topY - line_space / 2 + 10;\n        botY += line_space / 2;\n        break;\n\n      case Stroke.Type.BRUSH_UP:\n        arrow = 'arrowheadBlackDown';\n        arrow_shift_x = 0.5;\n        arrow_y = botY + line_space / 2;\n        topY -= line_space / 2;\n        break;\n\n      case Stroke.Type.ROLL_DOWN:\n      case Stroke.Type.RASQUEDO_DOWN:\n        arrow = 'arrowheadBlackUp';\n        arrow_shift_x = -3;\n        text_shift_x = this.x_shift + arrow_shift_x - 2;\n\n        if (this.note instanceof StaveNote) {\n          topY += 1.5 * line_space;\n\n          if ((botY - topY) % 2 !== 0) {\n            botY += 0.5 * line_space;\n          } else {\n            botY += line_space;\n          }\n\n          arrow_y = topY - line_space;\n          text_y = botY + line_space + 2;\n        } else {\n          topY += 1.5 * line_space;\n          botY += line_space;\n          arrow_y = topY - 0.75 * line_space;\n          text_y = botY + 0.25 * line_space;\n        }\n\n        break;\n\n      case Stroke.Type.ROLL_UP:\n      case Stroke.Type.RASQUEDO_UP:\n        arrow = 'arrowheadBlackDown';\n        arrow_shift_x = -4;\n        text_shift_x = this.x_shift + arrow_shift_x - 1;\n\n        if (this.note instanceof StaveNote) {\n          arrow_y = line_space / 2;\n          topY += 0.5 * line_space;\n\n          if ((botY - topY) % 2 === 0) {\n            botY += line_space / 2;\n          }\n\n          arrow_y = botY + 0.5 * line_space;\n          text_y = topY - 1.25 * line_space;\n        } else {\n          topY += 0.25 * line_space;\n          botY += 0.5 * line_space;\n          arrow_y = botY + 0.25 * line_space;\n          text_y = topY - line_space;\n        }\n\n        break;\n\n      case Stroke.Type.ARPEGGIO_DIRECTIONLESS:\n        topY += 0.5 * line_space;\n        botY += line_space; // * 0.5 can lead to slight underlap instead of overlap sometimes\n\n        break;\n\n      default:\n        throw new Vex.RERR('InvalidType', `The stroke type ${this.type} does not exist`);\n    }\n\n    let strokeLine = 'straight'; // Draw the stroke\n\n    if (this.type === Stroke.Type.BRUSH_DOWN || this.type === Stroke.Type.BRUSH_UP) {\n      this.context.fillRect(x + this.x_shift, topY, 1, botY - topY);\n    } else {\n      strokeLine = 'wiggly';\n\n      if (this.note instanceof StaveNote) {\n        for (let i = topY; i <= botY; i += line_space) {\n          Glyph.renderGlyph(this.context, x + this.x_shift - 4, i, this.render_options.font_scale, 'vexWiggleArpeggioUp');\n        }\n      } else {\n        let i;\n\n        for (i = topY; i <= botY; i += 10) {\n          Glyph.renderGlyph(this.context, x + this.x_shift - 4, i, this.render_options.font_scale, 'vexWiggleArpeggioUp');\n        }\n\n        if (this.type === Stroke.Type.RASQUEDO_DOWN) {\n          text_y = i + 0.25 * line_space;\n        }\n      }\n    }\n\n    if (this.type === Stroke.Type.ARPEGGIO_DIRECTIONLESS) {\n      return; // skip drawing arrow heads or text\n    } // Draw the arrow head\n\n\n    Glyph.renderGlyph(this.context, x + this.x_shift + arrow_shift_x, arrow_y, this.render_options.font_scale, arrow, {\n      category: `stroke.${arrow}.${strokeLine}`\n    }); // Draw the rasquedo \"R\"\n\n    if (this.type === Stroke.Type.RASQUEDO_DOWN || this.type === Stroke.Type.RASQUEDO_UP) {\n      this.context.save();\n      this.context.setFont(this.font.family, this.font.size, this.font.weight);\n      this.context.fillText('R', x + text_shift_x, text_y);\n      this.context.restore();\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/strokes.js"],"names":["Vex","Modifier","StaveNote","Glyph","Stroke","CATEGORY","Type","BRUSH_DOWN","BRUSH_UP","ROLL_DOWN","ROLL_UP","RASQUEDO_DOWN","RASQUEDO_UP","ARPEGGIO_DIRECTIONLESS","format","strokes","state","left_shift","stroke_spacing","length","strokeList","map","stroke","note","getNote","line","getKeyProps","getIndex","shift","getLeftDisplacedHeadPx","str","string","getPositions","strokeShift","xShift","reduce","setXShift","Math","max","getWidth","constructor","type","options","setAttribute","Merge","all_voices","note_end","index","position","Position","LEFT","render_options","font_scale","stroke_px","font","family","size","weight","setWidth","getCategory","getPosition","addEndNote","draw","checkContext","setRendered","RERR","start","getModifierStartXY","ys","getYs","topY","y","botY","x","line_space","stave","spacing_between_lines_px","notes","getModifierContext","getModifiers","i","n","Min","Max","arrow","arrow_shift_x","arrow_y","text_shift_x","text_y","x_shift","strokeLine","context","fillRect","renderGlyph","category","save","setFont","fillText","restore"],"mappings":"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","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n// Author: Larry Kuhns\n//\n// ## Description\n// This file implements the `Stroke` class which renders chord strokes\n// that can be arpeggiated, brushed, rasquedo, etc.\n\nimport { Vex } from './vex';\nimport { Modifier } from './modifier';\nimport { StaveNote } from './stavenote';\nimport { Glyph } from './glyph';\n\nexport class Stroke extends Modifier {\n  static get CATEGORY() { return 'strokes'; }\n  static get Type() {\n    return {\n      BRUSH_DOWN: 1,\n      BRUSH_UP: 2,\n      ROLL_DOWN: 3, // Arpeggiated chord\n      ROLL_UP: 4,   // Arpeggiated chord\n      RASQUEDO_DOWN: 5,\n      RASQUEDO_UP: 6,\n      ARPEGGIO_DIRECTIONLESS: 7, // Arpeggiated chord without upwards or downwards arrow\n    };\n  }\n\n  // Arrange strokes inside `ModifierContext`\n  static format(strokes, state) {\n    const left_shift = state.left_shift;\n    const stroke_spacing = 0;\n\n    if (!strokes || strokes.length === 0) return this;\n\n    const strokeList = strokes.map((stroke) => {\n      const note = stroke.getNote();\n      if (note instanceof StaveNote) {\n        const { line } = note.getKeyProps()[stroke.getIndex()];\n        const shift = note.getLeftDisplacedHeadPx();\n        return { line, shift, stroke };\n      } else {\n        const { str: string } = note.getPositions()[stroke.getIndex()];\n        return { line: string, shift: 0, stroke };\n      }\n    });\n\n    const strokeShift = left_shift;\n\n    // There can only be one stroke .. if more than one, they overlay each other\n    const xShift = strokeList.reduce((xShift, { stroke, shift }) => {\n      stroke.setXShift(strokeShift + shift);\n      return Math.max(stroke.getWidth() + stroke_spacing, xShift);\n    }, 0);\n\n    state.left_shift += xShift;\n    return true;\n  }\n\n  constructor(type, options) {\n    super();\n    this.setAttribute('type', 'Stroke');\n\n    this.note = null;\n    this.options = Vex.Merge({}, options);\n\n    // multi voice - span stroke across all voices if true\n    this.all_voices = 'all_voices' in this.options ? this.options.all_voices : true;\n\n    // multi voice - end note of stroke, set in draw()\n    this.note_end = null;\n    this.index = null;\n    this.type = type;\n    this.position = Modifier.Position.LEFT;\n\n    this.render_options = {\n      font_scale: 38,\n      stroke_px: 3,\n      stroke_spacing: 10,\n    };\n\n    this.font = {\n      family: 'serif',\n      size: 10,\n      weight: 'bold italic',\n    };\n\n    this.setXShift(0);\n    this.setWidth(10);\n  }\n\n  getCategory() { return Stroke.CATEGORY; }\n  getPosition() { return this.position; }\n  addEndNote(note) { this.note_end = note; return this; }\n\n  draw() {\n    this.checkContext();\n    this.setRendered();\n\n    if (!(this.note && (this.index != null))) {\n      throw new Vex.RERR('NoAttachedNote', \"Can't draw stroke without a note and index.\");\n    }\n\n    const start = this.note.getModifierStartXY(this.position, this.index);\n    let ys = this.note.getYs();\n    let topY = start.y;\n    let botY = start.y;\n    const x = start.x - 5;\n    const line_space = this.note.stave.options.spacing_between_lines_px;\n\n    const notes = this.getModifierContext().getModifiers(this.note.getCategory());\n    for (let i = 0; i < notes.length; i++) {\n      ys = notes[i].getYs();\n      for (let n = 0; n < ys.length; n++) {\n        if (this.note === notes[i] || this.all_voices) {\n          topY = Vex.Min(topY, ys[n]);\n          botY = Vex.Max(botY, ys[n]);\n        }\n      }\n    }\n\n    let arrow;\n    let arrow_shift_x;\n    let arrow_y;\n    let text_shift_x;\n    let text_y;\n\n    switch (this.type) {\n      case Stroke.Type.BRUSH_DOWN:\n        arrow = 'arrowheadBlackUp';\n        arrow_shift_x = -3;\n        arrow_y = topY - (line_space / 2) + 10;\n        botY += (line_space / 2);\n        break;\n      case Stroke.Type.BRUSH_UP:\n        arrow = 'arrowheadBlackDown';\n        arrow_shift_x = 0.5;\n        arrow_y = botY + (line_space / 2);\n        topY -= (line_space / 2);\n        break;\n      case Stroke.Type.ROLL_DOWN:\n      case Stroke.Type.RASQUEDO_DOWN:\n        arrow = 'arrowheadBlackUp';\n        arrow_shift_x = -3;\n        text_shift_x = this.x_shift + arrow_shift_x - 2;\n        if (this.note instanceof StaveNote) {\n          topY += 1.5 * line_space;\n          if ((botY - topY) % 2 !== 0) {\n            botY += 0.5 * line_space;\n          } else {\n            botY += line_space;\n          }\n          arrow_y = topY - line_space;\n          text_y = botY + line_space + 2;\n        } else {\n          topY += 1.5 * line_space;\n          botY += line_space;\n          arrow_y = topY - 0.75 * line_space;\n          text_y = botY + 0.25 * line_space;\n        }\n        break;\n      case Stroke.Type.ROLL_UP:\n      case Stroke.Type.RASQUEDO_UP:\n        arrow = 'arrowheadBlackDown';\n        arrow_shift_x = -4;\n        text_shift_x = this.x_shift + arrow_shift_x - 1;\n        if (this.note instanceof StaveNote) {\n          arrow_y = line_space / 2;\n          topY += 0.5 * line_space;\n          if ((botY - topY) % 2 === 0) {\n            botY += line_space / 2;\n          }\n          arrow_y = botY + 0.5 * line_space;\n          text_y = topY - 1.25 * line_space;\n        } else {\n          topY += 0.25 * line_space;\n          botY += 0.5 * line_space;\n          arrow_y = botY + 0.25 * line_space;\n          text_y = topY - line_space;\n        }\n        break;\n      case Stroke.Type.ARPEGGIO_DIRECTIONLESS:\n        topY += 0.5 * line_space;\n        botY += line_space; // * 0.5 can lead to slight underlap instead of overlap sometimes\n        break;\n      default:\n        throw new Vex.RERR('InvalidType', `The stroke type ${this.type} does not exist`);\n    }\n\n    let strokeLine = 'straight';\n    // Draw the stroke\n    if (this.type === Stroke.Type.BRUSH_DOWN || this.type === Stroke.Type.BRUSH_UP) {\n      this.context.fillRect(x + this.x_shift, topY, 1, botY - topY);\n    } else {\n      strokeLine = 'wiggly';\n      if (this.note instanceof StaveNote) {\n        for (let i = topY; i <= botY; i += line_space) {\n          Glyph.renderGlyph(\n            this.context,\n            x + this.x_shift - 4,\n            i,\n            this.render_options.font_scale,\n            'vexWiggleArpeggioUp'\n          );\n        }\n      } else {\n        let i;\n        for (i = topY; i <= botY; i += 10) {\n          Glyph.renderGlyph(\n            this.context,\n            x + this.x_shift - 4,\n            i,\n            this.render_options.font_scale,\n            'vexWiggleArpeggioUp'\n          );\n        }\n        if (this.type === Stroke.Type.RASQUEDO_DOWN) {\n          text_y = i + 0.25 * line_space;\n        }\n      }\n    }\n\n    if (this.type === Stroke.Type.ARPEGGIO_DIRECTIONLESS) {\n      return; // skip drawing arrow heads or text\n    }\n\n    // Draw the arrow head\n    Glyph.renderGlyph(\n      this.context,\n      x + this.x_shift + arrow_shift_x,\n      arrow_y,\n      this.render_options.font_scale,\n      arrow,\n      { category: `stroke.${arrow}.${strokeLine}` }\n    );\n\n    // Draw the rasquedo \"R\"\n    if (this.type === Stroke.Type.RASQUEDO_DOWN || this.type === Stroke.Type.RASQUEDO_UP) {\n      this.context.save();\n      this.context.setFont(this.font.family, this.font.size, this.font.weight);\n      this.context.fillText('R', x + text_shift_x, text_y);\n      this.context.restore();\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}