{"ast":null,"code":"// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n//\n// This file implements text annotations as modifiers that can be attached to\n// notes.\n//\n// See `tests/annotation_tests.js` for usage examples.\nimport { Vex } from './vex';\nimport { Flow } from './tables';\nimport { Modifier } from './modifier'; // To enable logging for this class. Set `Vex.Flow.Annotation.DEBUG` to `true`.\n\nfunction L(...args) {\n  if (Annotation.DEBUG) Vex.L('Vex.Flow.Annotation', args);\n}\n\nexport class Annotation extends Modifier {\n  static get CATEGORY() {\n    return 'annotations';\n  } // Text annotations can be positioned and justified relative to the note.\n\n\n  static get Justify() {\n    return {\n      LEFT: 1,\n      CENTER: 2,\n      RIGHT: 3,\n      CENTER_STEM: 4\n    };\n  }\n\n  static get JustifyString() {\n    return {\n      left: Annotation.Justify.LEFT,\n      right: Annotation.Justify.RIGHT,\n      center: Annotation.Justify.CENTER,\n      centerStem: Annotation.Justify.CENTER_STEM\n    };\n  }\n\n  static get VerticalJustify() {\n    return {\n      TOP: 1,\n      CENTER: 2,\n      BOTTOM: 3,\n      CENTER_STEM: 4\n    };\n  }\n\n  static get VerticalJustifyString() {\n    return {\n      above: Annotation.VerticalJustify.TOP,\n      top: Annotation.VerticalJustify.TOP,\n      below: Annotation.VerticalJustify.BOTTOM,\n      bottom: Annotation.VerticalJustify.BOTTOM,\n      center: Annotation.VerticalJustify.CENTER,\n      centerStem: Annotation.VerticalJustify.CENTER_STEM\n    };\n  } // Arrange annotations within a `ModifierContext`\n\n\n  static format(annotations, state) {\n    if (!annotations || annotations.length === 0) return false;\n    let width = 0;\n\n    for (let i = 0; i < annotations.length; ++i) {\n      const annotation = annotations[i];\n      width = Math.max(annotation.getWidth(), width);\n\n      if (annotation.getPosition() === Modifier.Position.ABOVE) {\n        annotation.setTextLine(state.top_text_line);\n        state.top_text_line++;\n      } else {\n        annotation.setTextLine(state.text_line);\n        state.text_line++;\n      }\n    }\n\n    state.left_shift += width / 2;\n    state.right_shift += width / 2;\n    return true;\n  } // ## Prototype Methods\n  //\n  // Annotations inherit from `Modifier` and is positioned correctly when\n  // in a `ModifierContext`.\n  // Create a new `Annotation` with the string `text`.\n\n\n  constructor(text) {\n    super();\n    this.setAttribute('type', 'Annotation');\n    this.note = null;\n    this.index = null;\n    this.text = text;\n    this.justification = Annotation.Justify.CENTER;\n    this.vert_justification = Annotation.VerticalJustify.TOP;\n    this.font = {\n      family: 'Arial',\n      size: 10,\n      weight: ''\n    }; // The default width is calculated from the text.\n\n    this.setWidth(Flow.textWidth(text));\n  }\n\n  getCategory() {\n    return Annotation.CATEGORY;\n  } // Set font family, size, and weight. E.g., `Arial`, `10pt`, `Bold`.\n\n\n  setFont(family, size, weight) {\n    this.font = {\n      family,\n      size,\n      weight\n    };\n    return this;\n  } // Set vertical position of text (above or below stave). `just` must be\n  // a value in `Annotation.VerticalJustify`.\n\n\n  setVerticalJustification(just) {\n    this.vert_justification = typeof just === 'string' ? Annotation.VerticalJustifyString[just] : just;\n    return this;\n  } // Get and set horizontal justification. `justification` is a value in\n  // `Annotation.Justify`.\n\n\n  getJustification() {\n    return this.justification;\n  }\n\n  setJustification(just) {\n    this.justification = typeof just === 'string' ? Annotation.JustifyString[just] : just;\n    return this;\n  } // Render text beside the note.\n\n\n  draw() {\n    this.checkContext();\n\n    if (!this.note) {\n      throw new Vex.RERR('NoNoteForAnnotation', \"Can't draw text annotation without an attached note.\");\n    }\n\n    this.setRendered();\n    const start = this.note.getModifierStartXY(Modifier.Position.ABOVE, this.index); // We're changing context parameters. Save current state.\n\n    this.context.save();\n    this.context.setFont(this.font.family, this.font.size, this.font.weight);\n    const text_width = this.context.measureText(this.text).width; // Estimate text height to be the same as the width of an 'm'.\n    //\n    // This is a hack to work around the inability to measure text height\n    // in HTML5 Canvas (and SVG).\n\n    const text_height = this.context.measureText('m').width;\n    let x;\n    let y;\n\n    if (this.justification === Annotation.Justify.LEFT) {\n      x = start.x;\n    } else if (this.justification === Annotation.Justify.RIGHT) {\n      x = start.x - text_width;\n    } else if (this.justification === Annotation.Justify.CENTER) {\n      x = start.x - text_width / 2;\n    } else\n      /* CENTER_STEM */\n      {\n        x = this.note.getStemX() - text_width / 2;\n      }\n\n    let stem_ext;\n    let spacing;\n    const has_stem = this.note.hasStem();\n    const stave = this.note.getStave(); // The position of the text varies based on whether or not the note\n    // has a stem.\n\n    if (has_stem) {\n      stem_ext = this.note.getStem().getExtents();\n      spacing = stave.getSpacingBetweenLines();\n    }\n\n    if (this.vert_justification === Annotation.VerticalJustify.BOTTOM) {\n      // HACK: We need to compensate for the text's height since its origin\n      // is bottom-right.\n      y = stave.getYForBottomText(this.text_line + Flow.TEXT_HEIGHT_OFFSET_HACK);\n\n      if (has_stem) {\n        const stem_base = this.note.getStemDirection() === 1 ? stem_ext.baseY : stem_ext.topY;\n        y = Math.max(y, stem_base + spacing * (this.text_line + 2));\n      }\n    } else if (this.vert_justification === Annotation.VerticalJustify.CENTER) {\n      const yt = this.note.getYForTopText(this.text_line) - 1;\n      const yb = stave.getYForBottomText(this.text_line);\n      y = yt + (yb - yt) / 2 + text_height / 2;\n    } else if (this.vert_justification === Annotation.VerticalJustify.TOP) {\n      y = Math.min(stave.getYForTopText(this.text_line), this.note.getYs()[0] - 10);\n\n      if (has_stem) {\n        y = Math.min(y, stem_ext.topY - 5 - spacing * this.text_line);\n      }\n    } else\n      /* CENTER_STEM */\n      {\n        const extents = this.note.getStemExtents();\n        y = extents.topY + (extents.baseY - extents.topY) / 2 + text_height / 2;\n      }\n\n    L('Rendering annotation: ', this.text, x, y);\n    this.context.fillText(this.text, x, y);\n    this.context.restore();\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/annotation.js"],"names":["Vex","Flow","Modifier","L","args","Annotation","DEBUG","CATEGORY","Justify","LEFT","CENTER","RIGHT","CENTER_STEM","JustifyString","left","right","center","centerStem","VerticalJustify","TOP","BOTTOM","VerticalJustifyString","above","top","below","bottom","format","annotations","state","length","width","i","annotation","Math","max","getWidth","getPosition","Position","ABOVE","setTextLine","top_text_line","text_line","left_shift","right_shift","constructor","text","setAttribute","note","index","justification","vert_justification","font","family","size","weight","setWidth","textWidth","getCategory","setFont","setVerticalJustification","just","getJustification","setJustification","draw","checkContext","RERR","setRendered","start","getModifierStartXY","context","save","text_width","measureText","text_height","x","y","getStemX","stem_ext","spacing","has_stem","hasStem","stave","getStave","getStem","getExtents","getSpacingBetweenLines","getYForBottomText","TEXT_HEIGHT_OFFSET_HACK","stem_base","getStemDirection","baseY","topY","yt","getYForTopText","yb","min","getYs","extents","getStemExtents","fillText","restore"],"mappings":"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","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n//\n// This file implements text annotations as modifiers that can be attached to\n// notes.\n//\n// See `tests/annotation_tests.js` for usage examples.\n\nimport { Vex } from './vex';\nimport { Flow } from './tables';\nimport { Modifier } from './modifier';\n\n// To enable logging for this class. Set `Vex.Flow.Annotation.DEBUG` to `true`.\nfunction L(...args) { if (Annotation.DEBUG) Vex.L('Vex.Flow.Annotation', args); }\n\nexport class Annotation extends Modifier {\n  static get CATEGORY() { return 'annotations'; }\n\n  // Text annotations can be positioned and justified relative to the note.\n  static get Justify() {\n    return {\n      LEFT: 1,\n      CENTER: 2,\n      RIGHT: 3,\n      CENTER_STEM: 4,\n    };\n  }\n\n  static get JustifyString() {\n    return {\n      left: Annotation.Justify.LEFT,\n      right: Annotation.Justify.RIGHT,\n      center: Annotation.Justify.CENTER,\n      centerStem: Annotation.Justify.CENTER_STEM,\n    };\n  }\n\n  static get VerticalJustify() {\n    return {\n      TOP: 1,\n      CENTER: 2,\n      BOTTOM: 3,\n      CENTER_STEM: 4,\n    };\n  }\n\n  static get VerticalJustifyString() {\n    return {\n      above: Annotation.VerticalJustify.TOP,\n      top: Annotation.VerticalJustify.TOP,\n      below: Annotation.VerticalJustify.BOTTOM,\n      bottom: Annotation.VerticalJustify.BOTTOM,\n      center: Annotation.VerticalJustify.CENTER,\n      centerStem: Annotation.VerticalJustify.CENTER_STEM,\n    };\n  }\n\n  // Arrange annotations within a `ModifierContext`\n  static format(annotations, state) {\n    if (!annotations || annotations.length === 0) return false;\n\n    let width = 0;\n    for (let i = 0; i < annotations.length; ++i) {\n      const annotation = annotations[i];\n      width = Math.max(annotation.getWidth(), width);\n      if (annotation.getPosition() === Modifier.Position.ABOVE) {\n        annotation.setTextLine(state.top_text_line);\n        state.top_text_line++;\n      } else {\n        annotation.setTextLine(state.text_line);\n        state.text_line++;\n      }\n    }\n\n    state.left_shift += width / 2;\n    state.right_shift += width / 2;\n    return true;\n  }\n\n  // ## Prototype Methods\n  //\n  // Annotations inherit from `Modifier` and is positioned correctly when\n  // in a `ModifierContext`.\n  // Create a new `Annotation` with the string `text`.\n  constructor(text) {\n    super();\n    this.setAttribute('type', 'Annotation');\n\n    this.note = null;\n    this.index = null;\n    this.text = text;\n    this.justification = Annotation.Justify.CENTER;\n    this.vert_justification = Annotation.VerticalJustify.TOP;\n    this.font = {\n      family: 'Arial',\n      size: 10,\n      weight: '',\n    };\n\n    // The default width is calculated from the text.\n    this.setWidth(Flow.textWidth(text));\n  }\n\n  getCategory() { return Annotation.CATEGORY; }\n\n  // Set font family, size, and weight. E.g., `Arial`, `10pt`, `Bold`.\n  setFont(family, size, weight) {\n    this.font = { family, size, weight };\n    return this;\n  }\n\n  // Set vertical position of text (above or below stave). `just` must be\n  // a value in `Annotation.VerticalJustify`.\n  setVerticalJustification(just) {\n    this.vert_justification = typeof (just) === 'string'\n      ? Annotation.VerticalJustifyString[just]\n      : just;\n    return this;\n  }\n\n  // Get and set horizontal justification. `justification` is a value in\n  // `Annotation.Justify`.\n  getJustification() { return this.justification; }\n  setJustification(just) {\n    this.justification = typeof (just) === 'string'\n      ? Annotation.JustifyString[just]\n      : just;\n    return this;\n  }\n\n  // Render text beside the note.\n  draw() {\n    this.checkContext();\n\n    if (!this.note) {\n      throw new Vex.RERR(\n        'NoNoteForAnnotation', \"Can't draw text annotation without an attached note.\"\n      );\n    }\n\n    this.setRendered();\n    const start = this.note.getModifierStartXY(Modifier.Position.ABOVE,\n      this.index);\n\n    // We're changing context parameters. Save current state.\n    this.context.save();\n    this.context.setFont(this.font.family, this.font.size, this.font.weight);\n    const text_width = this.context.measureText(this.text).width;\n\n    // Estimate text height to be the same as the width of an 'm'.\n    //\n    // This is a hack to work around the inability to measure text height\n    // in HTML5 Canvas (and SVG).\n    const text_height = this.context.measureText('m').width;\n    let x;\n    let y;\n\n    if (this.justification === Annotation.Justify.LEFT) {\n      x = start.x;\n    } else if (this.justification === Annotation.Justify.RIGHT) {\n      x = start.x - text_width;\n    } else if (this.justification === Annotation.Justify.CENTER) {\n      x = start.x - text_width / 2;\n    } else /* CENTER_STEM */ {\n      x = this.note.getStemX() - text_width / 2;\n    }\n\n    let stem_ext;\n    let spacing;\n    const has_stem = this.note.hasStem();\n    const stave = this.note.getStave();\n\n    // The position of the text varies based on whether or not the note\n    // has a stem.\n    if (has_stem) {\n      stem_ext = this.note.getStem().getExtents();\n      spacing = stave.getSpacingBetweenLines();\n    }\n\n    if (this.vert_justification === Annotation.VerticalJustify.BOTTOM) {\n      // HACK: We need to compensate for the text's height since its origin\n      // is bottom-right.\n      y = stave.getYForBottomText(this.text_line + Flow.TEXT_HEIGHT_OFFSET_HACK);\n      if (has_stem) {\n        const stem_base = (this.note.getStemDirection() === 1 ? stem_ext.baseY : stem_ext.topY);\n        y = Math.max(y, stem_base + (spacing * (this.text_line + 2)));\n      }\n    } else if (this.vert_justification === Annotation.VerticalJustify.CENTER) {\n      const yt = this.note.getYForTopText(this.text_line) - 1;\n      const yb = stave.getYForBottomText(this.text_line);\n      y = yt + (yb - yt) / 2 + text_height / 2;\n    } else if (this.vert_justification === Annotation.VerticalJustify.TOP) {\n      y = Math.min(stave.getYForTopText(this.text_line), this.note.getYs()[0] - 10);\n      if (has_stem) {\n        y = Math.min(y, (stem_ext.topY - 5) - (spacing * this.text_line));\n      }\n    } else /* CENTER_STEM */ {\n      const extents = this.note.getStemExtents();\n      y = extents.topY + (extents.baseY - extents.topY) / 2 +\n        text_height / 2;\n    }\n\n    L('Rendering annotation: ', this.text, x, y);\n    this.context.fillText(this.text, x, y);\n    this.context.restore();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}