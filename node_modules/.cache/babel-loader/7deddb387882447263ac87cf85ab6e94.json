{"ast":null,"code":"// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n//\n// The file implements notes for Tablature notation. This consists of one or\n// more fret positions, and can either be drawn with or without stems.\n//\n// See `tests/tabnote_tests.js` for usage examples\nimport { Vex } from './vex';\nimport { Flow } from './tables';\nimport { Modifier } from './modifier';\nimport { Stem } from './stem';\nimport { StemmableNote } from './stemmablenote';\nimport { Dot } from './dot';\nimport { Glyph } from './glyph'; // Gets the unused strings grouped together if consecutive.\n//\n// Parameters:\n// * num_lines - The number of lines\n// * strings_used - An array of numbers representing which strings have fret positions\n\nfunction getUnusedStringGroups(num_lines, strings_used) {\n  const stem_through = [];\n  let group = [];\n\n  for (let string = 1; string <= num_lines; string++) {\n    const is_used = strings_used.indexOf(string) > -1;\n\n    if (!is_used) {\n      group.push(string);\n    } else {\n      stem_through.push(group);\n      group = [];\n    }\n  }\n\n  if (group.length > 0) stem_through.push(group);\n  return stem_through;\n} // Gets groups of points that outline the partial stem lines\n// between fret positions\n//\n// Parameters:\n// * stem_Y - The `y` coordinate the stem is located on\n// * unused_strings - An array of groups of unused strings\n// * stave - The stave to use for reference\n// * stem_direction - The direction of the stem\n\n\nfunction getPartialStemLines(stem_y, unused_strings, stave, stem_direction) {\n  const up_stem = stem_direction !== 1;\n  const down_stem = stem_direction !== -1;\n  const line_spacing = stave.getSpacingBetweenLines();\n  const total_lines = stave.getNumLines();\n  const stem_lines = [];\n  unused_strings.forEach(strings => {\n    const containsLastString = strings.indexOf(total_lines) > -1;\n    const containsFirstString = strings.indexOf(1) > -1;\n\n    if (up_stem && containsFirstString || down_stem && containsLastString) {\n      return;\n    } // If there's only one string in the group, push a duplicate value.\n    // We do this because we need 2 strings to convert into upper/lower y\n    // values.\n\n\n    if (strings.length === 1) {\n      strings.push(strings[0]);\n    }\n\n    const line_ys = []; // Iterate through each group string and store it's y position\n\n    strings.forEach((string, index, strings) => {\n      const isTopBound = string === 1;\n      const isBottomBound = string === total_lines; // Get the y value for the appropriate staff line,\n      // we adjust for a 0 index array, since string numbers are index 1\n\n      let y = stave.getYForLine(string - 1); // Unless the string is the first or last, add padding to each side\n      // of the line\n\n      if (index === 0 && !isTopBound) {\n        y -= line_spacing / 2 - 1;\n      } else if (index === strings.length - 1 && !isBottomBound) {\n        y += line_spacing / 2 - 1;\n      } // Store the y value\n\n\n      line_ys.push(y); // Store a subsequent y value connecting this group to the main\n      // stem above/below the stave if it's the top/bottom string\n\n      if (stem_direction === 1 && isTopBound) {\n        line_ys.push(stem_y - 2);\n      } else if (stem_direction === -1 && isBottomBound) {\n        line_ys.push(stem_y + 2);\n      }\n    }); // Add the sorted y values to the\n\n    stem_lines.push(line_ys.sort((a, b) => a - b));\n  });\n  return stem_lines;\n}\n\nexport class TabNote extends StemmableNote {\n  static get CATEGORY() {\n    return 'tabnotes';\n  } // Initialize the TabNote with a `tab_struct` full of properties\n  // and whether to `draw_stem` when rendering the note\n\n\n  constructor(tab_struct, draw_stem) {\n    super(tab_struct);\n    this.setAttribute('type', 'TabNote');\n    this.ghost = false; // Renders parenthesis around notes\n    // Note properties\n    //\n    // The fret positions in the note. An array of `{ str: X, fret: X }`\n\n    this.positions = tab_struct.positions; // Render Options\n\n    Vex.Merge(this.render_options, {\n      // font size for note heads and rests\n      glyph_font_scale: Flow.DEFAULT_TABLATURE_FONT_SCALE,\n      // Flag to draw a stem\n      draw_stem,\n      // Flag to draw dot modifiers\n      draw_dots: draw_stem,\n      // Flag to extend the main stem through the stave and fret positions\n      draw_stem_through_stave: false,\n      // vertical shift from stave line\n      y_shift: 0,\n      // normal glyph scale\n      scale: 1.0,\n      // default tablature font\n      font: '10pt Arial'\n    });\n    this.glyph = Flow.getGlyphProps(this.duration, this.noteType);\n\n    if (!this.glyph) {\n      throw new Vex.RuntimeError('BadArguments', `Invalid note initialization data (No glyph found): ${JSON.stringify(tab_struct)}`);\n    }\n\n    this.buildStem();\n\n    if (tab_struct.stem_direction) {\n      this.setStemDirection(tab_struct.stem_direction);\n    } else {\n      this.setStemDirection(Stem.UP);\n    } // Renders parenthesis around notes\n\n\n    this.ghost = false;\n    this.updateWidth();\n  }\n\n  reset() {\n    if (this.stave) this.setStave(this.stave);\n  } // The ModifierContext category\n\n\n  getCategory() {\n    return TabNote.CATEGORY;\n  } // Set as ghost `TabNote`, surrounds the fret positions with parenthesis.\n  // Often used for indicating frets that are being bent to\n\n\n  setGhost(ghost) {\n    this.ghost = ghost;\n    this.updateWidth();\n    return this;\n  } // Determine if the note has a stem\n\n\n  hasStem() {\n    return this.render_options.draw_stem;\n  } // Get the default stem extension for the note\n\n\n  getStemExtension() {\n    const glyph = this.getGlyph();\n\n    if (this.stem_extension_override != null) {\n      return this.stem_extension_override;\n    }\n\n    if (glyph) {\n      return this.getStemDirection() === 1 ? glyph.tabnote_stem_up_extension : glyph.tabnote_stem_down_extension;\n    }\n\n    return 0;\n  } // Add a dot to the note\n\n\n  addDot() {\n    const dot = new Dot();\n    this.dots += 1;\n    return this.addModifier(dot, 0);\n  } // Calculate and store the width of the note\n\n\n  updateWidth() {\n    this.glyphs = [];\n    this.width = 0;\n\n    for (let i = 0; i < this.positions.length; ++i) {\n      let fret = this.positions[i].fret;\n      if (this.ghost) fret = '(' + fret + ')';\n      const glyph = Flow.tabToGlyph(fret, this.render_options.scale);\n      this.glyphs.push(glyph);\n      this.width = Math.max(glyph.getWidth(), this.width);\n    } // For some reason we associate a notehead glyph with a TabNote, and this\n    // glyph is used for certain width calculations. Of course, this is totally\n    // incorrect since a notehead is a poor approximation for the dimensions of\n    // a fret number which can have multiple digits. As a result, we must\n    // overwrite getWidth() to return the correct width\n\n\n    this.glyph.getWidth = () => this.width;\n  } // Set the `stave` to the note\n\n\n  setStave(stave) {\n    super.setStave(stave);\n    this.context = stave.context; // Calculate the fret number width based on font used\n\n    let i;\n\n    if (this.context) {\n      const ctx = this.context;\n      this.width = 0;\n\n      for (i = 0; i < this.glyphs.length; ++i) {\n        const glyph = this.glyphs[i];\n        const text = '' + glyph.text;\n\n        if (text.toUpperCase() !== 'X') {\n          ctx.save();\n          ctx.setRawFont(this.render_options.font);\n          glyph.width = ctx.measureText(text).width;\n          ctx.restore();\n\n          glyph.getWidth = () => glyph.width;\n        }\n\n        this.width = Math.max(glyph.getWidth(), this.width);\n      }\n\n      this.glyph.getWidth = () => this.width;\n    } // we subtract 1 from `line` because getYForLine expects a 0-based index,\n    // while the position.str is a 1-based index\n\n\n    const ys = this.positions.map(({\n      str: line\n    }) => stave.getYForLine(line - 1));\n    this.setYs(ys);\n\n    if (this.stem) {\n      this.stem.setYBounds(this.getStemY(), this.getStemY());\n    }\n\n    return this;\n  } // Get the fret positions for the note\n\n\n  getPositions() {\n    return this.positions;\n  } // Add self to the provided modifier context `mc`\n\n\n  addToModifierContext(mc) {\n    this.setModifierContext(mc);\n\n    for (let i = 0; i < this.modifiers.length; ++i) {\n      this.modifierContext.addModifier(this.modifiers[i]);\n    }\n\n    this.modifierContext.addModifier(this);\n    this.preFormatted = false;\n    return this;\n  } // Get the `x` coordinate to the right of the note\n\n\n  getTieRightX() {\n    let tieStartX = this.getAbsoluteX();\n    const note_glyph_width = this.glyph.getWidth();\n    tieStartX += note_glyph_width / 2;\n    tieStartX += -this.width / 2 + this.width + 2;\n    return tieStartX;\n  } // Get the `x` coordinate to the left of the note\n\n\n  getTieLeftX() {\n    let tieEndX = this.getAbsoluteX();\n    const note_glyph_width = this.glyph.getWidth();\n    tieEndX += note_glyph_width / 2;\n    tieEndX -= this.width / 2 + 2;\n    return tieEndX;\n  } // Get the default `x` and `y` coordinates for a modifier at a specific\n  // `position` at a fret position `index`\n\n\n  getModifierStartXY(position, index) {\n    if (!this.preFormatted) {\n      throw new Vex.RERR('UnformattedNote', \"Can't call GetModifierStartXY on an unformatted note\");\n    }\n\n    if (this.ys.length === 0) {\n      throw new Vex.RERR('NoYValues', 'No Y-Values calculated for this note.');\n    }\n\n    let x = 0;\n\n    if (position === Modifier.Position.LEFT) {\n      x = -1 * 2; // FIXME: modifier padding, move to font file\n    } else if (position === Modifier.Position.RIGHT) {\n      x = this.width + 2; // FIXME: modifier padding, move to font file\n    } else if (position === Modifier.Position.BELOW || position === Modifier.Position.ABOVE) {\n      const note_glyph_width = this.glyph.getWidth();\n      x = note_glyph_width / 2;\n    }\n\n    return {\n      x: this.getAbsoluteX() + x,\n      y: this.ys[index]\n    };\n  } // Get the default line for rest\n\n\n  getLineForRest() {\n    return this.positions[0].str;\n  } // Pre-render formatting\n\n\n  preFormat() {\n    if (this.preFormatted) return;\n    if (this.modifierContext) this.modifierContext.preFormat(); // width is already set during init()\n\n    this.setPreFormatted(true);\n  } // Get the x position for the stem\n\n\n  getStemX() {\n    return this.getCenterGlyphX();\n  } // Get the y position for the stem\n\n\n  getStemY() {\n    const num_lines = this.stave.getNumLines(); // The decimal staff line amounts provide optimal spacing between the\n    // fret number and the stem\n\n    const stemUpLine = -0.5;\n    const stemDownLine = num_lines - 0.5;\n    const stemStartLine = Stem.UP === this.stem_direction ? stemUpLine : stemDownLine;\n    return this.stave.getYForLine(stemStartLine);\n  } // Get the stem extents for the tabnote\n\n\n  getStemExtents() {\n    return this.stem.getExtents();\n  } // Draw the fal onto the context\n\n\n  drawFlag() {\n    const {\n      beam,\n      glyph,\n      context,\n      stem,\n      stem_direction,\n      render_options: {\n        draw_stem,\n        glyph_font_scale\n      }\n    } = this;\n    const shouldDrawFlag = beam == null && draw_stem; // Now it's the flag's turn.\n\n    if (glyph.flag && shouldDrawFlag) {\n      const flag_x = this.getStemX() + 1;\n      const flag_y = this.getStemY() - stem.getHeight();\n      const flag_code = stem_direction === Stem.DOWN ? glyph.code_flag_downstem // Down stems have flags on the left.\n      : glyph.code_flag_upstem; // Draw the Flag\n\n      Glyph.renderGlyph(context, flag_x, flag_y, glyph_font_scale, flag_code, {\n        category: 'flag.tabStem'\n      });\n    }\n  } // Render the modifiers onto the context\n\n\n  drawModifiers() {\n    // Draw the modifiers\n    this.modifiers.forEach(modifier => {\n      // Only draw the dots if enabled\n      if (modifier.getCategory() === 'dots' && !this.render_options.draw_dots) return;\n      modifier.setContext(this.context);\n      modifier.drawWithStyle();\n    });\n  } // Render the stem extension through the fret positions\n\n\n  drawStemThrough() {\n    const stem_x = this.getStemX();\n    const stem_y = this.getStemY();\n    const ctx = this.context;\n    const stem_through = this.render_options.draw_stem_through_stave;\n    const draw_stem = this.render_options.draw_stem;\n\n    if (draw_stem && stem_through) {\n      const total_lines = this.stave.getNumLines();\n      const strings_used = this.positions.map(position => position.str);\n      const unused_strings = getUnusedStringGroups(total_lines, strings_used);\n      const stem_lines = getPartialStemLines(stem_y, unused_strings, this.getStave(), this.getStemDirection());\n      ctx.save();\n      ctx.setLineWidth(Stem.WIDTH);\n      stem_lines.forEach(bounds => {\n        if (bounds.length === 0) return;\n        ctx.beginPath();\n        ctx.moveTo(stem_x, bounds[0]);\n        ctx.lineTo(stem_x, bounds[bounds.length - 1]);\n        ctx.stroke();\n        ctx.closePath();\n      });\n      ctx.restore();\n    }\n  } // Render the fret positions onto the context\n\n\n  drawPositions() {\n    const ctx = this.context;\n    const x = this.getAbsoluteX();\n    const ys = this.ys;\n\n    for (let i = 0; i < this.positions.length; ++i) {\n      const y = ys[i] + this.render_options.y_shift;\n      const glyph = this.glyphs[i]; // Center the fret text beneath the notation note head\n\n      const note_glyph_width = this.glyph.getWidth();\n      const tab_x = x + note_glyph_width / 2 - glyph.getWidth() / 2; // FIXME: Magic numbers.\n\n      ctx.clearRect(tab_x - 2, y - 3, glyph.getWidth() + 4, 6);\n\n      if (glyph.code) {\n        Glyph.renderGlyph(ctx, tab_x, y, this.render_options.glyph_font_scale * this.render_options.scale, glyph.code);\n      } else {\n        ctx.save();\n        ctx.setRawFont(this.render_options.font);\n        const text = glyph.text.toString();\n        ctx.fillText(text, tab_x, y + 5 * this.render_options.scale);\n        ctx.restore();\n      }\n    }\n  } // The main rendering function for the entire note\n\n\n  draw() {\n    this.checkContext();\n\n    if (!this.stave) {\n      throw new Vex.RERR('NoStave', \"Can't draw without a stave.\");\n    }\n\n    if (this.ys.length === 0) {\n      throw new Vex.RERR('NoYValues', \"Can't draw note without Y values.\");\n    }\n\n    this.setRendered();\n    const render_stem = this.beam == null && this.render_options.draw_stem;\n    this.drawPositions();\n    this.drawStemThrough();\n    const stem_x = this.getStemX();\n    this.stem.setNoteHeadXBounds(stem_x, stem_x);\n\n    if (render_stem) {\n      this.context.openGroup('stem', null, {\n        pointerBBox: true\n      });\n      this.stem.setContext(this.context).draw();\n      this.context.closeGroup();\n    }\n\n    this.drawFlag();\n    this.drawModifiers();\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/tabnote.js"],"names":["Vex","Flow","Modifier","Stem","StemmableNote","Dot","Glyph","getUnusedStringGroups","num_lines","strings_used","stem_through","group","string","is_used","indexOf","push","length","getPartialStemLines","stem_y","unused_strings","stave","stem_direction","up_stem","down_stem","line_spacing","getSpacingBetweenLines","total_lines","getNumLines","stem_lines","forEach","strings","containsLastString","containsFirstString","line_ys","index","isTopBound","isBottomBound","y","getYForLine","sort","a","b","TabNote","CATEGORY","constructor","tab_struct","draw_stem","setAttribute","ghost","positions","Merge","render_options","glyph_font_scale","DEFAULT_TABLATURE_FONT_SCALE","draw_dots","draw_stem_through_stave","y_shift","scale","font","glyph","getGlyphProps","duration","noteType","RuntimeError","JSON","stringify","buildStem","setStemDirection","UP","updateWidth","reset","setStave","getCategory","setGhost","hasStem","getStemExtension","getGlyph","stem_extension_override","getStemDirection","tabnote_stem_up_extension","tabnote_stem_down_extension","addDot","dot","dots","addModifier","glyphs","width","i","fret","tabToGlyph","Math","max","getWidth","context","ctx","text","toUpperCase","save","setRawFont","measureText","restore","ys","map","str","line","setYs","stem","setYBounds","getStemY","getPositions","addToModifierContext","mc","setModifierContext","modifiers","modifierContext","preFormatted","getTieRightX","tieStartX","getAbsoluteX","note_glyph_width","getTieLeftX","tieEndX","getModifierStartXY","position","RERR","x","Position","LEFT","RIGHT","BELOW","ABOVE","getLineForRest","preFormat","setPreFormatted","getStemX","getCenterGlyphX","stemUpLine","stemDownLine","stemStartLine","getStemExtents","getExtents","drawFlag","beam","shouldDrawFlag","flag","flag_x","flag_y","getHeight","flag_code","DOWN","code_flag_downstem","code_flag_upstem","renderGlyph","category","drawModifiers","modifier","setContext","drawWithStyle","drawStemThrough","stem_x","getStave","setLineWidth","WIDTH","bounds","beginPath","moveTo","lineTo","stroke","closePath","drawPositions","tab_x","clearRect","code","toString","fillText","draw","checkContext","setRendered","render_stem","setNoteHeadXBounds","openGroup","pointerBBox","closeGroup"],"mappings":"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","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n//\n// The file implements notes for Tablature notation. This consists of one or\n// more fret positions, and can either be drawn with or without stems.\n//\n// See `tests/tabnote_tests.js` for usage examples\n\nimport { Vex } from './vex';\nimport { Flow } from './tables';\nimport { Modifier } from './modifier';\nimport { Stem } from './stem';\nimport { StemmableNote } from './stemmablenote';\nimport { Dot } from './dot';\nimport { Glyph } from './glyph';\n\n// Gets the unused strings grouped together if consecutive.\n//\n// Parameters:\n// * num_lines - The number of lines\n// * strings_used - An array of numbers representing which strings have fret positions\nfunction getUnusedStringGroups(num_lines, strings_used) {\n  const stem_through = [];\n  let group = [];\n  for (let string = 1; string <= num_lines; string++) {\n    const is_used = strings_used.indexOf(string) > -1;\n\n    if (!is_used) {\n      group.push(string);\n    } else {\n      stem_through.push(group);\n      group = [];\n    }\n  }\n  if (group.length > 0) stem_through.push(group);\n\n  return stem_through;\n}\n\n// Gets groups of points that outline the partial stem lines\n// between fret positions\n//\n// Parameters:\n// * stem_Y - The `y` coordinate the stem is located on\n// * unused_strings - An array of groups of unused strings\n// * stave - The stave to use for reference\n// * stem_direction - The direction of the stem\nfunction getPartialStemLines(stem_y, unused_strings, stave, stem_direction) {\n  const up_stem = stem_direction !== 1;\n  const down_stem = stem_direction !== -1;\n\n  const line_spacing = stave.getSpacingBetweenLines();\n  const total_lines = stave.getNumLines();\n\n  const stem_lines = [];\n\n  unused_strings.forEach(strings => {\n    const containsLastString = strings.indexOf(total_lines) > -1;\n    const containsFirstString =  strings.indexOf(1) > -1;\n\n    if ((up_stem && containsFirstString) ||\n       (down_stem && containsLastString)) {\n      return;\n    }\n\n    // If there's only one string in the group, push a duplicate value.\n    // We do this because we need 2 strings to convert into upper/lower y\n    // values.\n    if (strings.length === 1) {\n      strings.push(strings[0]);\n    }\n\n    const line_ys = [];\n    // Iterate through each group string and store it's y position\n    strings.forEach((string, index, strings) => {\n      const isTopBound = string === 1;\n      const isBottomBound = string === total_lines;\n\n      // Get the y value for the appropriate staff line,\n      // we adjust for a 0 index array, since string numbers are index 1\n      let y = stave.getYForLine(string - 1);\n\n      // Unless the string is the first or last, add padding to each side\n      // of the line\n      if (index === 0 && !isTopBound) {\n        y -= line_spacing / 2 - 1;\n      } else if (index === strings.length - 1 && !isBottomBound) {\n        y += line_spacing / 2 - 1;\n      }\n\n      // Store the y value\n      line_ys.push(y);\n\n      // Store a subsequent y value connecting this group to the main\n      // stem above/below the stave if it's the top/bottom string\n      if (stem_direction === 1 && isTopBound) {\n        line_ys.push(stem_y - 2);\n      } else if (stem_direction === -1 && isBottomBound) {\n        line_ys.push(stem_y + 2);\n      }\n    });\n\n    // Add the sorted y values to the\n    stem_lines.push(line_ys.sort((a, b) => a - b));\n  });\n\n  return stem_lines;\n}\n\nexport class TabNote extends StemmableNote {\n  static get CATEGORY() { return 'tabnotes'; }\n\n  // Initialize the TabNote with a `tab_struct` full of properties\n  // and whether to `draw_stem` when rendering the note\n  constructor(tab_struct, draw_stem) {\n    super(tab_struct);\n    this.setAttribute('type', 'TabNote');\n\n    this.ghost = false; // Renders parenthesis around notes\n    // Note properties\n    //\n    // The fret positions in the note. An array of `{ str: X, fret: X }`\n    this.positions = tab_struct.positions;\n\n    // Render Options\n    Vex.Merge(this.render_options, {\n      // font size for note heads and rests\n      glyph_font_scale: Flow.DEFAULT_TABLATURE_FONT_SCALE,\n      // Flag to draw a stem\n      draw_stem,\n      // Flag to draw dot modifiers\n      draw_dots: draw_stem,\n      // Flag to extend the main stem through the stave and fret positions\n      draw_stem_through_stave: false,\n      // vertical shift from stave line\n      y_shift: 0,\n      // normal glyph scale\n      scale: 1.0,\n      // default tablature font\n      font: '10pt Arial',\n    });\n\n    this.glyph = Flow.getGlyphProps(this.duration, this.noteType);\n\n    if (!this.glyph) {\n      throw new Vex.RuntimeError(\n        'BadArguments',\n        `Invalid note initialization data (No glyph found): ${JSON.stringify(tab_struct)}`\n      );\n    }\n\n    this.buildStem();\n\n    if (tab_struct.stem_direction) {\n      this.setStemDirection(tab_struct.stem_direction);\n    } else {\n      this.setStemDirection(Stem.UP);\n    }\n\n    // Renders parenthesis around notes\n    this.ghost = false;\n    this.updateWidth();\n  }\n\n  reset() {\n    if (this.stave) this.setStave(this.stave);\n  }\n\n  // The ModifierContext category\n  getCategory() { return TabNote.CATEGORY; }\n\n  // Set as ghost `TabNote`, surrounds the fret positions with parenthesis.\n  // Often used for indicating frets that are being bent to\n  setGhost(ghost) {\n    this.ghost = ghost;\n    this.updateWidth();\n    return this;\n  }\n\n  // Determine if the note has a stem\n  hasStem() { return this.render_options.draw_stem; }\n\n  // Get the default stem extension for the note\n  getStemExtension() {\n    const glyph = this.getGlyph();\n\n    if (this.stem_extension_override != null) {\n      return this.stem_extension_override;\n    }\n\n    if (glyph) {\n      return this.getStemDirection() === 1\n        ? glyph.tabnote_stem_up_extension\n        : glyph.tabnote_stem_down_extension;\n    }\n\n    return 0;\n  }\n\n  // Add a dot to the note\n  addDot() {\n    const dot = new Dot();\n    this.dots += 1;\n    return this.addModifier(dot, 0);\n  }\n\n  // Calculate and store the width of the note\n  updateWidth() {\n    this.glyphs = [];\n    this.width = 0;\n    for (let i = 0; i < this.positions.length; ++i) {\n      let fret = this.positions[i].fret;\n      if (this.ghost) fret = '(' + fret + ')';\n      const glyph = Flow.tabToGlyph(fret, this.render_options.scale);\n      this.glyphs.push(glyph);\n      this.width = Math.max(glyph.getWidth(), this.width);\n    }\n    // For some reason we associate a notehead glyph with a TabNote, and this\n    // glyph is used for certain width calculations. Of course, this is totally\n    // incorrect since a notehead is a poor approximation for the dimensions of\n    // a fret number which can have multiple digits. As a result, we must\n    // overwrite getWidth() to return the correct width\n    this.glyph.getWidth = () => this.width;\n  }\n\n  // Set the `stave` to the note\n  setStave(stave) {\n    super.setStave(stave);\n    this.context = stave.context;\n\n    // Calculate the fret number width based on font used\n    let i;\n    if (this.context) {\n      const ctx = this.context;\n      this.width = 0;\n      for (i = 0; i < this.glyphs.length; ++i) {\n        const glyph = this.glyphs[i];\n        const text = '' + glyph.text;\n        if (text.toUpperCase() !== 'X') {\n          ctx.save();\n          ctx.setRawFont(this.render_options.font);\n          glyph.width = ctx.measureText(text).width;\n          ctx.restore();\n          glyph.getWidth = () => glyph.width;\n        }\n        this.width = Math.max(glyph.getWidth(), this.width);\n      }\n      this.glyph.getWidth = () => this.width;\n    }\n\n    // we subtract 1 from `line` because getYForLine expects a 0-based index,\n    // while the position.str is a 1-based index\n    const ys = this.positions.map(({ str: line }) => stave.getYForLine(line - 1));\n\n    this.setYs(ys);\n\n    if (this.stem) {\n      this.stem.setYBounds(this.getStemY(), this.getStemY());\n    }\n\n    return this;\n  }\n\n  // Get the fret positions for the note\n  getPositions() { return this.positions; }\n\n  // Add self to the provided modifier context `mc`\n  addToModifierContext(mc) {\n    this.setModifierContext(mc);\n    for (let i = 0; i < this.modifiers.length; ++i) {\n      this.modifierContext.addModifier(this.modifiers[i]);\n    }\n    this.modifierContext.addModifier(this);\n    this.preFormatted = false;\n    return this;\n  }\n\n  // Get the `x` coordinate to the right of the note\n  getTieRightX() {\n    let tieStartX = this.getAbsoluteX();\n    const note_glyph_width = this.glyph.getWidth();\n    tieStartX += note_glyph_width / 2;\n    tieStartX += (-this.width / 2) + this.width + 2;\n\n    return tieStartX;\n  }\n\n  // Get the `x` coordinate to the left of the note\n  getTieLeftX() {\n    let tieEndX = this.getAbsoluteX();\n    const note_glyph_width = this.glyph.getWidth();\n    tieEndX += note_glyph_width / 2;\n    tieEndX -= (this.width / 2) + 2;\n\n    return tieEndX;\n  }\n\n  // Get the default `x` and `y` coordinates for a modifier at a specific\n  // `position` at a fret position `index`\n  getModifierStartXY(position, index) {\n    if (!this.preFormatted) {\n      throw new Vex.RERR('UnformattedNote', \"Can't call GetModifierStartXY on an unformatted note\");\n    }\n\n    if (this.ys.length === 0) {\n      throw new Vex.RERR('NoYValues', 'No Y-Values calculated for this note.');\n    }\n\n    let x = 0;\n    if (position === Modifier.Position.LEFT) {\n      x = -1 * 2;  // FIXME: modifier padding, move to font file\n    } else if (position === Modifier.Position.RIGHT) {\n      x = this.width + 2; // FIXME: modifier padding, move to font file\n    } else if (position === Modifier.Position.BELOW || position === Modifier.Position.ABOVE) {\n      const note_glyph_width = this.glyph.getWidth();\n      x = note_glyph_width / 2;\n    }\n\n    return {\n      x: this.getAbsoluteX() + x,\n      y: this.ys[index],\n    };\n  }\n\n  // Get the default line for rest\n  getLineForRest() { return this.positions[0].str; }\n\n  // Pre-render formatting\n  preFormat() {\n    if (this.preFormatted) return;\n    if (this.modifierContext) this.modifierContext.preFormat();\n    // width is already set during init()\n    this.setPreFormatted(true);\n  }\n\n  // Get the x position for the stem\n  getStemX() { return this.getCenterGlyphX(); }\n\n  // Get the y position for the stem\n  getStemY() {\n    const num_lines = this.stave.getNumLines();\n\n    // The decimal staff line amounts provide optimal spacing between the\n    // fret number and the stem\n    const stemUpLine = -0.5;\n    const stemDownLine = num_lines - 0.5;\n    const stemStartLine = Stem.UP === this.stem_direction ? stemUpLine : stemDownLine;\n\n    return this.stave.getYForLine(stemStartLine);\n  }\n\n  // Get the stem extents for the tabnote\n  getStemExtents() {\n    return this.stem.getExtents();\n  }\n\n  // Draw the fal onto the context\n  drawFlag() {\n    const {\n      beam, glyph, context, stem, stem_direction,\n      render_options: { draw_stem, glyph_font_scale },\n    } = this;\n\n    const shouldDrawFlag = beam == null && draw_stem;\n\n    // Now it's the flag's turn.\n    if (glyph.flag && shouldDrawFlag) {\n      const flag_x = this.getStemX() + 1;\n      const flag_y = this.getStemY() - stem.getHeight();\n\n      const flag_code = stem_direction === Stem.DOWN\n        ? glyph.code_flag_downstem // Down stems have flags on the left.\n        : glyph.code_flag_upstem;\n\n      // Draw the Flag\n      Glyph.renderGlyph(context, flag_x, flag_y, glyph_font_scale, flag_code, { category: 'flag.tabStem' });\n    }\n  }\n\n  // Render the modifiers onto the context\n  drawModifiers() {\n    // Draw the modifiers\n    this.modifiers.forEach((modifier) => {\n      // Only draw the dots if enabled\n      if (modifier.getCategory() === 'dots' && !this.render_options.draw_dots) return;\n\n      modifier.setContext(this.context);\n      modifier.drawWithStyle();\n    });\n  }\n\n  // Render the stem extension through the fret positions\n  drawStemThrough() {\n    const stem_x = this.getStemX();\n    const stem_y = this.getStemY();\n    const ctx = this.context;\n\n    const stem_through = this.render_options.draw_stem_through_stave;\n    const draw_stem = this.render_options.draw_stem;\n    if (draw_stem && stem_through) {\n      const total_lines = this.stave.getNumLines();\n      const strings_used = this.positions.map(position => position.str);\n\n      const unused_strings = getUnusedStringGroups(total_lines, strings_used);\n      const stem_lines = getPartialStemLines(\n        stem_y,\n        unused_strings,\n        this.getStave(),\n        this.getStemDirection()\n      );\n\n      ctx.save();\n      ctx.setLineWidth(Stem.WIDTH);\n      stem_lines.forEach(bounds => {\n        if (bounds.length === 0) return;\n\n        ctx.beginPath();\n        ctx.moveTo(stem_x, bounds[0]);\n        ctx.lineTo(stem_x, bounds[bounds.length - 1]);\n        ctx.stroke();\n        ctx.closePath();\n      });\n      ctx.restore();\n    }\n  }\n\n  // Render the fret positions onto the context\n  drawPositions() {\n    const ctx = this.context;\n    const x = this.getAbsoluteX();\n    const ys = this.ys;\n    for (let i = 0; i < this.positions.length; ++i) {\n      const y = ys[i] + this.render_options.y_shift;\n      const glyph = this.glyphs[i];\n\n      // Center the fret text beneath the notation note head\n      const note_glyph_width = this.glyph.getWidth();\n      const tab_x = x + (note_glyph_width / 2) - (glyph.getWidth() / 2);\n\n      // FIXME: Magic numbers.\n      ctx.clearRect(tab_x - 2, y - 3, glyph.getWidth() + 4, 6);\n\n      if (glyph.code) {\n        Glyph.renderGlyph(ctx, tab_x, y,\n          this.render_options.glyph_font_scale * this.render_options.scale,\n          glyph.code);\n      } else {\n        ctx.save();\n        ctx.setRawFont(this.render_options.font);\n        const text = glyph.text.toString();\n        ctx.fillText(text, tab_x, y + 5 * this.render_options.scale);\n        ctx.restore();\n      }\n    }\n  }\n\n  // The main rendering function for the entire note\n  draw() {\n    this.checkContext();\n\n    if (!this.stave) {\n      throw new Vex.RERR('NoStave', \"Can't draw without a stave.\");\n    }\n\n    if (this.ys.length === 0) {\n      throw new Vex.RERR('NoYValues', \"Can't draw note without Y values.\");\n    }\n\n    this.setRendered();\n    const render_stem = this.beam == null && this.render_options.draw_stem;\n\n    this.drawPositions();\n    this.drawStemThrough();\n\n    const stem_x = this.getStemX();\n\n    this.stem.setNoteHeadXBounds(stem_x, stem_x);\n\n    if (render_stem) {\n      this.context.openGroup('stem', null, { pointerBBox: true });\n      this.stem.setContext(this.context).draw();\n      this.context.closeGroup();\n    }\n\n    this.drawFlag();\n    this.drawModifiers();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}