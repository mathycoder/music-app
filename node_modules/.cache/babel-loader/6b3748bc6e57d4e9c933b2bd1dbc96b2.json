{"ast":null,"code":"// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n// Author: Larry Kuhns.\n//\n// ## Description\n//\n// This file implements articulations and accents as modifiers that can be\n// attached to notes. The complete list of articulations is available in\n// `tables.js` under `Vex.Flow.articulationCodes`.\n//\n// See `tests/articulation_tests.js` for usage examples.\nimport { Vex } from './vex';\nimport { Flow } from './tables';\nimport { Modifier } from './modifier';\nimport { Glyph } from './glyph';\nimport { Stem } from './stem'; // To enable logging for this class. Set `Vex.Flow.Articulation.DEBUG` to `true`.\n\nfunction L(...args) {\n  if (Articulation.DEBUG) Vex.L('Vex.Flow.Articulation', args);\n}\n\nconst {\n  ABOVE,\n  BELOW\n} = Modifier.Position;\n\nconst roundToNearestHalf = (mathFn, value) => mathFn(value / 0.5) * 0.5; // This includes both staff and ledger lines\n\n\nconst isWithinLines = (line, position) => position === ABOVE ? line <= 5 : line >= 1;\n\nconst getRoundingFunction = (line, position) => {\n  if (isWithinLines(line, position)) {\n    if (position === ABOVE) {\n      return Math.ceil;\n    } else {\n      return Math.floor;\n    }\n  } else {\n    return Math.round;\n  }\n};\n\nconst snapLineToStaff = (canSitBetweenLines, line, position, offsetDirection) => {\n  // Initially, snap to nearest staff line or space\n  const snappedLine = roundToNearestHalf(getRoundingFunction(line, position), line);\n  const canSnapToStaffSpace = canSitBetweenLines && isWithinLines(snappedLine, position);\n  const onStaffLine = snappedLine % 1 === 0;\n\n  if (canSnapToStaffSpace && onStaffLine) {\n    const HALF_STAFF_SPACE = 0.5;\n    return snappedLine + HALF_STAFF_SPACE * -offsetDirection;\n  } else {\n    return snappedLine;\n  }\n};\n\nconst isStaveNote = note => {\n  const noteCategory = note.getCategory();\n  return noteCategory === 'stavenotes' || noteCategory === 'gracenotes';\n};\n\nconst getTopY = (note, textLine) => {\n  const stave = note.getStave();\n  const stemDirection = note.getStemDirection();\n  const {\n    topY: stemTipY,\n    baseY: stemBaseY\n  } = note.getStemExtents();\n\n  if (isStaveNote(note)) {\n    if (note.hasStem()) {\n      if (stemDirection === Stem.UP) {\n        return stemTipY;\n      } else {\n        return stemBaseY;\n      }\n    } else {\n      return Math.min(...note.getYs());\n    }\n  } else if (note.getCategory() === 'tabnotes') {\n    if (note.hasStem()) {\n      if (stemDirection === Stem.UP) {\n        return stemTipY;\n      } else {\n        return stave.getYForTopText(textLine);\n      }\n    } else {\n      return stave.getYForTopText(textLine);\n    }\n  } else {\n    throw new Vex.RERR('UnknownCategory', 'Only can get the top and bottom ys of stavenotes and tabnotes');\n  }\n};\n\nconst getBottomY = (note, textLine) => {\n  const stave = note.getStave();\n  const stemDirection = note.getStemDirection();\n  const {\n    topY: stemTipY,\n    baseY: stemBaseY\n  } = note.getStemExtents();\n\n  if (isStaveNote(note)) {\n    if (note.hasStem()) {\n      if (stemDirection === Stem.UP) {\n        return stemBaseY;\n      } else {\n        return stemTipY;\n      }\n    } else {\n      return Math.max(...note.getYs());\n    }\n  } else if (note.getCategory() === 'tabnotes') {\n    if (note.hasStem()) {\n      if (stemDirection === Stem.UP) {\n        return stave.getYForBottomText(textLine);\n      } else {\n        return stemTipY;\n      }\n    } else {\n      return stave.getYForBottomText(textLine);\n    }\n  } else {\n    throw new Vex.RERR('UnknownCategory', 'Only can get the top and bottom ys of stavenotes and tabnotes');\n  }\n}; // Gets the initial offset of the articulation from the y value of the starting position.\n// This is required because the top/bottom text positions already have spacing applied to\n// provide a \"visually pleasent\" default position. However the y values provided from\n// the stavenote's top/bottom do *not* have any pre-applied spacing. This function\n// normalizes this asymmetry.\n\n\nconst getInitialOffset = (note, position) => {\n  const isOnStemTip = position === ABOVE && note.getStemDirection() === Stem.UP || position === BELOW && note.getStemDirection() === Stem.DOWN;\n\n  if (isStaveNote(note)) {\n    if (note.hasStem() && isOnStemTip) {\n      return 0.5;\n    } else {\n      // this amount is larger than the stem-tip offset because we start from\n      // the center of the notehead\n      return 1;\n    }\n  } else {\n    if (note.hasStem() && isOnStemTip) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n};\n\nexport class Articulation extends Modifier {\n  static get CATEGORY() {\n    return 'articulations';\n  }\n\n  static get INITIAL_OFFSET() {\n    return -0.5;\n  } // FIXME:\n  // Most of the complex formatting logic (ie: snapping to space) is\n  // actually done in .render(). But that logic belongs in this method.\n  //\n  // Unfortunately, this isn't possible because, by this point, stem lengths\n  // have not yet been finalized. Finalized stem lengths are required to determine the\n  // initial position of any stem-side articulation.\n  //\n  // This indicates that all objects should have their stave set before being\n  // formatted. It can't be an optional if you want accurate vertical positioning.\n  // Consistently positioned articulations that play nice with other modifiers\n  // won't be possible until we stop relying on render-time formatting.\n  //\n  // Ideally, when this function has completed, the vertical articulation positions\n  // should be ready to render without further adjustment. But the current state\n  // is far from this ideal.\n\n\n  static format(articulations, state) {\n    if (!articulations || articulations.length === 0) return false;\n\n    const isAbove = artic => artic.getPosition() === ABOVE;\n\n    const isBelow = artic => artic.getPosition() === BELOW;\n\n    const margin = 0.5;\n\n    const getIncrement = (articulation, line, position) => roundToNearestHalf(getRoundingFunction(line, position), articulation.glyph.getMetrics().height / 10 + margin);\n\n    articulations.filter(isAbove).forEach(articulation => {\n      articulation.setTextLine(state.top_text_line);\n      state.top_text_line += getIncrement(articulation, state.top_text_line, ABOVE);\n    });\n    articulations.filter(isBelow).forEach(articulation => {\n      articulation.setTextLine(state.text_line);\n      state.text_line += getIncrement(articulation, state.text_line, BELOW);\n    });\n    const width = articulations.map(articulation => articulation.getWidth()).reduce((maxWidth, articWidth) => Math.max(articWidth, maxWidth));\n    state.left_shift += width / 2;\n    state.right_shift += width / 2;\n    return true;\n  }\n\n  static easyScoreHook({\n    articulations\n  }, note, builder) {\n    if (!articulations) return;\n    const articNameToCode = {\n      staccato: 'a.',\n      tenuto: 'a-'\n    };\n    articulations.split(',').map(articString => articString.trim().split('.')).map(([name, position]) => {\n      const artic = {\n        type: articNameToCode[name]\n      };\n      if (position) artic.position = Modifier.PositionString[position];\n      return builder.getFactory().Articulation(artic);\n    }).map(artic => note.addModifier(0, artic));\n  } // Create a new articulation of type `type`, which is an entry in\n  // `Vex.Flow.articulationCodes` in `tables.js`.\n\n\n  constructor(type) {\n    super();\n    this.setAttribute('type', 'Articulation');\n    this.note = null;\n    this.index = null;\n    this.type = type;\n    this.position = BELOW;\n    this.render_options = {\n      font_scale: 38\n    };\n    this.reset();\n  }\n\n  reset() {\n    this.articulation = Flow.articulationCodes(this.type);\n\n    if (!this.articulation) {\n      throw new Vex.RERR('ArgumentError', `Articulation not found: ${this.type}`);\n    }\n\n    const code = (this.position === ABOVE ? this.articulation.aboveCode : this.articulation.belowCode) || this.articulation.code;\n    this.glyph = new Glyph(code, this.render_options.font_scale);\n    this.setWidth(this.glyph.getMetrics().width);\n  }\n\n  getCategory() {\n    return Articulation.CATEGORY;\n  } // Render articulation in position next to note.\n\n\n  draw() {\n    const {\n      note,\n      index,\n      position,\n      glyph,\n      articulation: {\n        between_lines: canSitBetweenLines\n      },\n      text_line: textLine,\n      context: ctx\n    } = this;\n    this.checkContext();\n\n    if (!note || index == null) {\n      throw new Vex.RERR('NoAttachedNote', \"Can't draw Articulation without a note and index.\");\n    }\n\n    this.setRendered();\n    const stave = note.getStave();\n    const staffSpace = stave.getSpacingBetweenLines();\n    const isTab = note.getCategory() === 'tabnotes'; // Articulations are centered over/under the note head.\n\n    const {\n      x\n    } = note.getModifierStartXY(position, index);\n    const shouldSitOutsideStaff = !canSitBetweenLines || isTab;\n    const initialOffset = getInitialOffset(note, position);\n    const padding = this.musicFont.lookupMetric(`articulation.${glyph.getCode()}.padding`, 0);\n    let y = {\n      [ABOVE]: () => {\n        glyph.setOrigin(0.5, 1);\n        const y = getTopY(note, textLine) - (textLine + initialOffset) * staffSpace;\n        return shouldSitOutsideStaff ? Math.min(stave.getYForTopText(Articulation.INITIAL_OFFSET), y) : y;\n      },\n      [BELOW]: () => {\n        glyph.setOrigin(0.5, 0);\n        const y = getBottomY(note, textLine) + (textLine + initialOffset) * staffSpace;\n        return shouldSitOutsideStaff ? Math.max(stave.getYForBottomText(Articulation.INITIAL_OFFSET), y) : y;\n      }\n    }[position]();\n\n    if (!isTab) {\n      const offsetDirection = position === ABOVE ? -1 : +1;\n      const noteLine = isTab ? note.positions[index].str : note.getKeyProps()[index].line;\n      const distanceFromNote = (note.getYs()[index] - y) / staffSpace;\n      const articLine = distanceFromNote + noteLine;\n      const snappedLine = snapLineToStaff(canSitBetweenLines, articLine, position, offsetDirection);\n      if (isWithinLines(snappedLine, position)) glyph.setOrigin(0.5, 0.5);\n      y += Math.abs(snappedLine - articLine) * staffSpace * offsetDirection + padding * offsetDirection;\n    }\n\n    L(`Rendering articulation at (x: ${x}, y: ${y})`);\n    glyph.render(ctx, x, y);\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/articulation.js"],"names":["Vex","Flow","Modifier","Glyph","Stem","L","args","Articulation","DEBUG","ABOVE","BELOW","Position","roundToNearestHalf","mathFn","value","isWithinLines","line","position","getRoundingFunction","Math","ceil","floor","round","snapLineToStaff","canSitBetweenLines","offsetDirection","snappedLine","canSnapToStaffSpace","onStaffLine","HALF_STAFF_SPACE","isStaveNote","note","noteCategory","getCategory","getTopY","textLine","stave","getStave","stemDirection","getStemDirection","topY","stemTipY","baseY","stemBaseY","getStemExtents","hasStem","UP","min","getYs","getYForTopText","RERR","getBottomY","max","getYForBottomText","getInitialOffset","isOnStemTip","DOWN","CATEGORY","INITIAL_OFFSET","format","articulations","state","length","isAbove","artic","getPosition","isBelow","margin","getIncrement","articulation","glyph","getMetrics","height","filter","forEach","setTextLine","top_text_line","text_line","width","map","getWidth","reduce","maxWidth","articWidth","left_shift","right_shift","easyScoreHook","builder","articNameToCode","staccato","tenuto","split","articString","trim","name","type","PositionString","getFactory","addModifier","constructor","setAttribute","index","render_options","font_scale","reset","articulationCodes","code","aboveCode","belowCode","setWidth","draw","between_lines","context","ctx","checkContext","setRendered","staffSpace","getSpacingBetweenLines","isTab","x","getModifierStartXY","shouldSitOutsideStaff","initialOffset","padding","musicFont","lookupMetric","getCode","y","setOrigin","noteLine","positions","str","getKeyProps","distanceFromNote","articLine","abs","render"],"mappings":"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","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n// Author: Larry Kuhns.\n//\n// ## Description\n//\n// This file implements articulations and accents as modifiers that can be\n// attached to notes. The complete list of articulations is available in\n// `tables.js` under `Vex.Flow.articulationCodes`.\n//\n// See `tests/articulation_tests.js` for usage examples.\n\nimport { Vex } from './vex';\nimport { Flow } from './tables';\nimport { Modifier } from './modifier';\nimport { Glyph } from './glyph';\nimport { Stem } from './stem';\n\n// To enable logging for this class. Set `Vex.Flow.Articulation.DEBUG` to `true`.\nfunction L(...args) { if (Articulation.DEBUG) Vex.L('Vex.Flow.Articulation', args); }\n\nconst { ABOVE, BELOW } = Modifier.Position;\n\nconst roundToNearestHalf = (mathFn, value) => mathFn(value / 0.5) * 0.5;\n\n// This includes both staff and ledger lines\nconst isWithinLines = (line, position) => position === ABOVE ? line <= 5 : line >= 1;\n\nconst getRoundingFunction = (line, position) => {\n  if (isWithinLines(line, position)) {\n    if (position === ABOVE) {\n      return Math.ceil;\n    } else {\n      return Math.floor;\n    }\n  } else {\n    return Math.round;\n  }\n};\n\nconst snapLineToStaff = (canSitBetweenLines, line, position, offsetDirection) => {\n  // Initially, snap to nearest staff line or space\n  const snappedLine = roundToNearestHalf(getRoundingFunction(line, position), line);\n  const canSnapToStaffSpace = canSitBetweenLines && isWithinLines(snappedLine, position);\n  const onStaffLine = snappedLine % 1 === 0;\n\n  if (canSnapToStaffSpace && onStaffLine) {\n    const HALF_STAFF_SPACE = 0.5;\n    return snappedLine + (HALF_STAFF_SPACE * -offsetDirection);\n  } else {\n    return snappedLine;\n  }\n};\n\nconst isStaveNote = (note) => {\n  const noteCategory = note.getCategory();\n  return noteCategory === 'stavenotes' || noteCategory === 'gracenotes';\n};\n\nconst getTopY = (note, textLine) => {\n  const stave = note.getStave();\n  const stemDirection = note.getStemDirection();\n  const { topY: stemTipY, baseY: stemBaseY } = note.getStemExtents();\n\n  if (isStaveNote(note)) {\n    if (note.hasStem()) {\n      if (stemDirection === Stem.UP) {\n        return stemTipY;\n      } else {\n        return stemBaseY;\n      }\n    } else {\n      return Math.min(...note.getYs());\n    }\n  } else if (note.getCategory() === 'tabnotes') {\n    if (note.hasStem()) {\n      if (stemDirection === Stem.UP) {\n        return stemTipY;\n      } else {\n        return stave.getYForTopText(textLine);\n      }\n    } else {\n      return stave.getYForTopText(textLine);\n    }\n  } else {\n    throw new Vex.RERR(\n      'UnknownCategory', 'Only can get the top and bottom ys of stavenotes and tabnotes'\n    );\n  }\n};\n\nconst getBottomY = (note, textLine) => {\n  const stave = note.getStave();\n  const stemDirection = note.getStemDirection();\n  const { topY: stemTipY, baseY: stemBaseY } = note.getStemExtents();\n\n  if (isStaveNote(note)) {\n    if (note.hasStem()) {\n      if (stemDirection === Stem.UP) {\n        return stemBaseY;\n      } else {\n        return stemTipY;\n      }\n    } else {\n      return Math.max(...note.getYs());\n    }\n  } else if (note.getCategory() === 'tabnotes') {\n    if (note.hasStem()) {\n      if (stemDirection === Stem.UP) {\n        return stave.getYForBottomText(textLine);\n      } else {\n        return stemTipY;\n      }\n    } else {\n      return stave.getYForBottomText(textLine);\n    }\n  } else {\n    throw new Vex.RERR(\n      'UnknownCategory', 'Only can get the top and bottom ys of stavenotes and tabnotes'\n    );\n  }\n};\n\n// Gets the initial offset of the articulation from the y value of the starting position.\n// This is required because the top/bottom text positions already have spacing applied to\n// provide a \"visually pleasent\" default position. However the y values provided from\n// the stavenote's top/bottom do *not* have any pre-applied spacing. This function\n// normalizes this asymmetry.\nconst getInitialOffset = (note, position) => {\n  const isOnStemTip = (\n    (position === ABOVE && note.getStemDirection() === Stem.UP) ||\n    (position === BELOW && note.getStemDirection() === Stem.DOWN)\n  );\n\n  if (isStaveNote(note)) {\n    if (note.hasStem() && isOnStemTip) {\n      return 0.5;\n    } else {\n      // this amount is larger than the stem-tip offset because we start from\n      // the center of the notehead\n      return 1;\n    }\n  } else {\n    if (note.hasStem() && isOnStemTip) {\n      return 1;\n    } else {\n      return 0;\n    }\n  }\n};\n\nexport class Articulation extends Modifier {\n  static get CATEGORY() { return 'articulations'; }\n  static get INITIAL_OFFSET() { return -0.5; }\n\n  // FIXME:\n  // Most of the complex formatting logic (ie: snapping to space) is\n  // actually done in .render(). But that logic belongs in this method.\n  //\n  // Unfortunately, this isn't possible because, by this point, stem lengths\n  // have not yet been finalized. Finalized stem lengths are required to determine the\n  // initial position of any stem-side articulation.\n  //\n  // This indicates that all objects should have their stave set before being\n  // formatted. It can't be an optional if you want accurate vertical positioning.\n  // Consistently positioned articulations that play nice with other modifiers\n  // won't be possible until we stop relying on render-time formatting.\n  //\n  // Ideally, when this function has completed, the vertical articulation positions\n  // should be ready to render without further adjustment. But the current state\n  // is far from this ideal.\n  static format(articulations, state) {\n    if (!articulations || articulations.length === 0) return false;\n\n    const isAbove = artic => artic.getPosition() === ABOVE;\n    const isBelow = artic => artic.getPosition() === BELOW;\n    const margin = 0.5;\n    const getIncrement = (articulation, line, position) =>\n      roundToNearestHalf(\n        getRoundingFunction(line, position),\n        (articulation.glyph.getMetrics().height / 10) + margin\n      );\n\n    articulations\n      .filter(isAbove)\n      .forEach(articulation => {\n        articulation.setTextLine(state.top_text_line);\n        state.top_text_line += getIncrement(articulation, state.top_text_line, ABOVE);\n      });\n\n    articulations\n      .filter(isBelow)\n      .forEach(articulation => {\n        articulation.setTextLine(state.text_line);\n        state.text_line += getIncrement(articulation, state.text_line, BELOW);\n      });\n\n    const width = articulations\n      .map(articulation => articulation.getWidth())\n      .reduce((maxWidth, articWidth) => Math.max(articWidth, maxWidth));\n\n    state.left_shift += width / 2;\n    state.right_shift += width / 2;\n    return true;\n  }\n\n  static easyScoreHook({ articulations }, note, builder) {\n    if (!articulations) return;\n\n    const articNameToCode = {\n      staccato: 'a.',\n      tenuto: 'a-',\n    };\n\n    articulations\n      .split(',')\n      .map(articString => articString.trim().split('.'))\n      .map(([name, position]) => {\n        const artic = { type: articNameToCode[name] };\n        if (position) artic.position = Modifier.PositionString[position];\n        return builder.getFactory().Articulation(artic);\n      })\n      .map(artic => note.addModifier(0, artic));\n  }\n\n  // Create a new articulation of type `type`, which is an entry in\n  // `Vex.Flow.articulationCodes` in `tables.js`.\n  constructor(type) {\n    super();\n    this.setAttribute('type', 'Articulation');\n\n    this.note = null;\n    this.index = null;\n    this.type = type;\n    this.position = BELOW;\n    this.render_options = {\n      font_scale: 38,\n    };\n\n    this.reset();\n  }\n\n  reset() {\n    this.articulation = Flow.articulationCodes(this.type);\n    if (!this.articulation) {\n      throw new Vex.RERR('ArgumentError', `Articulation not found: ${this.type}`);\n    }\n\n    const code = (this.position === ABOVE ? this.articulation.aboveCode : this.articulation.belowCode) || this.articulation.code;\n    this.glyph = new Glyph(code, this.render_options.font_scale);\n\n    this.setWidth(this.glyph.getMetrics().width);\n  }\n\n  getCategory() { return Articulation.CATEGORY; }\n\n  // Render articulation in position next to note.\n  draw() {\n    const {\n      note, index, position, glyph,\n      articulation: { between_lines: canSitBetweenLines },\n      text_line: textLine,\n      context: ctx,\n    } = this;\n\n    this.checkContext();\n\n    if (!note || index == null) {\n      throw new Vex.RERR('NoAttachedNote', \"Can't draw Articulation without a note and index.\");\n    }\n\n    this.setRendered();\n\n    const stave = note.getStave();\n    const staffSpace = stave.getSpacingBetweenLines();\n    const isTab = note.getCategory() === 'tabnotes';\n\n    // Articulations are centered over/under the note head.\n    const { x } = note.getModifierStartXY(position, index);\n    const shouldSitOutsideStaff = !canSitBetweenLines || isTab;\n\n    const initialOffset = getInitialOffset(note, position);\n\n    const padding = this.musicFont.lookupMetric(`articulation.${glyph.getCode()}.padding`, 0);\n\n    let y = {\n      [ABOVE]: () => {\n        glyph.setOrigin(0.5, 1);\n        const y = getTopY(note, textLine) - ((textLine + initialOffset) * staffSpace);\n        return shouldSitOutsideStaff\n          ? Math.min(stave.getYForTopText(Articulation.INITIAL_OFFSET), y)\n          : y;\n      },\n      [BELOW]: () => {\n        glyph.setOrigin(0.5, 0);\n        const y = getBottomY(note, textLine) + ((textLine + initialOffset) * staffSpace);\n        return shouldSitOutsideStaff\n          ? Math.max(stave.getYForBottomText(Articulation.INITIAL_OFFSET), y)\n          : y;\n      },\n    }[position]();\n\n    if (!isTab) {\n      const offsetDirection = position === ABOVE ? -1 : +1;\n      const noteLine = isTab ? note.positions[index].str : note.getKeyProps()[index].line;\n      const distanceFromNote = (note.getYs()[index] - y) / staffSpace;\n      const articLine = distanceFromNote + noteLine;\n      const snappedLine = snapLineToStaff(canSitBetweenLines, articLine, position, offsetDirection);\n\n      if (isWithinLines(snappedLine, position)) glyph.setOrigin(0.5, 0.5);\n\n      y += Math.abs(snappedLine - articLine) * staffSpace * offsetDirection + (padding * offsetDirection);\n    }\n\n    L(`Rendering articulation at (x: ${x}, y: ${y})`);\n\n    glyph.render(ctx, x, y);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}