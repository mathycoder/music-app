{"ast":null,"code":"// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// This class implements a parser for a simple language to generate\n// VexFlow objects.\n\n/* eslint max-classes-per-file: \"off\" */\nimport { Vex } from './vex';\nimport { StaveNote } from './stavenote';\nimport { Parser } from './parser';\nimport { Articulation } from './articulation'; // To enable logging for this class. Set `Vex.Flow.EasyScore.DEBUG` to `true`.\n\nfunction L(...args) {\n  if (EasyScore.DEBUG) Vex.L('Vex.Flow.EasyScore', args);\n}\n\nexport const X = Vex.MakeException('EasyScoreError');\n\nclass Grammar {\n  constructor(builder) {\n    this.builder = builder;\n  }\n\n  begin() {\n    return this.LINE;\n  }\n\n  LINE() {\n    return {\n      expect: [this.PIECE, this.PIECES, this.EOL]\n    };\n  }\n\n  PIECE() {\n    return {\n      expect: [this.CHORDORNOTE, this.PARAMS],\n      run: () => this.builder.commitPiece()\n    };\n  }\n\n  PIECES() {\n    return {\n      expect: [this.COMMA, this.PIECE],\n      zeroOrMore: true\n    };\n  }\n\n  PARAMS() {\n    return {\n      expect: [this.DURATION, this.TYPE, this.DOTS, this.OPTS]\n    };\n  }\n\n  CHORDORNOTE() {\n    return {\n      expect: [this.CHORD, this.SINGLENOTE],\n      or: true\n    };\n  }\n\n  CHORD() {\n    return {\n      expect: [this.LPAREN, this.NOTES, this.RPAREN],\n      run: state => this.builder.addChord(state.matches[1])\n    };\n  }\n\n  NOTES() {\n    return {\n      expect: [this.NOTE],\n      oneOrMore: true\n    };\n  }\n\n  NOTE() {\n    return {\n      expect: [this.NOTENAME, this.ACCIDENTAL, this.OCTAVE]\n    };\n  }\n\n  SINGLENOTE() {\n    return {\n      expect: [this.NOTENAME, this.ACCIDENTAL, this.OCTAVE],\n      run: state => this.builder.addSingleNote(state.matches[0], state.matches[1], state.matches[2])\n    };\n  }\n\n  ACCIDENTAL() {\n    return {\n      expect: [this.ACCIDENTALS],\n      maybe: true\n    };\n  }\n\n  DOTS() {\n    return {\n      expect: [this.DOT],\n      zeroOrMore: true,\n      run: state => this.builder.setNoteDots(state.matches[0])\n    };\n  }\n\n  TYPE() {\n    return {\n      expect: [this.SLASH, this.MAYBESLASH, this.TYPES],\n      maybe: true,\n      run: state => this.builder.setNoteType(state.matches[2])\n    };\n  }\n\n  DURATION() {\n    return {\n      expect: [this.SLASH, this.DURATIONS],\n      maybe: true,\n      run: state => this.builder.setNoteDuration(state.matches[1])\n    };\n  }\n\n  OPTS() {\n    return {\n      expect: [this.LBRACKET, this.KEYVAL, this.KEYVALS, this.RBRACKET],\n      maybe: true\n    };\n  }\n\n  KEYVALS() {\n    return {\n      expect: [this.COMMA, this.KEYVAL],\n      zeroOrMore: true\n    };\n  }\n\n  KEYVAL() {\n    const unquote = str => str.slice(1, -1);\n\n    return {\n      expect: [this.KEY, this.EQUALS, this.VAL],\n      run: state => this.builder.addNoteOption(state.matches[0], unquote(state.matches[2]))\n    };\n  }\n\n  VAL() {\n    return {\n      expect: [this.SVAL, this.DVAL],\n      or: true\n    };\n  }\n\n  KEY() {\n    return {\n      token: '[a-zA-Z][a-zA-Z0-9]*'\n    };\n  }\n\n  DVAL() {\n    return {\n      token: '[\"][^\"]*[\"]'\n    };\n  }\n\n  SVAL() {\n    return {\n      token: \"['][^']*[']\"\n    };\n  }\n\n  NOTENAME() {\n    return {\n      token: '[a-gA-G]'\n    };\n  }\n\n  OCTAVE() {\n    return {\n      token: '[0-9]+'\n    };\n  }\n\n  ACCIDENTALS() {\n    return {\n      token: 'bbs|bb|bss|bs|b|db|d|##|#|n|\\\\+\\\\+-|\\\\+-|\\\\+\\\\+|\\\\+|k|o'\n    };\n  }\n\n  DURATIONS() {\n    return {\n      token: '[0-9whq]+'\n    };\n  }\n\n  TYPES() {\n    return {\n      token: '[rRsSxX]'\n    };\n  }\n\n  LPAREN() {\n    return {\n      token: '[(]'\n    };\n  }\n\n  RPAREN() {\n    return {\n      token: '[)]'\n    };\n  }\n\n  COMMA() {\n    return {\n      token: '[,]'\n    };\n  }\n\n  DOT() {\n    return {\n      token: '[.]'\n    };\n  }\n\n  SLASH() {\n    return {\n      token: '[/]'\n    };\n  }\n\n  MAYBESLASH() {\n    return {\n      token: '[/]?'\n    };\n  }\n\n  EQUALS() {\n    return {\n      token: '[=]'\n    };\n  }\n\n  LBRACKET() {\n    return {\n      token: '\\\\['\n    };\n  }\n\n  RBRACKET() {\n    return {\n      token: '\\\\]'\n    };\n  }\n\n  EOL() {\n    return {\n      token: '$'\n    };\n  }\n\n}\n\nclass Builder {\n  constructor(factory) {\n    this.factory = factory;\n    this.commitHooks = [];\n    this.reset();\n  }\n\n  reset(options = {}) {\n    this.options = {\n      stem: 'auto',\n      clef: 'treble'\n    };\n    this.elements = {\n      notes: [],\n      accidentals: []\n    };\n    this.rollingDuration = '8';\n    this.resetPiece();\n    Object.assign(this.options, options);\n  }\n\n  getFactory() {\n    return this.factory;\n  }\n\n  getElements() {\n    return this.elements;\n  }\n\n  addCommitHook(commitHook) {\n    this.commitHooks.push(commitHook);\n  }\n\n  resetPiece() {\n    L('resetPiece');\n    this.piece = {\n      chord: [],\n      duration: this.rollingDuration,\n      dots: 0,\n      type: undefined,\n      options: {}\n    };\n  }\n\n  setNoteDots(dots) {\n    L('setNoteDots:', dots);\n    if (dots) this.piece.dots = dots.length;\n  }\n\n  setNoteDuration(duration) {\n    L('setNoteDuration:', duration);\n    this.rollingDuration = this.piece.duration = duration || this.rollingDuration;\n  }\n\n  setNoteType(type) {\n    L('setNoteType:', type);\n    if (type) this.piece.type = type;\n  }\n\n  addNoteOption(key, value) {\n    L('addNoteOption: key:', key, 'value:', value);\n    this.piece.options[key] = value;\n  }\n\n  addNote(key, accid, octave) {\n    L('addNote:', key, accid, octave);\n    this.piece.chord.push({\n      key,\n      accid,\n      octave\n    });\n  }\n\n  addSingleNote(key, accid, octave) {\n    L('addSingleNote:', key, accid, octave);\n    this.addNote(key, accid, octave);\n  }\n\n  addChord(notes) {\n    L('startChord');\n\n    if (typeof notes[0] !== 'object') {\n      this.addSingleNote(notes[0]);\n    } else {\n      notes.forEach(n => {\n        if (n) this.addNote(...n);\n      });\n    }\n\n    L('endChord');\n  }\n\n  commitPiece() {\n    L('commitPiece');\n    const {\n      factory\n    } = this;\n    if (!factory) return;\n    const options = { ...this.options,\n      ...this.piece.options\n    };\n    const {\n      stem,\n      clef\n    } = options;\n    const autoStem = stem.toLowerCase() === 'auto';\n    const stemDirection = !autoStem && stem.toLowerCase() === 'up' ? StaveNote.STEM_UP : StaveNote.STEM_DOWN; // Build StaveNotes.\n\n    const {\n      chord,\n      duration,\n      dots,\n      type\n    } = this.piece;\n    const keys = chord.map(note => note.key + '/' + note.octave);\n    const note = factory.StaveNote({\n      keys,\n      duration,\n      dots,\n      type,\n      clef,\n      auto_stem: autoStem\n    });\n    if (!autoStem) note.setStemDirection(stemDirection); // Attach accidentals.\n\n    const accids = chord.map(note => note.accid || null);\n    accids.forEach((accid, i) => {\n      if (accid) note.addAccidental(i, factory.Accidental({\n        type: accid\n      }));\n    }); // Attach dots.\n\n    for (let i = 0; i < dots; i++) note.addDotToAll();\n\n    this.commitHooks.forEach(fn => fn(options, note, this));\n    this.elements.notes.push(note);\n    this.elements.accidentals.concat(accids);\n    this.resetPiece();\n  }\n\n}\n\nfunction setId({\n  id\n}, note) {\n  if (id === undefined) return;\n  note.setAttribute('id', id);\n}\n\nfunction setClass(options, note) {\n  if (!options.class) return;\n  const commaSeparatedRegex = /\\s*,\\s*/;\n  options.class.split(commaSeparatedRegex).forEach(className => note.addClass(className));\n}\n\nexport class EasyScore {\n  constructor(options = {}) {\n    this.setOptions(options);\n    this.defaults = {\n      clef: 'treble',\n      time: '4/4',\n      stem: 'auto'\n    };\n  }\n\n  set(defaults) {\n    Object.assign(this.defaults, defaults);\n    return this;\n  }\n\n  setOptions(options) {\n    this.options = {\n      factory: null,\n      builder: null,\n      commitHooks: [setId, setClass, Articulation.easyScoreHook],\n      throwOnError: false,\n      ...options\n    };\n    this.factory = this.options.factory;\n    this.builder = this.options.builder || new Builder(this.factory);\n    this.grammar = new Grammar(this.builder);\n    this.parser = new Parser(this.grammar);\n    this.options.commitHooks.forEach(commitHook => this.addCommitHook(commitHook));\n    return this;\n  }\n\n  setContext(context) {\n    if (this.factory) this.factory.setContext(context);\n    return this;\n  }\n\n  parse(line, options = {}) {\n    this.builder.reset(options);\n    const result = this.parser.parse(line);\n\n    if (!result.success && this.options.throwOnError) {\n      throw new X('Error parsing line: ' + line, result);\n    }\n\n    return result;\n  }\n\n  beam(notes, options = {}) {\n    this.factory.Beam({\n      notes,\n      options\n    });\n    return notes;\n  }\n\n  tuplet(notes, options = {}) {\n    this.factory.Tuplet({\n      notes,\n      options\n    });\n    return notes;\n  }\n\n  notes(line, options = {}) {\n    options = {\n      clef: this.defaults.clef,\n      stem: this.defaults.stem,\n      ...options\n    };\n    this.parse(line, options);\n    return this.builder.getElements().notes;\n  }\n\n  voice(notes, voiceOptions) {\n    voiceOptions = {\n      time: this.defaults.time,\n      ...voiceOptions\n    };\n    return this.factory.Voice(voiceOptions).addTickables(notes);\n  }\n\n  addCommitHook(commitHook) {\n    return this.builder.addCommitHook(commitHook);\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/easyscore.js"],"names":["Vex","StaveNote","Parser","Articulation","L","args","EasyScore","DEBUG","X","MakeException","Grammar","constructor","builder","begin","LINE","expect","PIECE","PIECES","EOL","CHORDORNOTE","PARAMS","run","commitPiece","COMMA","zeroOrMore","DURATION","TYPE","DOTS","OPTS","CHORD","SINGLENOTE","or","LPAREN","NOTES","RPAREN","state","addChord","matches","NOTE","oneOrMore","NOTENAME","ACCIDENTAL","OCTAVE","addSingleNote","ACCIDENTALS","maybe","DOT","setNoteDots","SLASH","MAYBESLASH","TYPES","setNoteType","DURATIONS","setNoteDuration","LBRACKET","KEYVAL","KEYVALS","RBRACKET","unquote","str","slice","KEY","EQUALS","VAL","addNoteOption","SVAL","DVAL","token","Builder","factory","commitHooks","reset","options","stem","clef","elements","notes","accidentals","rollingDuration","resetPiece","Object","assign","getFactory","getElements","addCommitHook","commitHook","push","piece","chord","duration","dots","type","undefined","length","key","value","addNote","accid","octave","forEach","n","autoStem","toLowerCase","stemDirection","STEM_UP","STEM_DOWN","keys","map","note","auto_stem","setStemDirection","accids","i","addAccidental","Accidental","addDotToAll","fn","concat","setId","id","setAttribute","setClass","class","commaSeparatedRegex","split","className","addClass","setOptions","defaults","time","set","easyScoreHook","throwOnError","grammar","parser","setContext","context","parse","line","result","success","beam","Beam","tuplet","Tuplet","voice","voiceOptions","Voice","addTickables"],"mappings":"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","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// This class implements a parser for a simple language to generate\n// VexFlow objects.\n\n/* eslint max-classes-per-file: \"off\" */\n\nimport { Vex } from './vex';\nimport { StaveNote } from './stavenote';\nimport { Parser } from './parser';\nimport { Articulation } from './articulation';\n\n// To enable logging for this class. Set `Vex.Flow.EasyScore.DEBUG` to `true`.\nfunction L(...args) { if (EasyScore.DEBUG) Vex.L('Vex.Flow.EasyScore', args); }\n\nexport const X = Vex.MakeException('EasyScoreError');\n\nclass Grammar {\n  constructor(builder) {\n    this.builder = builder;\n  }\n\n  begin() { return this.LINE; }\n\n  LINE() {\n    return {\n      expect: [this.PIECE, this.PIECES, this.EOL],\n    };\n  }\n  PIECE() {\n    return {\n      expect: [this.CHORDORNOTE, this.PARAMS],\n      run: () => this.builder.commitPiece(),\n    };\n  }\n  PIECES() {\n    return {\n      expect: [this.COMMA, this.PIECE],\n      zeroOrMore: true,\n    };\n  }\n  PARAMS() {\n    return {\n      expect: [this.DURATION, this.TYPE, this.DOTS, this.OPTS],\n    };\n  }\n  CHORDORNOTE() {\n    return {\n      expect: [this.CHORD, this.SINGLENOTE],\n      or: true,\n    };\n  }\n  CHORD() {\n    return {\n      expect: [this.LPAREN, this.NOTES, this.RPAREN],\n      run: (state) => this.builder.addChord(state.matches[1]),\n    };\n  }\n  NOTES() {\n    return {\n      expect: [this.NOTE],\n      oneOrMore: true,\n    };\n  }\n  NOTE() {\n    return {\n      expect: [this.NOTENAME, this.ACCIDENTAL, this.OCTAVE],\n    };\n  }\n  SINGLENOTE() {\n    return {\n      expect: [this.NOTENAME, this.ACCIDENTAL, this.OCTAVE],\n      run: (state) =>\n        this.builder.addSingleNote(state.matches[0], state.matches[1], state.matches[2]),\n    };\n  }\n  ACCIDENTAL() {\n    return {\n      expect: [this.ACCIDENTALS],\n      maybe: true,\n    };\n  }\n  DOTS() {\n    return {\n      expect: [this.DOT],\n      zeroOrMore: true,\n      run: (state) => this.builder.setNoteDots(state.matches[0]),\n    };\n  }\n  TYPE() {\n    return {\n      expect: [this.SLASH, this.MAYBESLASH, this.TYPES],\n      maybe: true,\n      run: (state) => this.builder.setNoteType(state.matches[2]),\n    };\n  }\n  DURATION() {\n    return {\n      expect: [this.SLASH, this.DURATIONS],\n      maybe: true,\n      run: (state) => this.builder.setNoteDuration(state.matches[1]),\n    };\n  }\n  OPTS() {\n    return {\n      expect: [this.LBRACKET, this.KEYVAL, this.KEYVALS, this.RBRACKET],\n      maybe: true,\n    };\n  }\n  KEYVALS() {\n    return {\n      expect: [this.COMMA, this.KEYVAL],\n      zeroOrMore: true,\n    };\n  }\n  KEYVAL() {\n    const unquote = (str) => str.slice(1, -1);\n\n    return {\n      expect: [this.KEY, this.EQUALS, this.VAL],\n      run: (state) => this.builder.addNoteOption(state.matches[0], unquote(state.matches[2])),\n    };\n  }\n  VAL() {\n    return {\n      expect: [this.SVAL, this.DVAL],\n      or: true,\n    };\n  }\n\n  KEY() { return { token: '[a-zA-Z][a-zA-Z0-9]*' }; }\n  DVAL() { return { token: '[\"][^\"]*[\"]' }; }\n  SVAL() { return { token: \"['][^']*[']\" }; }\n  NOTENAME() { return { token: '[a-gA-G]' }; }\n  OCTAVE() { return { token: '[0-9]+' }; }\n  ACCIDENTALS() { return { token: 'bbs|bb|bss|bs|b|db|d|##|#|n|\\\\+\\\\+-|\\\\+-|\\\\+\\\\+|\\\\+|k|o' }; }\n  DURATIONS() { return { token: '[0-9whq]+' }; }\n  TYPES() { return { token: '[rRsSxX]' }; }\n  LPAREN() { return { token: '[(]' }; }\n  RPAREN() { return { token: '[)]' }; }\n  COMMA() { return { token: '[,]' }; }\n  DOT() { return { token: '[.]' }; }\n  SLASH() { return { token: '[/]' }; }\n  MAYBESLASH() { return { token: '[/]?' }; }\n  EQUALS() { return { token: '[=]' }; }\n  LBRACKET() { return { token: '\\\\[' }; }\n  RBRACKET() { return { token: '\\\\]' }; }\n  EOL() { return { token: '$' }; }\n}\n\nclass Builder {\n  constructor(factory) {\n    this.factory = factory;\n    this.commitHooks = [];\n    this.reset();\n  }\n\n  reset(options = {}) {\n    this.options = {\n      stem: 'auto',\n      clef: 'treble',\n    };\n    this.elements = {\n      notes: [],\n      accidentals: [],\n    };\n    this.rollingDuration = '8';\n    this.resetPiece();\n    Object.assign(this.options, options);\n  }\n\n  getFactory() { return this.factory; }\n\n  getElements() { return this.elements; }\n\n  addCommitHook(commitHook) {\n    this.commitHooks.push(commitHook);\n  }\n\n  resetPiece() {\n    L('resetPiece');\n    this.piece = {\n      chord: [],\n      duration: this.rollingDuration,\n      dots: 0,\n      type: undefined,\n      options: {},\n    };\n  }\n\n  setNoteDots(dots) {\n    L('setNoteDots:', dots);\n    if (dots) this.piece.dots = dots.length;\n  }\n\n  setNoteDuration(duration) {\n    L('setNoteDuration:', duration);\n    this.rollingDuration = this.piece.duration = duration || this.rollingDuration;\n  }\n\n  setNoteType(type) {\n    L('setNoteType:', type);\n    if (type) this.piece.type = type;\n  }\n\n  addNoteOption(key, value) {\n    L('addNoteOption: key:', key, 'value:', value);\n    this.piece.options[key] = value;\n  }\n\n  addNote(key, accid, octave) {\n    L('addNote:', key, accid, octave);\n    this.piece.chord.push({ key, accid, octave });\n  }\n\n  addSingleNote(key, accid, octave) {\n    L('addSingleNote:', key, accid, octave);\n    this.addNote(key, accid, octave);\n  }\n\n  addChord(notes) {\n    L('startChord');\n    if (typeof (notes[0]) !== 'object') {\n      this.addSingleNote(notes[0]);\n    } else {\n      notes.forEach(n => {\n        if (n) this.addNote(...n);\n      });\n    }\n    L('endChord');\n  }\n\n  commitPiece() {\n    L('commitPiece');\n    const { factory } = this;\n\n    if (!factory) return;\n\n    const options = { ...this.options, ...this.piece.options };\n    const { stem, clef } = options;\n    const autoStem = stem.toLowerCase() === 'auto';\n    const stemDirection = !autoStem && stem.toLowerCase() === 'up'\n      ? StaveNote.STEM_UP\n      : StaveNote.STEM_DOWN;\n\n    // Build StaveNotes.\n    const { chord, duration, dots, type } = this.piece;\n    const keys = chord.map(note => note.key + '/' + note.octave);\n    const note = factory.StaveNote({\n      keys,\n      duration,\n      dots,\n      type,\n      clef,\n      auto_stem: autoStem,\n    });\n    if (!autoStem) note.setStemDirection(stemDirection);\n\n    // Attach accidentals.\n    const accids = chord.map(note => note.accid || null);\n    accids.forEach((accid, i) => {\n      if (accid) note.addAccidental(i, factory.Accidental({ type: accid }));\n    });\n\n    // Attach dots.\n    for (let i = 0; i < dots; i++) note.addDotToAll();\n\n    this.commitHooks.forEach(fn => fn(options, note, this));\n\n    this.elements.notes.push(note);\n    this.elements.accidentals.concat(accids);\n    this.resetPiece();\n  }\n}\n\nfunction setId({ id }, note) {\n  if (id === undefined) return;\n\n  note.setAttribute('id', id);\n}\n\n\nfunction setClass(options, note) {\n  if (!options.class) return;\n\n  const commaSeparatedRegex = /\\s*,\\s*/;\n\n  options.class\n    .split(commaSeparatedRegex)\n    .forEach(className => note.addClass(className));\n}\n\nexport class EasyScore {\n  constructor(options = {}) {\n    this.setOptions(options);\n    this.defaults = {\n      clef: 'treble',\n      time: '4/4',\n      stem: 'auto',\n    };\n  }\n\n  set(defaults) {\n    Object.assign(this.defaults, defaults);\n    return this;\n  }\n\n  setOptions(options) {\n    this.options = {\n      factory: null,\n      builder: null,\n      commitHooks: [\n        setId,\n        setClass,\n        Articulation.easyScoreHook,\n      ],\n      throwOnError: false, ...options\n    };\n\n    this.factory = this.options.factory;\n    this.builder = this.options.builder || new Builder(this.factory);\n    this.grammar = new Grammar(this.builder);\n    this.parser = new Parser(this.grammar);\n    this.options.commitHooks.forEach(commitHook => this.addCommitHook(commitHook));\n    return this;\n  }\n\n  setContext(context) {\n    if (this.factory) this.factory.setContext(context);\n    return this;\n  }\n\n  parse(line, options = {}) {\n    this.builder.reset(options);\n    const result = this.parser.parse(line);\n    if (!result.success && this.options.throwOnError) {\n      throw new X('Error parsing line: ' + line, result);\n    }\n    return result;\n  }\n\n  beam(notes, options = {}) {\n    this.factory.Beam({ notes, options });\n    return notes;\n  }\n\n  tuplet(notes, options = {}) {\n    this.factory.Tuplet({ notes, options });\n    return notes;\n  }\n\n  notes(line, options = {}) {\n    options = { clef: this.defaults.clef, stem: this.defaults.stem, ...options };\n    this.parse(line, options);\n    return this.builder.getElements().notes;\n  }\n\n  voice(notes, voiceOptions) {\n    voiceOptions = { time: this.defaults.time, ...voiceOptions };\n    return this.factory.Voice(voiceOptions).addTickables(notes);\n  }\n\n  addCommitHook(commitHook) {\n    return this.builder.addCommitHook(commitHook);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}