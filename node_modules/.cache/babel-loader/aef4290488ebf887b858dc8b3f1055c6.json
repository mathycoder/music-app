{"ast":null,"code":"// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n// `StemmableNote` is an abstract interface for notes with optional stems.\n// Examples of stemmable notes are `StaveNote` and `TabNote`\nimport { Vex } from './vex';\nimport { Flow } from './tables';\nimport { Stem } from './stem';\nimport { Glyph } from './glyph';\nimport { Note } from './note';\nexport class StemmableNote extends Note {\n  constructor(note_struct) {\n    super(note_struct);\n    this.setAttribute('type', 'StemmableNote');\n    this.stem = null;\n    this.stemExtensionOverride = null;\n    this.beam = null;\n  } // Get and set the note's `Stem`\n\n\n  getStem() {\n    return this.stem;\n  }\n\n  setStem(stem) {\n    this.stem = stem;\n    return this;\n  } // Builds and sets a new stem\n\n\n  buildStem() {\n    const stem = new Stem();\n    this.setStem(stem);\n    return this;\n  }\n\n  buildFlag(category = 'flag') {\n    const {\n      glyph,\n      beam\n    } = this;\n    const shouldRenderFlag = beam === null;\n\n    if (glyph && glyph.flag && shouldRenderFlag) {\n      const flagCode = this.getStemDirection() === Stem.DOWN ? glyph.code_flag_downstem : glyph.code_flag_upstem;\n      this.flag = new Glyph(flagCode, this.render_options.glyph_font_scale, {\n        category\n      });\n    }\n  } // Get the custom glyph associated with the outer note head on the base of the stem.\n\n\n  getBaseCustomNoteHeadGlyph() {\n    if (this.getStemDirection() === Stem.DOWN) {\n      return this.customGlyphs[this.customGlyphs.length - 1];\n    } else {\n      return this.customGlyphs[0];\n    }\n  } // Get the full length of stem\n\n\n  getStemLength() {\n    return Stem.HEIGHT + this.getStemExtension();\n  } // Get the number of beams for this duration\n\n\n  getBeamCount() {\n    const glyph = this.getGlyph();\n\n    if (glyph) {\n      return glyph.beam_count;\n    } else {\n      return 0;\n    }\n  } // Get the minimum length of stem\n\n\n  getStemMinumumLength() {\n    const frac = Flow.durationToFraction(this.duration);\n    let length = frac.value() <= 1 ? 0 : 20; // if note is flagged, cannot shorten beam\n\n    switch (this.duration) {\n      case '8':\n        if (this.beam == null) length = 35;\n        break;\n\n      case '16':\n        length = this.beam == null ? 35 : 25;\n        break;\n\n      case '32':\n        length = this.beam == null ? 45 : 35;\n        break;\n\n      case '64':\n        length = this.beam == null ? 50 : 40;\n        break;\n\n      case '128':\n        length = this.beam == null ? 55 : 45;\n        break;\n\n      default:\n        break;\n    }\n\n    return length;\n  } // Get/set the direction of the stem\n\n\n  getStemDirection() {\n    return this.stem_direction;\n  }\n\n  setStemDirection(direction) {\n    if (!direction) direction = Stem.UP;\n\n    if (direction !== Stem.UP && direction !== Stem.DOWN) {\n      throw new Vex.RERR('BadArgument', `Invalid stem direction: ${direction}`);\n    }\n\n    this.stem_direction = direction;\n\n    if (this.stem) {\n      this.stem.setDirection(direction);\n      this.stem.setExtension(this.getStemExtension()); // Lookup the base custom notehead (closest to the base of the stem) to extend or shorten\n      // the stem appropriately. If there's no custom note head, lookup the standard notehead.\n\n      const glyph = this.getBaseCustomNoteHeadGlyph() || this.getGlyph(); // Get the font-specific customizations for the note heads.\n\n      const offsets = this.musicFont.lookupMetric(`stem.noteHead.${glyph.code_head}`, {\n        offsetYBaseStemUp: 0,\n        offsetYTopStemUp: 0,\n        offsetYBaseStemDown: 0,\n        offsetYTopStemDown: 0\n      }); // Configure the stem to use these offsets.\n\n      this.stem.setOptions({\n        stem_up_y_offset: offsets.offsetYTopStemUp,\n        // glyph.stem_up_y_offset,\n        stem_down_y_offset: offsets.offsetYTopStemDown,\n        // glyph.stem_down_y_offset,\n        stem_up_y_base_offset: offsets.offsetYBaseStemUp,\n        // glyph.stem_up_y_base_offset,\n        stem_down_y_base_offset: offsets.offsetYBaseStemDown // glyph.stem_down_y_base_offset,\n\n      });\n    } // Reset and reformat everything.\n\n\n    this.reset();\n\n    if (this.flag) {\n      this.buildFlag();\n    }\n\n    this.beam = null;\n\n    if (this.preFormatted) {\n      this.preFormat();\n    }\n\n    return this;\n  } // Get the `x` coordinate of the stem\n\n\n  getStemX() {\n    const x_begin = this.getAbsoluteX() + this.x_shift;\n    const x_end = this.getAbsoluteX() + this.x_shift + this.getGlyphWidth();\n    const stem_x = this.stem_direction === Stem.DOWN ? x_begin : x_end;\n    return stem_x;\n  } // Get the `x` coordinate for the center of the glyph.\n  // Used for `TabNote` stems and stemlets over rests\n\n\n  getCenterGlyphX() {\n    return this.getAbsoluteX() + this.x_shift + this.getGlyphWidth() / 2;\n  } // Get the stem extension for the current duration\n\n\n  getStemExtension() {\n    const glyph = this.getGlyph();\n\n    if (this.stemExtensionOverride != null) {\n      return this.stemExtensionOverride;\n    }\n\n    if (glyph) {\n      return this.getStemDirection() === 1 ? glyph.stem_up_extension : glyph.stem_down_extension;\n    }\n\n    return 0;\n  } // Set the stem length to a specific. Will override the default length.\n\n\n  setStemLength(height) {\n    this.stemExtensionOverride = height - Stem.HEIGHT;\n    return this;\n  } // Get the top and bottom `y` values of the stem.\n\n\n  getStemExtents() {\n    return this.stem.getExtents();\n  } // Sets the current note's beam\n\n\n  setBeam(beam) {\n    this.beam = beam;\n    return this;\n  } // Get the `y` value for the top/bottom modifiers at a specific `textLine`\n\n\n  getYForTopText(textLine) {\n    const extents = this.getStemExtents();\n\n    if (this.hasStem()) {\n      return Math.min(this.stave.getYForTopText(textLine), extents.topY - this.render_options.annotation_spacing * (textLine + 1));\n    } else {\n      return this.stave.getYForTopText(textLine);\n    }\n  }\n\n  getYForBottomText(textLine) {\n    const extents = this.getStemExtents();\n\n    if (this.hasStem()) {\n      return Math.max(this.stave.getYForTopText(textLine), extents.baseY + this.render_options.annotation_spacing * textLine);\n    } else {\n      return this.stave.getYForBottomText(textLine);\n    }\n  }\n\n  hasFlag() {\n    return Flow.getGlyphProps(this.duration).flag && !this.beam;\n  } // Post format the note\n\n\n  postFormat() {\n    if (this.beam) this.beam.postFormat();\n    this.postFormatted = true;\n    return this;\n  } // Render the stem onto the canvas\n\n\n  drawStem(stem_struct) {\n    this.checkContext();\n    this.setRendered();\n    this.setStem(new Stem(stem_struct));\n    this.stem.setContext(this.context).draw();\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/stemmablenote.js"],"names":["Vex","Flow","Stem","Glyph","Note","StemmableNote","constructor","note_struct","setAttribute","stem","stemExtensionOverride","beam","getStem","setStem","buildStem","buildFlag","category","glyph","shouldRenderFlag","flag","flagCode","getStemDirection","DOWN","code_flag_downstem","code_flag_upstem","render_options","glyph_font_scale","getBaseCustomNoteHeadGlyph","customGlyphs","length","getStemLength","HEIGHT","getStemExtension","getBeamCount","getGlyph","beam_count","getStemMinumumLength","frac","durationToFraction","duration","value","stem_direction","setStemDirection","direction","UP","RERR","setDirection","setExtension","offsets","musicFont","lookupMetric","code_head","offsetYBaseStemUp","offsetYTopStemUp","offsetYBaseStemDown","offsetYTopStemDown","setOptions","stem_up_y_offset","stem_down_y_offset","stem_up_y_base_offset","stem_down_y_base_offset","reset","preFormatted","preFormat","getStemX","x_begin","getAbsoluteX","x_shift","x_end","getGlyphWidth","stem_x","getCenterGlyphX","stem_up_extension","stem_down_extension","setStemLength","height","getStemExtents","getExtents","setBeam","getYForTopText","textLine","extents","hasStem","Math","min","stave","topY","annotation_spacing","getYForBottomText","max","baseY","hasFlag","getGlyphProps","postFormat","postFormatted","drawStem","stem_struct","checkContext","setRendered","setContext","context","draw"],"mappings":"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","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n// `StemmableNote` is an abstract interface for notes with optional stems.\n// Examples of stemmable notes are `StaveNote` and `TabNote`\n\nimport { Vex } from './vex';\nimport { Flow } from './tables';\nimport { Stem } from './stem';\nimport { Glyph } from './glyph';\nimport { Note } from './note';\n\nexport class StemmableNote extends Note {\n  constructor(note_struct) {\n    super(note_struct);\n    this.setAttribute('type', 'StemmableNote');\n\n    this.stem = null;\n    this.stemExtensionOverride = null;\n    this.beam = null;\n  }\n\n  // Get and set the note's `Stem`\n  getStem() { return this.stem; }\n  setStem(stem) { this.stem = stem; return this; }\n\n  // Builds and sets a new stem\n  buildStem() {\n    const stem = new Stem();\n    this.setStem(stem);\n    return this;\n  }\n\n  buildFlag(category = 'flag') {\n    const { glyph, beam } = this;\n    const shouldRenderFlag = beam === null;\n\n    if (glyph && glyph.flag && shouldRenderFlag) {\n      const flagCode = this.getStemDirection() === Stem.DOWN\n        ? glyph.code_flag_downstem\n        : glyph.code_flag_upstem;\n\n      this.flag = new Glyph(flagCode, this.render_options.glyph_font_scale, { category });\n    }\n  }\n\n  // Get the custom glyph associated with the outer note head on the base of the stem.\n  getBaseCustomNoteHeadGlyph() {\n    if (this.getStemDirection() === Stem.DOWN) {\n      return this.customGlyphs[this.customGlyphs.length - 1];\n    } else {\n      return this.customGlyphs[0];\n    }\n  }\n\n  // Get the full length of stem\n  getStemLength() {\n    return Stem.HEIGHT + this.getStemExtension();\n  }\n\n  // Get the number of beams for this duration\n  getBeamCount() {\n    const glyph = this.getGlyph();\n\n    if (glyph) {\n      return glyph.beam_count;\n    } else {\n      return 0;\n    }\n  }\n\n  // Get the minimum length of stem\n  getStemMinumumLength() {\n    const frac = Flow.durationToFraction(this.duration);\n    let length = frac.value() <= 1 ? 0 : 20;\n    // if note is flagged, cannot shorten beam\n    switch (this.duration) {\n      case '8':\n        if (this.beam == null) length = 35;\n        break;\n      case '16':\n        length = this.beam == null ? 35 : 25;\n        break;\n      case '32':\n        length = this.beam == null ? 45 : 35;\n        break;\n      case '64':\n        length = this.beam == null ? 50 : 40;\n        break;\n      case '128':\n        length = this.beam == null ? 55 : 45;\n        break;\n      default:\n        break;\n    }\n    return length;\n  }\n\n  // Get/set the direction of the stem\n  getStemDirection() { return this.stem_direction; }\n  setStemDirection(direction) {\n    if (!direction) direction = Stem.UP;\n    if (direction !== Stem.UP && direction !== Stem.DOWN) {\n      throw new Vex.RERR('BadArgument', `Invalid stem direction: ${direction}`);\n    }\n\n    this.stem_direction = direction;\n\n    if (this.stem) {\n      this.stem.setDirection(direction);\n      this.stem.setExtension(this.getStemExtension());\n\n      // Lookup the base custom notehead (closest to the base of the stem) to extend or shorten\n      // the stem appropriately. If there's no custom note head, lookup the standard notehead.\n      const glyph = this.getBaseCustomNoteHeadGlyph() || this.getGlyph();\n\n      // Get the font-specific customizations for the note heads.\n      const offsets = this.musicFont.lookupMetric(`stem.noteHead.${glyph.code_head}`,\n        { offsetYBaseStemUp: 0, offsetYTopStemUp: 0, offsetYBaseStemDown: 0, offsetYTopStemDown: 0, });\n\n      // Configure the stem to use these offsets.\n      this.stem.setOptions({\n        stem_up_y_offset: offsets.offsetYTopStemUp, // glyph.stem_up_y_offset,\n        stem_down_y_offset: offsets.offsetYTopStemDown, // glyph.stem_down_y_offset,\n        stem_up_y_base_offset: offsets.offsetYBaseStemUp, // glyph.stem_up_y_base_offset,\n        stem_down_y_base_offset: offsets.offsetYBaseStemDown, // glyph.stem_down_y_base_offset,\n      });\n    }\n\n    // Reset and reformat everything.\n    this.reset();\n    if (this.flag) { this.buildFlag(); }\n    this.beam = null;\n    if (this.preFormatted) { this.preFormat(); }\n    return this;\n  }\n\n  // Get the `x` coordinate of the stem\n  getStemX() {\n    const x_begin = this.getAbsoluteX() + this.x_shift;\n    const x_end = this.getAbsoluteX() + this.x_shift + this.getGlyphWidth();\n    const stem_x = this.stem_direction === Stem.DOWN ? x_begin : x_end;\n    return stem_x;\n  }\n\n  // Get the `x` coordinate for the center of the glyph.\n  // Used for `TabNote` stems and stemlets over rests\n  getCenterGlyphX() {\n    return this.getAbsoluteX() + this.x_shift + (this.getGlyphWidth() / 2);\n  }\n\n  // Get the stem extension for the current duration\n  getStemExtension() {\n    const glyph = this.getGlyph();\n\n    if (this.stemExtensionOverride != null) {\n      return this.stemExtensionOverride;\n    }\n\n    if (glyph) {\n      return this.getStemDirection() === 1\n        ? glyph.stem_up_extension\n        : glyph.stem_down_extension;\n    }\n\n    return 0;\n  }\n\n  // Set the stem length to a specific. Will override the default length.\n  setStemLength(height) {\n    this.stemExtensionOverride = (height - Stem.HEIGHT);\n    return this;\n  }\n\n  // Get the top and bottom `y` values of the stem.\n  getStemExtents() {\n    return this.stem.getExtents();\n  }\n\n  // Sets the current note's beam\n  setBeam(beam) { this.beam = beam; return this; }\n\n  // Get the `y` value for the top/bottom modifiers at a specific `textLine`\n  getYForTopText(textLine) {\n    const extents = this.getStemExtents();\n    if (this.hasStem()) {\n      return Math.min(\n        this.stave.getYForTopText(textLine),\n        extents.topY - (this.render_options.annotation_spacing * (textLine + 1))\n      );\n    } else {\n      return this.stave.getYForTopText(textLine);\n    }\n  }\n\n  getYForBottomText(textLine) {\n    const extents = this.getStemExtents();\n    if (this.hasStem()) {\n      return Math.max(\n        this.stave.getYForTopText(textLine),\n        extents.baseY + (this.render_options.annotation_spacing * (textLine))\n      );\n    } else {\n      return this.stave.getYForBottomText(textLine);\n    }\n  }\n\n  hasFlag() {\n    return Flow.getGlyphProps(this.duration).flag && !this.beam;\n  }\n\n  // Post format the note\n  postFormat() {\n    if (this.beam) this.beam.postFormat();\n\n    this.postFormatted = true;\n\n    return this;\n  }\n\n  // Render the stem onto the canvas\n  drawStem(stem_struct) {\n    this.checkContext();\n    this.setRendered();\n\n    this.setStem(new Stem(stem_struct));\n    this.stem.setContext(this.context).draw();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}