{"ast":null,"code":"// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n// This class implements some standard music theory routines.\nimport { Vex } from './vex';\nexport class Music {\n  static get NUM_TONES() {\n    return 12;\n  }\n\n  static get roots() {\n    return ['c', 'd', 'e', 'f', 'g', 'a', 'b'];\n  }\n\n  static get root_values() {\n    return [0, 2, 4, 5, 7, 9, 11];\n  }\n\n  static get root_indices() {\n    return {\n      'c': 0,\n      'd': 1,\n      'e': 2,\n      'f': 3,\n      'g': 4,\n      'a': 5,\n      'b': 6\n    };\n  }\n\n  static get canonical_notes() {\n    return ['c', 'c#', 'd', 'd#', 'e', 'f', 'f#', 'g', 'g#', 'a', 'a#', 'b'];\n  }\n\n  static get diatonic_intervals() {\n    return ['unison', 'm2', 'M2', 'm3', 'M3', 'p4', 'dim5', 'p5', 'm6', 'M6', 'b7', 'M7', 'octave'];\n  }\n\n  static get diatonic_accidentals() {\n    return {\n      'unison': {\n        note: 0,\n        accidental: 0\n      },\n      'm2': {\n        note: 1,\n        accidental: -1\n      },\n      'M2': {\n        note: 1,\n        accidental: 0\n      },\n      'm3': {\n        note: 2,\n        accidental: -1\n      },\n      'M3': {\n        note: 2,\n        accidental: 0\n      },\n      'p4': {\n        note: 3,\n        accidental: 0\n      },\n      'dim5': {\n        note: 4,\n        accidental: -1\n      },\n      'p5': {\n        note: 4,\n        accidental: 0\n      },\n      'm6': {\n        note: 5,\n        accidental: -1\n      },\n      'M6': {\n        note: 5,\n        accidental: 0\n      },\n      'b7': {\n        note: 6,\n        accidental: -1\n      },\n      'M7': {\n        note: 6,\n        accidental: 0\n      },\n      'octave': {\n        note: 7,\n        accidental: 0\n      }\n    };\n  }\n\n  static get intervals() {\n    return {\n      'u': 0,\n      'unison': 0,\n      'm2': 1,\n      'b2': 1,\n      'min2': 1,\n      'S': 1,\n      'H': 1,\n      '2': 2,\n      'M2': 2,\n      'maj2': 2,\n      'T': 2,\n      'W': 2,\n      'm3': 3,\n      'b3': 3,\n      'min3': 3,\n      'M3': 4,\n      '3': 4,\n      'maj3': 4,\n      '4': 5,\n      'p4': 5,\n      '#4': 6,\n      'b5': 6,\n      'aug4': 6,\n      'dim5': 6,\n      '5': 7,\n      'p5': 7,\n      '#5': 8,\n      'b6': 8,\n      'aug5': 8,\n      '6': 9,\n      'M6': 9,\n      'maj6': 9,\n      'b7': 10,\n      'm7': 10,\n      'min7': 10,\n      'dom7': 10,\n      'M7': 11,\n      'maj7': 11,\n      '8': 12,\n      'octave': 12\n    };\n  }\n\n  static get scales() {\n    return {\n      major: [2, 2, 1, 2, 2, 2, 1],\n      dorian: [2, 1, 2, 2, 2, 1, 2],\n      mixolydian: [2, 2, 1, 2, 2, 1, 2],\n      minor: [2, 1, 2, 2, 1, 2, 2]\n    };\n  }\n\n  static get scaleTypes() {\n    return {\n      'M': Music.scales.major,\n      'm': Music.scales.minor\n    };\n  }\n\n  static get accidentals() {\n    return ['bb', 'b', 'n', '#', '##'];\n  }\n\n  static get noteValues() {\n    return {\n      'c': {\n        root_index: 0,\n        int_val: 0\n      },\n      'cn': {\n        root_index: 0,\n        int_val: 0\n      },\n      'c#': {\n        root_index: 0,\n        int_val: 1\n      },\n      'c##': {\n        root_index: 0,\n        int_val: 2\n      },\n      'cb': {\n        root_index: 0,\n        int_val: 11\n      },\n      'cbb': {\n        root_index: 0,\n        int_val: 10\n      },\n      'd': {\n        root_index: 1,\n        int_val: 2\n      },\n      'dn': {\n        root_index: 1,\n        int_val: 2\n      },\n      'd#': {\n        root_index: 1,\n        int_val: 3\n      },\n      'd##': {\n        root_index: 1,\n        int_val: 4\n      },\n      'db': {\n        root_index: 1,\n        int_val: 1\n      },\n      'dbb': {\n        root_index: 1,\n        int_val: 0\n      },\n      'e': {\n        root_index: 2,\n        int_val: 4\n      },\n      'en': {\n        root_index: 2,\n        int_val: 4\n      },\n      'e#': {\n        root_index: 2,\n        int_val: 5\n      },\n      'e##': {\n        root_index: 2,\n        int_val: 6\n      },\n      'eb': {\n        root_index: 2,\n        int_val: 3\n      },\n      'ebb': {\n        root_index: 2,\n        int_val: 2\n      },\n      'f': {\n        root_index: 3,\n        int_val: 5\n      },\n      'fn': {\n        root_index: 3,\n        int_val: 5\n      },\n      'f#': {\n        root_index: 3,\n        int_val: 6\n      },\n      'f##': {\n        root_index: 3,\n        int_val: 7\n      },\n      'fb': {\n        root_index: 3,\n        int_val: 4\n      },\n      'fbb': {\n        root_index: 3,\n        int_val: 3\n      },\n      'g': {\n        root_index: 4,\n        int_val: 7\n      },\n      'gn': {\n        root_index: 4,\n        int_val: 7\n      },\n      'g#': {\n        root_index: 4,\n        int_val: 8\n      },\n      'g##': {\n        root_index: 4,\n        int_val: 9\n      },\n      'gb': {\n        root_index: 4,\n        int_val: 6\n      },\n      'gbb': {\n        root_index: 4,\n        int_val: 5\n      },\n      'a': {\n        root_index: 5,\n        int_val: 9\n      },\n      'an': {\n        root_index: 5,\n        int_val: 9\n      },\n      'a#': {\n        root_index: 5,\n        int_val: 10\n      },\n      'a##': {\n        root_index: 5,\n        int_val: 11\n      },\n      'ab': {\n        root_index: 5,\n        int_val: 8\n      },\n      'abb': {\n        root_index: 5,\n        int_val: 7\n      },\n      'b': {\n        root_index: 6,\n        int_val: 11\n      },\n      'bn': {\n        root_index: 6,\n        int_val: 11\n      },\n      'b#': {\n        root_index: 6,\n        int_val: 0\n      },\n      'b##': {\n        root_index: 6,\n        int_val: 1\n      },\n      'bb': {\n        root_index: 6,\n        int_val: 10\n      },\n      'bbb': {\n        root_index: 6,\n        int_val: 9\n      }\n    };\n  }\n\n  isValidNoteValue(note) {\n    if (note == null || note < 0 || note >= Music.NUM_TONES) {\n      return false;\n    }\n\n    return true;\n  }\n\n  isValidIntervalValue(interval) {\n    return this.isValidNoteValue(interval);\n  }\n\n  getNoteParts(noteString) {\n    if (!noteString || noteString.length < 1) {\n      throw new Vex.RERR('BadArguments', 'Invalid note name: ' + noteString);\n    }\n\n    if (noteString.length > 3) {\n      throw new Vex.RERR('BadArguments', 'Invalid note name: ' + noteString);\n    }\n\n    const note = noteString.toLowerCase();\n    const regex = /^([cdefgab])(b|bb|n|#|##)?$/;\n    const match = regex.exec(note);\n\n    if (match != null) {\n      const root = match[1];\n      const accidental = match[2];\n      return {\n        root,\n        accidental\n      };\n    } else {\n      throw new Vex.RERR('BadArguments', 'Invalid note name: ' + noteString);\n    }\n  }\n\n  getKeyParts(keyString) {\n    if (!keyString || keyString.length < 1) {\n      throw new Vex.RERR('BadArguments', 'Invalid key: ' + keyString);\n    }\n\n    const key = keyString.toLowerCase(); // Support Major, Minor, Melodic Minor, and Harmonic Minor key types.\n\n    const regex = /^([cdefgab])(b|#)?(mel|harm|m|M)?$/;\n    const match = regex.exec(key);\n\n    if (match != null) {\n      const root = match[1];\n      const accidental = match[2];\n      let type = match[3]; // Unspecified type implies major\n\n      if (!type) type = 'M';\n      return {\n        root,\n        accidental,\n        type\n      };\n    } else {\n      throw new Vex.RERR('BadArguments', `Invalid key: ${keyString}`);\n    }\n  }\n\n  getNoteValue(noteString) {\n    const value = Music.noteValues[noteString];\n\n    if (value == null) {\n      throw new Vex.RERR('BadArguments', `Invalid note name: ${noteString}`);\n    }\n\n    return value.int_val;\n  }\n\n  getIntervalValue(intervalString) {\n    const value = Music.intervals[intervalString];\n\n    if (value == null) {\n      throw new Vex.RERR('BadArguments', `Invalid interval name: ${intervalString}`);\n    }\n\n    return value;\n  }\n\n  getCanonicalNoteName(noteValue) {\n    if (!this.isValidNoteValue(noteValue)) {\n      throw new Vex.RERR('BadArguments', `Invalid note value: ${noteValue}`);\n    }\n\n    return Music.canonical_notes[noteValue];\n  }\n\n  getCanonicalIntervalName(intervalValue) {\n    if (!this.isValidIntervalValue(intervalValue)) {\n      throw new Vex.RERR('BadArguments', `Invalid interval value: ${intervalValue}`);\n    }\n\n    return Music.diatonic_intervals[intervalValue];\n  }\n  /* Given a note, interval, and interval direction, product the\n   * relative note.\n   */\n\n\n  getRelativeNoteValue(noteValue, intervalValue, direction) {\n    if (direction == null) direction = 1;\n\n    if (direction !== 1 && direction !== -1) {\n      throw new Vex.RERR('BadArguments', `Invalid direction: ${direction}`);\n    }\n\n    let sum = (noteValue + direction * intervalValue) % Music.NUM_TONES;\n    if (sum < 0) sum += Music.NUM_TONES;\n    return sum;\n  }\n\n  getRelativeNoteName(root, noteValue) {\n    const parts = this.getNoteParts(root);\n    const rootValue = this.getNoteValue(parts.root);\n    let interval = noteValue - rootValue;\n\n    if (Math.abs(interval) > Music.NUM_TONES - 3) {\n      let multiplier = 1;\n      if (interval > 0) multiplier = -1; // Possibly wrap around. (Add +1 for modulo operator)\n\n      const reverse_interval = (noteValue + 1 + (rootValue + 1)) % Music.NUM_TONES * multiplier;\n\n      if (Math.abs(reverse_interval) > 2) {\n        throw new Vex.RERR('BadArguments', `Notes not related: ${root}, ${noteValue})`);\n      } else {\n        interval = reverse_interval;\n      }\n    }\n\n    if (Math.abs(interval) > 2) {\n      throw new Vex.RERR('BadArguments', `Notes not related: ${root}, ${noteValue})`);\n    }\n\n    let relativeNoteName = parts.root;\n\n    if (interval > 0) {\n      for (let i = 1; i <= interval; ++i) {\n        relativeNoteName += '#';\n      }\n    } else if (interval < 0) {\n      for (let i = -1; i >= interval; --i) {\n        relativeNoteName += 'b';\n      }\n    }\n\n    return relativeNoteName;\n  }\n  /* Return scale tones, given intervals. Each successive interval is\n   * relative to the previous one, e.g., Major Scale:\n   *\n   *   TTSTTTS = [2,2,1,2,2,2,1]\n   *\n   * When used with key = 0, returns C scale (which is isomorphic to\n   * interval list).\n   */\n\n\n  getScaleTones(key, intervals) {\n    const tones = [key];\n    let nextNote = key;\n\n    for (let i = 0; i < intervals.length; i += 1) {\n      nextNote = this.getRelativeNoteValue(nextNote, intervals[i]);\n      if (nextNote !== key) tones.push(nextNote);\n    }\n\n    return tones;\n  }\n  /* Returns the interval of a note, given a diatonic scale.\n   *\n   * E.g., Given the scale C, and the note E, returns M3\n   */\n\n\n  getIntervalBetween(note1, note2, direction) {\n    if (direction == null) direction = 1;\n\n    if (direction !== 1 && direction !== -1) {\n      throw new Vex.RERR('BadArguments', `Invalid direction: ${direction}`);\n    }\n\n    if (!this.isValidNoteValue(note1) || !this.isValidNoteValue(note2)) {\n      throw new Vex.RERR('BadArguments', `Invalid notes: ${note1}, ${note2}`);\n    }\n\n    let difference = direction === 1 ? note2 - note1 : note1 - note2;\n    if (difference < 0) difference += Music.NUM_TONES;\n    return difference;\n  } // Create a scale map that represents the pitch state for a\n  // `keySignature`. For example, passing a `G` to `keySignature` would\n  // return a scale map with every note naturalized except for `F` which\n  // has an `F#` state.\n\n\n  createScaleMap(keySignature) {\n    const keySigParts = this.getKeyParts(keySignature);\n    const scaleName = Music.scaleTypes[keySigParts.type];\n    let keySigString = keySigParts.root;\n    if (keySigParts.accidental) keySigString += keySigParts.accidental;\n    if (!scaleName) throw new Vex.RERR('BadArguments', 'Unsupported key type: ' + keySignature);\n    const scale = this.getScaleTones(this.getNoteValue(keySigString), scaleName);\n    const noteLocation = Music.root_indices[keySigParts.root];\n    const scaleMap = {};\n\n    for (let i = 0; i < Music.roots.length; ++i) {\n      const index = (noteLocation + i) % Music.roots.length;\n      const rootName = Music.roots[index];\n      let noteName = this.getRelativeNoteName(rootName, scale[i]);\n\n      if (noteName.length === 1) {\n        noteName += 'n';\n      }\n\n      scaleMap[rootName] = noteName;\n    }\n\n    return scaleMap;\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/music.js"],"names":["Vex","Music","NUM_TONES","roots","root_values","root_indices","canonical_notes","diatonic_intervals","diatonic_accidentals","note","accidental","intervals","scales","major","dorian","mixolydian","minor","scaleTypes","accidentals","noteValues","root_index","int_val","isValidNoteValue","isValidIntervalValue","interval","getNoteParts","noteString","length","RERR","toLowerCase","regex","match","exec","root","getKeyParts","keyString","key","type","getNoteValue","value","getIntervalValue","intervalString","getCanonicalNoteName","noteValue","getCanonicalIntervalName","intervalValue","getRelativeNoteValue","direction","sum","getRelativeNoteName","parts","rootValue","Math","abs","multiplier","reverse_interval","relativeNoteName","i","getScaleTones","tones","nextNote","push","getIntervalBetween","note1","note2","difference","createScaleMap","keySignature","keySigParts","scaleName","keySigString","scale","noteLocation","scaleMap","index","rootName","noteName"],"mappings":"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","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n// This class implements some standard music theory routines.\n\nimport { Vex } from './vex';\n\nexport class Music {\n  static get NUM_TONES() {\n    return 12;\n  }\n\n  static get roots() {\n    return ['c', 'd', 'e', 'f', 'g', 'a', 'b'];\n  }\n\n  static get root_values() {\n    return [0, 2, 4, 5, 7, 9, 11];\n  }\n\n  static get root_indices() {\n    return {\n      'c': 0,\n      'd': 1,\n      'e': 2,\n      'f': 3,\n      'g': 4,\n      'a': 5,\n      'b': 6,\n    };\n  }\n\n  static get canonical_notes() {\n    return [\n      'c', 'c#', 'd', 'd#',\n      'e', 'f', 'f#', 'g',\n      'g#', 'a', 'a#', 'b',\n    ];\n  }\n\n  static get diatonic_intervals() {\n    return [\n      'unison', 'm2', 'M2', 'm3', 'M3',\n      'p4', 'dim5', 'p5', 'm6', 'M6',\n      'b7', 'M7', 'octave',\n    ];\n  }\n\n  static get diatonic_accidentals() {\n    return {\n      'unison': { note: 0, accidental: 0 },\n      'm2': { note: 1, accidental: -1 },\n      'M2': { note: 1, accidental: 0 },\n      'm3': { note: 2, accidental: -1 },\n      'M3': { note: 2, accidental: 0 },\n      'p4': { note: 3, accidental: 0 },\n      'dim5': { note: 4, accidental: -1 },\n      'p5': { note: 4, accidental: 0 },\n      'm6': { note: 5, accidental: -1 },\n      'M6': { note: 5, accidental: 0 },\n      'b7': { note: 6, accidental: -1 },\n      'M7': { note: 6, accidental: 0 },\n      'octave': { note: 7, accidental: 0 },\n    };\n  }\n\n  static get intervals() {\n    return {\n      'u': 0, 'unison': 0,\n      'm2': 1, 'b2': 1, 'min2': 1, 'S': 1, 'H': 1,\n      '2': 2, 'M2': 2, 'maj2': 2, 'T': 2, 'W': 2,\n      'm3': 3, 'b3': 3, 'min3': 3,\n      'M3': 4, '3': 4, 'maj3': 4,\n      '4': 5, 'p4': 5,\n      '#4': 6, 'b5': 6, 'aug4': 6, 'dim5': 6,\n      '5': 7, 'p5': 7,\n      '#5': 8, 'b6': 8, 'aug5': 8,\n      '6': 9, 'M6': 9, 'maj6': 9,\n      'b7': 10, 'm7': 10, 'min7': 10, 'dom7': 10,\n      'M7': 11, 'maj7': 11,\n      '8': 12, 'octave': 12,\n    };\n  }\n\n  static get scales() {\n    return {\n      major: [2, 2, 1, 2, 2, 2, 1],\n      dorian: [2, 1, 2, 2, 2, 1, 2],\n      mixolydian: [2, 2, 1, 2, 2, 1, 2],\n      minor: [2, 1, 2, 2, 1, 2, 2],\n    };\n  }\n\n  static get scaleTypes() {\n    return {\n      'M': Music.scales.major,\n      'm': Music.scales.minor,\n    };\n  }\n\n  static get accidentals() {\n    return ['bb', 'b', 'n', '#', '##'];\n  }\n\n  static get noteValues() {\n    return {\n      'c': { root_index: 0, int_val: 0 },\n      'cn': { root_index: 0, int_val: 0 },\n      'c#': { root_index: 0, int_val: 1 },\n      'c##': { root_index: 0, int_val: 2 },\n      'cb': { root_index: 0, int_val: 11 },\n      'cbb': { root_index: 0, int_val: 10 },\n      'd': { root_index: 1, int_val: 2 },\n      'dn': { root_index: 1, int_val: 2 },\n      'd#': { root_index: 1, int_val: 3 },\n      'd##': { root_index: 1, int_val: 4 },\n      'db': { root_index: 1, int_val: 1 },\n      'dbb': { root_index: 1, int_val: 0 },\n      'e': { root_index: 2, int_val: 4 },\n      'en': { root_index: 2, int_val: 4 },\n      'e#': { root_index: 2, int_val: 5 },\n      'e##': { root_index: 2, int_val: 6 },\n      'eb': { root_index: 2, int_val: 3 },\n      'ebb': { root_index: 2, int_val: 2 },\n      'f': { root_index: 3, int_val: 5 },\n      'fn': { root_index: 3, int_val: 5 },\n      'f#': { root_index: 3, int_val: 6 },\n      'f##': { root_index: 3, int_val: 7 },\n      'fb': { root_index: 3, int_val: 4 },\n      'fbb': { root_index: 3, int_val: 3 },\n      'g': { root_index: 4, int_val: 7 },\n      'gn': { root_index: 4, int_val: 7 },\n      'g#': { root_index: 4, int_val: 8 },\n      'g##': { root_index: 4, int_val: 9 },\n      'gb': { root_index: 4, int_val: 6 },\n      'gbb': { root_index: 4, int_val: 5 },\n      'a': { root_index: 5, int_val: 9 },\n      'an': { root_index: 5, int_val: 9 },\n      'a#': { root_index: 5, int_val: 10 },\n      'a##': { root_index: 5, int_val: 11 },\n      'ab': { root_index: 5, int_val: 8 },\n      'abb': { root_index: 5, int_val: 7 },\n      'b': { root_index: 6, int_val: 11 },\n      'bn': { root_index: 6, int_val: 11 },\n      'b#': { root_index: 6, int_val: 0 },\n      'b##': { root_index: 6, int_val: 1 },\n      'bb': { root_index: 6, int_val: 10 },\n      'bbb': { root_index: 6, int_val: 9 },\n    };\n  }\n\n  isValidNoteValue(note) {\n    if (note == null || note < 0 || note >= Music.NUM_TONES) {\n      return false;\n    }\n    return true;\n  }\n\n  isValidIntervalValue(interval) {\n    return this.isValidNoteValue(interval);\n  }\n\n  getNoteParts(noteString) {\n    if (!noteString || noteString.length < 1) {\n      throw new Vex.RERR('BadArguments', 'Invalid note name: ' + noteString);\n    }\n\n    if (noteString.length > 3) {\n      throw new Vex.RERR('BadArguments', 'Invalid note name: ' + noteString);\n    }\n\n    const note = noteString.toLowerCase();\n\n    const regex = /^([cdefgab])(b|bb|n|#|##)?$/;\n    const match = regex.exec(note);\n\n    if (match != null) {\n      const root = match[1];\n      const accidental = match[2];\n\n      return {\n        root,\n        accidental,\n      };\n    } else {\n      throw new Vex.RERR('BadArguments', 'Invalid note name: ' + noteString);\n    }\n  }\n\n  getKeyParts(keyString) {\n    if (!keyString || keyString.length < 1) {\n      throw new Vex.RERR('BadArguments', 'Invalid key: ' + keyString);\n    }\n\n    const key = keyString.toLowerCase();\n\n    // Support Major, Minor, Melodic Minor, and Harmonic Minor key types.\n    const regex = /^([cdefgab])(b|#)?(mel|harm|m|M)?$/;\n    const match = regex.exec(key);\n\n    if (match != null) {\n      const root = match[1];\n      const accidental = match[2];\n      let type = match[3];\n\n      // Unspecified type implies major\n      if (!type) type = 'M';\n\n      return {\n        root,\n        accidental,\n        type,\n      };\n    } else {\n      throw new Vex.RERR('BadArguments', `Invalid key: ${keyString}`);\n    }\n  }\n\n  getNoteValue(noteString) {\n    const value = Music.noteValues[noteString];\n    if (value == null) {\n      throw new Vex.RERR('BadArguments', `Invalid note name: ${noteString}`);\n    }\n\n    return value.int_val;\n  }\n\n  getIntervalValue(intervalString) {\n    const value = Music.intervals[intervalString];\n    if (value == null) {\n      throw new Vex.RERR('BadArguments', `Invalid interval name: ${intervalString}`);\n    }\n\n    return value;\n  }\n\n  getCanonicalNoteName(noteValue) {\n    if (!this.isValidNoteValue(noteValue)) {\n      throw new Vex.RERR('BadArguments', `Invalid note value: ${noteValue}`);\n    }\n\n    return Music.canonical_notes[noteValue];\n  }\n\n  getCanonicalIntervalName(intervalValue) {\n    if (!this.isValidIntervalValue(intervalValue)) {\n      throw new Vex.RERR('BadArguments', `Invalid interval value: ${intervalValue}`);\n    }\n\n    return Music.diatonic_intervals[intervalValue];\n  }\n\n  /* Given a note, interval, and interval direction, product the\n   * relative note.\n   */\n  getRelativeNoteValue(noteValue, intervalValue, direction) {\n    if (direction == null) direction = 1;\n\n    if (direction !== 1 && direction !== -1) {\n      throw new Vex.RERR('BadArguments', `Invalid direction: ${direction}`);\n    }\n\n    let sum = (noteValue + (direction * intervalValue)) % Music.NUM_TONES;\n    if (sum < 0) sum += Music.NUM_TONES;\n\n    return sum;\n  }\n\n  getRelativeNoteName(root, noteValue) {\n    const parts = this.getNoteParts(root);\n    const rootValue = this.getNoteValue(parts.root);\n    let interval = noteValue - rootValue;\n\n    if (Math.abs(interval) > Music.NUM_TONES - 3) {\n      let multiplier = 1;\n      if (interval > 0) multiplier = -1;\n\n      // Possibly wrap around. (Add +1 for modulo operator)\n      const reverse_interval = (((noteValue + 1) + (rootValue + 1)) %\n        Music.NUM_TONES) * multiplier;\n\n      if (Math.abs(reverse_interval) > 2) {\n        throw new Vex.RERR('BadArguments', `Notes not related: ${root}, ${noteValue})`);\n      } else {\n        interval = reverse_interval;\n      }\n    }\n\n    if (Math.abs(interval) > 2) {\n      throw new Vex.RERR('BadArguments', `Notes not related: ${root}, ${noteValue})`);\n    }\n\n    let relativeNoteName = parts.root;\n    if (interval > 0) {\n      for (let i = 1; i <= interval; ++i) {\n        relativeNoteName += '#';\n      }\n    } else if (interval < 0) {\n      for (let i = -1; i >= interval; --i) {\n        relativeNoteName += 'b';\n      }\n    }\n\n    return relativeNoteName;\n  }\n\n  /* Return scale tones, given intervals. Each successive interval is\n   * relative to the previous one, e.g., Major Scale:\n   *\n   *   TTSTTTS = [2,2,1,2,2,2,1]\n   *\n   * When used with key = 0, returns C scale (which is isomorphic to\n   * interval list).\n   */\n  getScaleTones(key, intervals) {\n    const tones = [key];\n\n    let nextNote = key;\n    for (let i = 0; i < intervals.length; i += 1) {\n      nextNote = this.getRelativeNoteValue(nextNote, intervals[i]);\n      if (nextNote !== key) tones.push(nextNote);\n    }\n\n    return tones;\n  }\n\n  /* Returns the interval of a note, given a diatonic scale.\n   *\n   * E.g., Given the scale C, and the note E, returns M3\n   */\n  getIntervalBetween(note1, note2, direction) {\n    if (direction == null) direction = 1;\n\n    if (direction !== 1 && direction !== -1) {\n      throw new Vex.RERR('BadArguments', `Invalid direction: ${direction}`);\n    }\n\n    if (!this.isValidNoteValue(note1) || !this.isValidNoteValue(note2)) {\n      throw new Vex.RERR('BadArguments', `Invalid notes: ${note1}, ${note2}`);\n    }\n\n    let difference = direction === 1\n      ? note2 - note1\n      : note1 - note2;\n\n    if (difference < 0) difference += Music.NUM_TONES;\n\n    return difference;\n  }\n\n  // Create a scale map that represents the pitch state for a\n  // `keySignature`. For example, passing a `G` to `keySignature` would\n  // return a scale map with every note naturalized except for `F` which\n  // has an `F#` state.\n  createScaleMap(keySignature) {\n    const keySigParts = this.getKeyParts(keySignature);\n    const scaleName = Music.scaleTypes[keySigParts.type];\n\n    let keySigString = keySigParts.root;\n    if (keySigParts.accidental) keySigString += keySigParts.accidental;\n\n    if (!scaleName) throw new Vex.RERR('BadArguments', 'Unsupported key type: ' + keySignature);\n\n    const scale = this.getScaleTones(this.getNoteValue(keySigString), scaleName);\n    const noteLocation = Music.root_indices[keySigParts.root];\n\n    const scaleMap = {};\n    for (let i = 0; i < Music.roots.length; ++i) {\n      const index = (noteLocation + i) % Music.roots.length;\n      const rootName = Music.roots[index];\n      let noteName = this.getRelativeNoteName(rootName, scale[i]);\n\n      if (noteName.length === 1) {\n        noteName += 'n';\n      }\n\n      scaleMap[rootName] = noteName;\n    }\n\n    return scaleMap;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}