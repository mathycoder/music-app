{"ast":null,"code":"// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\nimport { Vex } from './vex';\nimport { Element } from './element';\nimport { Flow } from './tables';\nimport { Glyph } from './glyph';\n\nfunction drawBoldDoubleLine(ctx, type, topX, topY, botY) {\n  if (type !== StaveConnector.type.BOLD_DOUBLE_LEFT && type !== StaveConnector.type.BOLD_DOUBLE_RIGHT) {\n    throw new Vex.RERR('InvalidConnector', 'A REPEAT_BEGIN or REPEAT_END type must be provided.');\n  }\n\n  let x_shift = 3;\n  let variableWidth = 3.5; // Width for avoiding anti-aliasing width issues\n\n  const thickLineOffset = 2; // For aesthetics\n\n  if (type === StaveConnector.type.BOLD_DOUBLE_RIGHT) {\n    x_shift = -5; // Flips the side of the thin line\n\n    variableWidth = 3;\n  } // Thin line\n\n\n  ctx.fillRect(topX + x_shift, topY, 1, botY - topY); // Thick line\n\n  ctx.fillRect(topX - thickLineOffset, topY, variableWidth, botY - topY);\n}\n\nexport class StaveConnector extends Element {\n  // SINGLE_LEFT and SINGLE are the same value for compatibility\n  // with older versions of vexflow which didn't have right sided\n  // stave connectors\n  static get type() {\n    return {\n      SINGLE_RIGHT: 0,\n      SINGLE_LEFT: 1,\n      SINGLE: 1,\n      DOUBLE: 2,\n      BRACE: 3,\n      BRACKET: 4,\n      BOLD_DOUBLE_LEFT: 5,\n      BOLD_DOUBLE_RIGHT: 6,\n      THIN_DOUBLE: 7,\n      NONE: 8\n    };\n  }\n\n  static get typeString() {\n    return {\n      singleRight: StaveConnector.type.SINGLE_RIGHT,\n      singleLeft: StaveConnector.type.SINGLE_LEFT,\n      single: StaveConnector.type.SINGLE,\n      double: StaveConnector.type.DOUBLE,\n      brace: StaveConnector.type.BRACE,\n      bracket: StaveConnector.type.BRACKET,\n      boldDoubleLeft: StaveConnector.type.BOLD_DOUBLE_LEFT,\n      boldDoubleRight: StaveConnector.type.BOLD_DOUBLE_RIGHT,\n      thinDouble: StaveConnector.type.THIN_DOUBLE,\n      none: StaveConnector.type.NONE\n    };\n  }\n\n  constructor(top_stave, bottom_stave) {\n    super();\n    this.setAttribute('type', 'StaveConnector');\n    this.thickness = Flow.STAVE_LINE_THICKNESS;\n    this.width = 3;\n    this.top_stave = top_stave;\n    this.bottom_stave = bottom_stave;\n    this.type = StaveConnector.type.DOUBLE;\n    this.font = {\n      family: 'times',\n      size: 16,\n      weight: 'normal'\n    }; // 1. Offset Bold Double Left to align with offset Repeat Begin bars\n    // 2. Offset BRACE type not to overlap with another StaveConnector\n\n    this.x_shift = 0;\n    this.texts = [];\n  }\n\n  setType(type) {\n    type = typeof type === 'string' ? StaveConnector.typeString[type] : type;\n\n    if (type >= StaveConnector.type.SINGLE_RIGHT && type <= StaveConnector.type.NONE) {\n      this.type = type;\n    }\n\n    return this;\n  }\n\n  setText(text, options) {\n    this.texts.push({\n      content: text,\n      options: Vex.Merge({\n        shift_x: 0,\n        shift_y: 0\n      }, options)\n    });\n    return this;\n  }\n\n  setFont(font) {\n    Vex.Merge(this.font, font);\n  }\n\n  setXShift(x_shift) {\n    if (typeof x_shift !== 'number') {\n      throw Vex.RERR('InvalidType', 'x_shift must be a Number');\n    }\n\n    this.x_shift = x_shift;\n    return this;\n  }\n\n  draw() {\n    const ctx = this.checkContext();\n    this.setRendered();\n    let topY = this.top_stave.getYForLine(0);\n    let botY = this.bottom_stave.getYForLine(this.bottom_stave.getNumLines() - 1) + this.thickness;\n    let width = this.width;\n    let topX = this.top_stave.getX();\n    const isRightSidedConnector = this.type === StaveConnector.type.SINGLE_RIGHT || this.type === StaveConnector.type.BOLD_DOUBLE_RIGHT || this.type === StaveConnector.type.THIN_DOUBLE;\n\n    if (isRightSidedConnector) {\n      topX = this.top_stave.getX() + this.top_stave.width;\n    }\n\n    let attachment_height = botY - topY;\n\n    switch (this.type) {\n      case StaveConnector.type.SINGLE:\n        width = 1;\n        break;\n\n      case StaveConnector.type.SINGLE_LEFT:\n        width = 1;\n        break;\n\n      case StaveConnector.type.SINGLE_RIGHT:\n        width = 1;\n        break;\n\n      case StaveConnector.type.DOUBLE:\n        topX -= this.width + 2;\n        topY -= this.thickness;\n        attachment_height += 0.5;\n        break;\n\n      case StaveConnector.type.BRACE:\n        {\n          width = 12; // May need additional code to draw brace\n\n          const x1 = this.top_stave.getX() - 2 + this.x_shift;\n          const y1 = topY;\n          const x3 = x1;\n          const y3 = botY;\n          const x2 = x1 - width;\n          const y2 = y1 + attachment_height / 2.0;\n          const cpx1 = x2 - 0.90 * width;\n          const cpy1 = y1 + 0.2 * attachment_height;\n          const cpx2 = x1 + 1.10 * width;\n          const cpy2 = y2 - 0.135 * attachment_height;\n          const cpx3 = cpx2;\n          const cpy3 = y2 + 0.135 * attachment_height;\n          const cpx4 = cpx1;\n          const cpy4 = y3 - 0.2 * attachment_height;\n          const cpx5 = x2 - width;\n          const cpy5 = cpy4;\n          const cpx6 = x1 + 0.40 * width;\n          const cpy6 = y2 + 0.135 * attachment_height;\n          const cpx7 = cpx6;\n          const cpy7 = y2 - 0.135 * attachment_height;\n          const cpx8 = cpx5;\n          const cpy8 = cpy1;\n          ctx.beginPath();\n          ctx.moveTo(x1, y1);\n          ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);\n          ctx.bezierCurveTo(cpx3, cpy3, cpx4, cpy4, x3, y3);\n          ctx.bezierCurveTo(cpx5, cpy5, cpx6, cpy6, x2, y2);\n          ctx.bezierCurveTo(cpx7, cpy7, cpx8, cpy8, x1, y1);\n          ctx.fill();\n          ctx.stroke();\n          break;\n        }\n\n      case StaveConnector.type.BRACKET:\n        topY -= 6;\n        botY += 6;\n        attachment_height = botY - topY;\n        Glyph.renderGlyph(ctx, topX - 5, topY, 40, 'bracketTop');\n        Glyph.renderGlyph(ctx, topX - 5, botY, 40, 'bracketBottom');\n        topX -= this.width + 2;\n        break;\n\n      case StaveConnector.type.BOLD_DOUBLE_LEFT:\n        drawBoldDoubleLine(ctx, this.type, topX + this.x_shift, topY, botY - this.thickness);\n        break;\n\n      case StaveConnector.type.BOLD_DOUBLE_RIGHT:\n        drawBoldDoubleLine(ctx, this.type, topX, topY, botY - this.thickness);\n        break;\n\n      case StaveConnector.type.THIN_DOUBLE:\n        width = 1;\n        attachment_height -= this.thickness;\n        break;\n\n      case StaveConnector.type.NONE:\n        break;\n\n      default:\n        throw new Vex.RERR('InvalidType', `The provided StaveConnector.type (${this.type}) is invalid`);\n    }\n\n    if (this.type !== StaveConnector.type.BRACE && this.type !== StaveConnector.type.BOLD_DOUBLE_LEFT && this.type !== StaveConnector.type.BOLD_DOUBLE_RIGHT && this.type !== StaveConnector.type.NONE) {\n      ctx.fillRect(topX, topY, width, attachment_height);\n    } // If the connector is a thin double barline, draw the paralell line\n\n\n    if (this.type === StaveConnector.type.THIN_DOUBLE) {\n      ctx.fillRect(topX - 3, topY, width, attachment_height);\n    }\n\n    ctx.save();\n    ctx.lineWidth = 2;\n    ctx.setFont(this.font.family, this.font.size, this.font.weight); // Add stave connector text\n\n    for (let i = 0; i < this.texts.length; i++) {\n      const text = this.texts[i];\n      const text_width = ctx.measureText('' + text.content).width;\n      const x = this.top_stave.getX() - text_width - 24 + text.options.shift_x;\n      const y = (this.top_stave.getYForLine(0) + this.bottom_stave.getBottomLineY()) / 2 + text.options.shift_y;\n      ctx.fillText('' + text.content, x, y + 4);\n    }\n\n    ctx.restore();\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/staveconnector.js"],"names":["Vex","Element","Flow","Glyph","drawBoldDoubleLine","ctx","type","topX","topY","botY","StaveConnector","BOLD_DOUBLE_LEFT","BOLD_DOUBLE_RIGHT","RERR","x_shift","variableWidth","thickLineOffset","fillRect","SINGLE_RIGHT","SINGLE_LEFT","SINGLE","DOUBLE","BRACE","BRACKET","THIN_DOUBLE","NONE","typeString","singleRight","singleLeft","single","double","brace","bracket","boldDoubleLeft","boldDoubleRight","thinDouble","none","constructor","top_stave","bottom_stave","setAttribute","thickness","STAVE_LINE_THICKNESS","width","font","family","size","weight","texts","setType","setText","text","options","push","content","Merge","shift_x","shift_y","setFont","setXShift","draw","checkContext","setRendered","getYForLine","getNumLines","getX","isRightSidedConnector","attachment_height","x1","y1","x3","y3","x2","y2","cpx1","cpy1","cpx2","cpy2","cpx3","cpy3","cpx4","cpy4","cpx5","cpy5","cpx6","cpy6","cpx7","cpy7","cpx8","cpy8","beginPath","moveTo","bezierCurveTo","fill","stroke","renderGlyph","save","lineWidth","i","length","text_width","measureText","x","y","getBottomLineY","fillText","restore"],"mappings":"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","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n\nimport { Vex } from './vex';\nimport { Element } from './element';\nimport { Flow } from './tables';\nimport { Glyph } from './glyph';\n\nfunction drawBoldDoubleLine(ctx, type, topX, topY, botY) {\n  if (\n    type !== StaveConnector.type.BOLD_DOUBLE_LEFT &&\n    type !== StaveConnector.type.BOLD_DOUBLE_RIGHT\n  ) {\n    throw new Vex.RERR(\n      'InvalidConnector', 'A REPEAT_BEGIN or REPEAT_END type must be provided.'\n    );\n  }\n\n  let x_shift = 3;\n  let variableWidth = 3.5; // Width for avoiding anti-aliasing width issues\n  const thickLineOffset = 2; // For aesthetics\n\n  if (type === StaveConnector.type.BOLD_DOUBLE_RIGHT) {\n    x_shift = -5; // Flips the side of the thin line\n    variableWidth = 3;\n  }\n\n  // Thin line\n  ctx.fillRect(topX + x_shift, topY, 1, botY - topY);\n  // Thick line\n  ctx.fillRect(topX - thickLineOffset, topY, variableWidth, botY - topY);\n}\n\nexport class StaveConnector extends Element {\n  // SINGLE_LEFT and SINGLE are the same value for compatibility\n  // with older versions of vexflow which didn't have right sided\n  // stave connectors\n  static get type() {\n    return {\n      SINGLE_RIGHT: 0,\n      SINGLE_LEFT: 1,\n      SINGLE: 1,\n      DOUBLE: 2,\n      BRACE: 3,\n      BRACKET: 4,\n      BOLD_DOUBLE_LEFT: 5,\n      BOLD_DOUBLE_RIGHT: 6,\n      THIN_DOUBLE: 7,\n      NONE: 8,\n    };\n  }\n\n  static get typeString() {\n    return {\n      singleRight: StaveConnector.type.SINGLE_RIGHT,\n      singleLeft: StaveConnector.type.SINGLE_LEFT,\n      single: StaveConnector.type.SINGLE,\n      double: StaveConnector.type.DOUBLE,\n      brace: StaveConnector.type.BRACE,\n      bracket: StaveConnector.type.BRACKET,\n      boldDoubleLeft: StaveConnector.type.BOLD_DOUBLE_LEFT,\n      boldDoubleRight: StaveConnector.type.BOLD_DOUBLE_RIGHT,\n      thinDouble: StaveConnector.type.THIN_DOUBLE,\n      none: StaveConnector.type.NONE,\n    };\n  }\n\n  constructor(top_stave, bottom_stave) {\n    super();\n    this.setAttribute('type', 'StaveConnector');\n\n    this.thickness = Flow.STAVE_LINE_THICKNESS;\n    this.width = 3;\n    this.top_stave = top_stave;\n    this.bottom_stave = bottom_stave;\n    this.type = StaveConnector.type.DOUBLE;\n    this.font = {\n      family: 'times',\n      size: 16,\n      weight: 'normal',\n    };\n    // 1. Offset Bold Double Left to align with offset Repeat Begin bars\n    // 2. Offset BRACE type not to overlap with another StaveConnector\n    this.x_shift = 0;\n    this.texts = [];\n  }\n\n  setType(type) {\n    type = typeof(type) === 'string'\n      ? StaveConnector.typeString[type]\n      : type;\n\n    if (type >= StaveConnector.type.SINGLE_RIGHT && type <= StaveConnector.type.NONE) {\n      this.type = type;\n    }\n    return this;\n  }\n\n  setText(text, options) {\n    this.texts.push({\n      content: text,\n      options: Vex.Merge({ shift_x: 0, shift_y: 0 }, options),\n    });\n    return this;\n  }\n\n  setFont(font) {\n    Vex.Merge(this.font, font);\n  }\n\n  setXShift(x_shift) {\n    if (typeof x_shift !== 'number') {\n      throw Vex.RERR('InvalidType', 'x_shift must be a Number');\n    }\n\n    this.x_shift = x_shift;\n    return this;\n  }\n\n  draw() {\n    const ctx = this.checkContext();\n    this.setRendered();\n\n    let topY = this.top_stave.getYForLine(0);\n    let botY = this.bottom_stave.getYForLine(this.bottom_stave.getNumLines() - 1) +\n      this.thickness;\n    let width = this.width;\n    let topX = this.top_stave.getX();\n\n    const isRightSidedConnector = (\n      this.type === StaveConnector.type.SINGLE_RIGHT ||\n      this.type === StaveConnector.type.BOLD_DOUBLE_RIGHT ||\n      this.type === StaveConnector.type.THIN_DOUBLE\n    );\n\n    if (isRightSidedConnector) {\n      topX = this.top_stave.getX() + this.top_stave.width;\n    }\n\n    let attachment_height = botY - topY;\n    switch (this.type) {\n      case StaveConnector.type.SINGLE:\n        width = 1;\n        break;\n      case StaveConnector.type.SINGLE_LEFT:\n        width = 1;\n        break;\n      case StaveConnector.type.SINGLE_RIGHT:\n        width = 1;\n        break;\n      case StaveConnector.type.DOUBLE:\n        topX -= (this.width + 2);\n        topY -= this.thickness;\n        attachment_height += 0.5;\n        break;\n      case StaveConnector.type.BRACE: {\n        width = 12;\n        // May need additional code to draw brace\n        const x1 = this.top_stave.getX() - 2 + this.x_shift;\n        const y1 = topY;\n        const x3 = x1;\n        const y3 = botY;\n        const x2 = x1 - width;\n        const y2 = y1 + attachment_height / 2.0;\n        const cpx1 = x2 - (0.90 * width);\n        const cpy1 = y1 + (0.2 * attachment_height);\n        const cpx2 = x1 + (1.10 * width);\n        const cpy2 = y2 - (0.135 * attachment_height);\n        const cpx3 = cpx2;\n        const cpy3 = y2 + (0.135 * attachment_height);\n        const cpx4 = cpx1;\n        const cpy4 = y3 - (0.2 * attachment_height);\n        const cpx5 = x2 - width;\n        const cpy5 = cpy4;\n        const cpx6 = x1 + (0.40 * width);\n        const cpy6 = y2 + (0.135 * attachment_height);\n        const cpx7 = cpx6;\n        const cpy7 = y2 - (0.135 * attachment_height);\n        const cpx8 = cpx5;\n        const cpy8 = cpy1;\n        ctx.beginPath();\n        ctx.moveTo(x1, y1);\n        ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);\n        ctx.bezierCurveTo(cpx3, cpy3, cpx4, cpy4, x3, y3);\n        ctx.bezierCurveTo(cpx5, cpy5, cpx6, cpy6, x2, y2);\n        ctx.bezierCurveTo(cpx7, cpy7, cpx8, cpy8, x1, y1);\n        ctx.fill();\n        ctx.stroke();\n        break;\n      } case StaveConnector.type.BRACKET:\n        topY -= 6;\n        botY += 6;\n        attachment_height = botY - topY;\n        Glyph.renderGlyph(ctx, topX - 5, topY, 40, 'bracketTop');\n        Glyph.renderGlyph(ctx, topX - 5, botY, 40, 'bracketBottom');\n        topX -= (this.width + 2);\n        break;\n      case StaveConnector.type.BOLD_DOUBLE_LEFT:\n        drawBoldDoubleLine(ctx, this.type, topX + this.x_shift, topY, botY - this.thickness);\n        break;\n      case StaveConnector.type.BOLD_DOUBLE_RIGHT:\n        drawBoldDoubleLine(ctx, this.type, topX, topY, botY - this.thickness);\n        break;\n      case StaveConnector.type.THIN_DOUBLE:\n        width = 1;\n        attachment_height -= this.thickness;\n        break;\n      case StaveConnector.type.NONE:\n        break;\n      default:\n        throw new Vex.RERR(\n          'InvalidType', `The provided StaveConnector.type (${this.type}) is invalid`\n        );\n    }\n\n    if (\n      this.type !== StaveConnector.type.BRACE &&\n      this.type !== StaveConnector.type.BOLD_DOUBLE_LEFT &&\n      this.type !== StaveConnector.type.BOLD_DOUBLE_RIGHT &&\n      this.type !== StaveConnector.type.NONE\n    ) {\n      ctx.fillRect(topX, topY, width, attachment_height);\n    }\n\n    // If the connector is a thin double barline, draw the paralell line\n    if (this.type === StaveConnector.type.THIN_DOUBLE) {\n      ctx.fillRect(topX - 3, topY, width, attachment_height);\n    }\n\n    ctx.save();\n    ctx.lineWidth = 2;\n    ctx.setFont(this.font.family, this.font.size, this.font.weight);\n    // Add stave connector text\n    for (let i = 0; i < this.texts.length; i++) {\n      const text = this.texts[i];\n      const text_width = ctx.measureText('' + text.content).width;\n      const x = this.top_stave.getX() - text_width - 24 + text.options.shift_x;\n      const y = (this.top_stave.getYForLine(0) + this.bottom_stave.getBottomLineY()) / 2 +\n        text.options.shift_y;\n\n      ctx.fillText('' + text.content, x, y + 4);\n    }\n    ctx.restore();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}