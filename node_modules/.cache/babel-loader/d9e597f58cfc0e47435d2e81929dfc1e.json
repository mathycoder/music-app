{"ast":null,"code":"// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n//\n// This file implements the formatting and layout algorithms that are used\n// to position notes in a voice. The algorithm can align multiple voices both\n// within a stave, and across multiple staves.\n//\n// To do this, the formatter breaks up voices into a grid of rational-valued\n// `ticks`, to which each note is assigned. Then, minimum widths are assigned\n// to each tick based on the widths of the notes and modifiers in that tick. This\n// establishes the smallest amount of space required for each tick.\n//\n// Finally, the formatter distributes the left over space proportionally to\n// all the ticks, setting the `x` values of the notes in each tick.\n//\n// See `tests/formatter_tests.js` for usage examples. The helper functions included\n// here (`FormatAndDraw`, `FormatAndDrawTab`) also serve as useful usage examples.\nimport { Vex } from './vex';\nimport { Beam } from './beam';\nimport { Flow } from './tables';\nimport { Fraction } from './fraction';\nimport { Voice } from './voice';\nimport { StaveConnector } from './staveconnector';\nimport { StaveNote } from './stavenote';\nimport { ModifierContext } from './modifiercontext';\nimport { TickContext } from './tickcontext'; // To enable logging for this class. Set `Vex.Flow.Formatter.DEBUG` to `true`.\n\nfunction L(...args) {\n  if (Formatter.DEBUG) Vex.L('Vex.Flow.Formatter', args);\n} // Helper function to locate the next non-rest note(s).\n\n\nfunction lookAhead(notes, restLine, i, compare) {\n  // If no valid next note group, nextRestLine is same as current.\n  let nextRestLine = restLine; // Get the rest line for next valid non-rest note group.\n\n  for (i += 1; i < notes.length; i += 1) {\n    const note = notes[i];\n\n    if (!note.isRest() && !note.shouldIgnoreTicks()) {\n      nextRestLine = note.getLineForRest();\n      break;\n    }\n  } // Locate the mid point between two lines.\n\n\n  if (compare && restLine !== nextRestLine) {\n    const top = Math.max(restLine, nextRestLine);\n    const bot = Math.min(restLine, nextRestLine);\n    nextRestLine = Vex.MidLine(top, bot);\n  }\n\n  return nextRestLine;\n} // Take an array of `voices` and place aligned tickables in the same context. Returns\n// a mapping from `tick` to `ContextType`, a list of `tick`s, and the resolution\n// multiplier.\n//\n// Params:\n// * `voices`: Array of `Voice` instances.\n// * `ContextType`: A context class (e.g., `ModifierContext`, `TickContext`)\n// * `addToContext`: Function to add tickable to context.\n\n\nfunction createContexts(voices, ContextType, addToContext) {\n  if (!voices || !voices.length) {\n    throw new Vex.RERR('BadArgument', 'No voices to format');\n  } // Find out highest common multiple of resolution multipliers.\n  // The purpose of this is to find out a common denominator\n  // for all fractional tick values in all tickables of all voices,\n  // so that the values can be expanded and the numerator used\n  // as an integer tick value.\n\n\n  const totalTicks = voices[0].getTotalTicks();\n  const resolutionMultiplier = voices.reduce((resolutionMultiplier, voice) => {\n    if (!voice.getTotalTicks().equals(totalTicks)) {\n      throw new Vex.RERR('TickMismatch', 'Voices should have same total note duration in ticks.');\n    }\n\n    if (voice.getMode() === Voice.Mode.STRICT && !voice.isComplete()) {\n      throw new Vex.RERR('IncompleteVoice', 'Voice does not have enough notes.');\n    }\n\n    return Math.max(resolutionMultiplier, Fraction.LCM(resolutionMultiplier, voice.getResolutionMultiplier()));\n  }, 1); // Initialize tick maps.\n\n  const tickToContextMap = {};\n  const tickList = [];\n  const contexts = []; // For each voice, extract notes and create a context for every\n  // new tick that hasn't been seen before.\n\n  voices.forEach((voice, voiceIndex) => {\n    // Use resolution multiplier as denominator to expand ticks\n    // to suitable integer values, so that no additional expansion\n    // of fractional tick values is needed.\n    const ticksUsed = new Fraction(0, resolutionMultiplier);\n    voice.getTickables().forEach(tickable => {\n      const integerTicks = ticksUsed.numerator; // If we have no tick context for this tick, create one.\n\n      if (!tickToContextMap[integerTicks]) {\n        const newContext = new ContextType({\n          tickID: integerTicks\n        });\n        contexts.push(newContext);\n        tickToContextMap[integerTicks] = newContext;\n      } // Add this tickable to the TickContext.\n\n\n      addToContext(tickable, tickToContextMap[integerTicks], voiceIndex); // Maintain a sorted list of tick contexts.\n\n      tickList.push(integerTicks);\n      ticksUsed.add(tickable.getTicks());\n    });\n  });\n  return {\n    map: tickToContextMap,\n    array: contexts,\n    list: Vex.SortAndUnique(tickList, (a, b) => a - b, (a, b) => a === b),\n    resolutionMultiplier\n  };\n}\n\nexport class Formatter {\n  // Helper function to layout \"notes\" one after the other without\n  // regard for proportions. Useful for tests and debugging.\n  static SimpleFormat(notes, x = 0, {\n    paddingBetween = 10\n  } = {}) {\n    notes.reduce((x, note) => {\n      note.addToModifierContext(new ModifierContext());\n      const tick = new TickContext().addTickable(note).preFormat();\n      const metrics = tick.getMetrics();\n      tick.setX(x + metrics.totalLeftPx);\n      return x + tick.getWidth() + metrics.totalRightPx + paddingBetween;\n    }, x);\n  } // Helper function to plot formatter debug info.\n\n\n  static plotDebugging(ctx, formatter, xPos, y1, y2, options) {\n    options = {\n      stavePadding: Vex.Flow.DEFAULT_FONT_STACK[0].lookupMetric('stave.padding'),\n      ...options\n    };\n    const x = xPos + options.stavePadding;\n    const contextGaps = formatter.contextGaps;\n\n    function stroke(x1, x2, color) {\n      ctx.beginPath();\n      ctx.setStrokeStyle(color);\n      ctx.setFillStyle(color);\n      ctx.setLineWidth(1);\n      ctx.fillRect(x1, y1, Math.max(x2 - x1, 0), y2 - y1);\n    }\n\n    ctx.save();\n    ctx.setFont('Arial', 8, '');\n    contextGaps.gaps.forEach(gap => {\n      stroke(x + gap.x1, x + gap.x2, 'rgba(100,200,100,0.4)');\n      ctx.setFillStyle('green');\n      ctx.fillText(Math.round(gap.x2 - gap.x1), x + gap.x1, y2 + 12);\n    });\n    ctx.setFillStyle('red');\n    ctx.fillText(`Loss: ${(formatter.totalCost || 0).toFixed(2)} Shift: ${(formatter.totalShift || 0).toFixed(2)} Gap: ${contextGaps.total.toFixed(2)}`, x - 20, y2 + 27);\n    ctx.restore();\n  } // Helper function to format and draw a single voice. Returns a bounding\n  // box for the notation.\n  //\n  // Parameters:\n  // * `ctx` - The rendering context\n  // * `stave` - The stave to which to draw (`Stave` or `TabStave`)\n  // * `notes` - Array of `Note` instances (`StaveNote`, `TextNote`, `TabNote`, etc.)\n  // * `params` - One of below:\n  //    * Setting `autobeam` only `(context, stave, notes, true)` or\n  //      `(ctx, stave, notes, {autobeam: true})`\n  //    * Setting `align_rests` a struct is needed `(context, stave, notes, {align_rests: true})`\n  //    * Setting both a struct is needed `(context, stave, notes, {\n  //      autobeam: true, align_rests: true})`\n  //\n  // `autobeam` automatically generates beams for the notes.\n  // `align_rests` aligns rests with nearby notes.\n\n\n  static FormatAndDraw(ctx, stave, notes, params) {\n    const options = {\n      auto_beam: false,\n      align_rests: false\n    };\n\n    if (typeof params === 'object') {\n      Vex.Merge(options, params);\n    } else if (typeof params === 'boolean') {\n      options.auto_beam = params;\n    } // Start by creating a voice and adding all the notes to it.\n\n\n    const voice = new Voice(Flow.TIME4_4).setMode(Voice.Mode.SOFT).addTickables(notes); // Then create beams, if requested.\n\n    const beams = options.auto_beam ? Beam.applyAndGetBeams(voice) : []; // Instantiate a `Formatter` and format the notes.\n\n    new Formatter().joinVoices([voice], {\n      align_rests: options.align_rests\n    }).formatToStave([voice], stave, {\n      align_rests: options.align_rests,\n      stave\n    }); // Render the voice and beams to the stave.\n\n    voice.setStave(stave).draw(ctx, stave);\n    beams.forEach(beam => beam.setContext(ctx).draw()); // Return the bounding box of the voice.\n\n    return voice.getBoundingBox();\n  } // Helper function to format and draw aligned tab and stave notes in two\n  // separate staves.\n  //\n  // Parameters:\n  // * `ctx` - The rendering context\n  // * `tabstave` - A `TabStave` instance on which to render `TabNote`s.\n  // * `stave` - A `Stave` instance on which to render `Note`s.\n  // * `notes` - Array of `Note` instances for the stave (`StaveNote`, `BarNote`, etc.)\n  // * `tabnotes` - Array of `Note` instances for the tab stave (`TabNote`, `BarNote`, etc.)\n  // * `autobeam` - Automatically generate beams.\n  // * `params` - A configuration object:\n  //    * `autobeam` automatically generates beams for the notes.\n  //    * `align_rests` aligns rests with nearby notes.\n\n\n  static FormatAndDrawTab(ctx, tabstave, stave, tabnotes, notes, autobeam, params) {\n    const opts = {\n      auto_beam: autobeam,\n      align_rests: false\n    };\n\n    if (typeof params === 'object') {\n      Vex.Merge(opts, params);\n    } else if (typeof params === 'boolean') {\n      opts.auto_beam = params;\n    } // Create a `4/4` voice for `notes`.\n\n\n    const notevoice = new Voice(Flow.TIME4_4).setMode(Voice.Mode.SOFT).addTickables(notes); // Create a `4/4` voice for `tabnotes`.\n\n    const tabvoice = new Voice(Flow.TIME4_4).setMode(Voice.Mode.SOFT).addTickables(tabnotes); // Then create beams, if requested.\n\n    const beams = opts.auto_beam ? Beam.applyAndGetBeams(notevoice) : []; // Instantiate a `Formatter` and align tab and stave notes.\n\n    new Formatter().joinVoices([notevoice], {\n      align_rests: opts.align_rests\n    }).joinVoices([tabvoice]).formatToStave([notevoice, tabvoice], stave, {\n      align_rests: opts.align_rests\n    }); // Render voices and beams to staves.\n\n    notevoice.draw(ctx, stave);\n    tabvoice.draw(ctx, tabstave);\n    beams.forEach(beam => beam.setContext(ctx).draw()); // Draw a connector between tab and note staves.\n\n    new StaveConnector(stave, tabstave).setContext(ctx).draw();\n  } // Auto position rests based on previous/next note positions.\n  //\n  // Params:\n  // * `notes`: An array of notes.\n  // * `alignAllNotes`: If set to false, only aligns non-beamed notes.\n  // * `alignTuplets`: If set to false, ignores tuplets.\n\n\n  static AlignRestsToNotes(notes, alignAllNotes, alignTuplets) {\n    notes.forEach((note, index) => {\n      if (note instanceof StaveNote && note.isRest()) {\n        if (note.tuplet && !alignTuplets) return; // If activated rests not on default can be rendered as specified.\n\n        const position = note.getGlyph().position.toUpperCase();\n        if (position !== 'R/4' && position !== 'B/4') return;\n\n        if (alignAllNotes || note.beam != null) {\n          // Align rests with previous/next notes.\n          const props = note.getKeyProps()[0];\n\n          if (index === 0) {\n            props.line = lookAhead(notes, props.line, index, false);\n            note.setKeyLine(0, props.line);\n          } else if (index > 0 && index < notes.length) {\n            // If previous note is a rest, use its line number.\n            let restLine;\n\n            if (notes[index - 1].isRest()) {\n              restLine = notes[index - 1].getKeyProps()[0].line;\n              props.line = restLine;\n            } else {\n              restLine = notes[index - 1].getLineForRest(); // Get the rest line for next valid non-rest note group.\n\n              props.line = lookAhead(notes, restLine, index, true);\n            }\n\n            note.setKeyLine(0, props.line);\n          }\n        }\n      }\n    });\n    return this;\n  }\n\n  constructor(options) {\n    this.options = {\n      softmaxFactor: null,\n      maxIterations: 2,\n      ...options\n    }; // Minimum width required to render all the notes in the voices.\n\n    this.minTotalWidth = 0; // This is set to `true` after `minTotalWidth` is calculated.\n\n    this.hasMinTotalWidth = false; // Total number of ticks in the voice.\n\n    this.totalTicks = new Fraction(0, 1); // Arrays of tick and modifier contexts.\n\n    this.tickContexts = null;\n    this.modiferContexts = null; // Gaps between contexts, for free movement of notes post\n    // formatting.\n\n    this.contextGaps = {\n      total: 0,\n      gaps: []\n    };\n    this.voices = [];\n    this.iterationsCompleted = 0;\n    this.lossHistory = [];\n  } // Find all the rests in each of the `voices` and align them\n  // to neighboring notes. If `alignAllNotes` is `false`, then only\n  // align non-beamed notes.\n\n\n  alignRests(voices, alignAllNotes) {\n    if (!voices || !voices.length) {\n      throw new Vex.RERR('BadArgument', 'No voices to format rests');\n    }\n\n    voices.forEach(voice => Formatter.AlignRestsToNotes(voice.getTickables(), alignAllNotes));\n  } // Calculate the minimum width required to align and format `voices`.\n\n\n  preCalculateMinTotalWidth(voices) {\n    // Cache results.\n    if (this.hasMinTotalWidth) return this.minTotalWidth; // Create tick contexts if not already created.\n\n    if (!this.tickContexts) {\n      if (!voices) {\n        throw new Vex.RERR('BadArgument', \"'voices' required to run preCalculateMinTotalWidth\");\n      }\n\n      this.createTickContexts(voices);\n    }\n\n    const {\n      list: contextList,\n      map: contextMap\n    } = this.tickContexts; // Go through each tick context and calculate total width.\n\n    this.minTotalWidth = contextList.map(tick => {\n      const context = contextMap[tick];\n      context.preFormat();\n      return context.getWidth();\n    }).reduce((a, b) => a + b, 0);\n    this.hasMinTotalWidth = true;\n    return this.minTotalWidth;\n  } // Get minimum width required to render all voices. Either `format` or\n  // `preCalculateMinTotalWidth` must be called before this method.\n\n\n  getMinTotalWidth() {\n    if (!this.hasMinTotalWidth) {\n      throw new Vex.RERR('NoMinTotalWidth', \"Call 'preCalculateMinTotalWidth' or 'preFormat' before calling 'getMinTotalWidth'\");\n    }\n\n    return this.minTotalWidth;\n  } // Create `ModifierContext`s for each tick in `voices`.\n\n\n  createModifierContexts(voices) {\n    const contexts = createContexts(voices, ModifierContext, (tickable, context) => tickable.addToModifierContext(context));\n    this.modiferContexts = contexts;\n    return contexts;\n  } // Create `TickContext`s for each tick in `voices`. Also calculate the\n  // total number of ticks in voices.\n\n\n  createTickContexts(voices) {\n    const contexts = createContexts(voices, TickContext, (tickable, context, voiceIndex) => context.addTickable(tickable, voiceIndex));\n    contexts.array.forEach(context => {\n      context.tContexts = contexts.array;\n    });\n    this.totalTicks = voices[0].getTicksUsed().clone();\n    this.tickContexts = contexts;\n    return contexts;\n  } // This is the core formatter logic. Format voices and justify them\n  // to `justifyWidth` pixels. `renderingContext` is required to justify elements\n  // that can't retreive widths without a canvas. This method sets the `x` positions\n  // of all the tickables/notes in the formatter.\n\n\n  preFormat(justifyWidth = 0, renderingContext, voices, stave) {\n    // Initialize context maps.\n    const contexts = this.tickContexts;\n    const {\n      list: contextList,\n      map: contextMap\n    } = contexts; // Reset loss history for evaluator.\n\n    this.lossHistory = []; // If voices and a stave were provided, set the Stave for each voice\n    // and preFormat to apply Y values to the notes;\n\n    if (voices && stave) {\n      voices.forEach(voice => voice.setStave(stave).preFormat());\n    } // Now distribute the ticks to each tick context, and assign them their\n    // own X positions.\n\n\n    let x = 0;\n    let shift = 0;\n    this.minTotalWidth = 0; // Pass 1: Give each note maximum width requested by context.\n\n    contextList.forEach(tick => {\n      const context = contextMap[tick];\n      if (renderingContext) context.setContext(renderingContext); // Make sure that all tickables in this context have calculated their\n      // space requirements.\n\n      context.preFormat();\n      const width = context.getWidth();\n      this.minTotalWidth += width;\n      const metrics = context.getMetrics();\n      x = x + shift + metrics.totalLeftPx;\n      context.setX(x); // Calculate shift for the next tick.\n\n      shift = width - metrics.totalLeftPx;\n    });\n    this.minTotalWidth = x + shift;\n    this.hasMinTotalWidth = true; // No justification needed. End formatting.\n\n    if (justifyWidth <= 0) return this.evaluate(); // Start justification. Subtract the right extra pixels of the final context because the formatter\n    // justifies based on the context's X position, which is the left-most part of the note head.\n\n    const firstContext = contextMap[contextList[0]];\n    const lastContext = contextMap[contextList[contextList.length - 1]]; // Calculate the \"distance error\" between the tick contexts. The expected distance is the spacing proportional to\n    // the softmax of the ticks.\n\n    function calculateIdealDistances(adjustedJustifyWidth) {\n      return contextList.map((tick, i) => {\n        const context = contextMap[tick];\n        const voices = context.getTickablesByVoice();\n        let backTickable = null;\n\n        if (i > 0) {\n          const prevContext = contextMap[contextList[i - 1]]; // Go through each tickable and search backwards for another tickable\n          // in the same voice. If found, use that duration (ticks) to calculate\n          // the expected distance.\n\n          for (let j = i - 1; j >= 0; j--) {\n            const backTick = contextMap[contextList[j]];\n            const backVoices = backTick.getTickablesByVoice(); // Look for matching voices between tick contexts.\n\n            const matchingVoices = [];\n            Object.keys(voices).forEach(v => {\n              if (backVoices[v]) {\n                matchingVoices.push(v);\n              }\n            });\n\n            if (matchingVoices.length > 0) {\n              // Found matching voices, get largest duration\n              let maxTicks = 0;\n              let maxNegativeShiftPx = Infinity;\n              let expectedDistance = 0; // eslint-disable-next-line\n\n              matchingVoices.forEach(v => {\n                const ticks = backVoices[v].getTicks().value();\n\n                if (ticks > maxTicks) {\n                  backTickable = backVoices[v];\n                  maxTicks = ticks;\n                } // Calculate the limits of the shift based on modifiers, etc.\n\n\n                const thisTickable = voices[v];\n                const insideLeftEdge = thisTickable.getX() - (thisTickable.getMetrics().modLeftPx + thisTickable.getMetrics().leftDisplacedHeadPx);\n                const backMetrics = backVoices[v].getMetrics();\n                const insideRightEdge = backVoices[v].getX() + backMetrics.notePx + backMetrics.modRightPx + backMetrics.rightDisplacedHeadPx; // Don't allow shifting if notes in the same voice can collide\n\n                maxNegativeShiftPx = Math.min(maxNegativeShiftPx, insideLeftEdge - insideRightEdge);\n              }); // Don't shift further left than the notehead of the last context\n\n              maxNegativeShiftPx = Math.min(maxNegativeShiftPx, context.getX() - prevContext.getX()); // Calculate the expected distance of the current context from the last matching tickable. The\n              // distance is scaled down by the softmax for the voice.\n\n              expectedDistance = backTickable.getVoice().softmax(maxTicks) * adjustedJustifyWidth;\n              return {\n                expectedDistance,\n                maxNegativeShiftPx,\n                fromTickable: backTickable\n              };\n            }\n          }\n        }\n\n        return {\n          errorPx: 0,\n          fromTickablePx: 0,\n          maxNegativeShiftPx: 0\n        };\n      });\n    }\n\n    function shiftToIdealDistances(idealDistances) {\n      // Distribute ticks to the contexts based on the calculated distance error.\n      const centerX = adjustedJustifyWidth / 2;\n      let spaceAccum = 0;\n      let negativeSpaceAccum = 0;\n      contextList.forEach((tick, index) => {\n        const context = contextMap[tick];\n\n        if (index > 0) {\n          const x = context.getX();\n          const ideal = idealDistances[index];\n          const errorPx = ideal.fromTickable.getX() + ideal.expectedDistance - (x + spaceAccum);\n          let negativeShiftPx = 0;\n\n          if (errorPx > 0) {\n            spaceAccum += errorPx;\n          } else if (errorPx < 0) {\n            negativeShiftPx = Math.min(ideal.maxNegativeShiftPx + negativeSpaceAccum, Math.abs(errorPx));\n          }\n\n          context.setX(x + spaceAccum - negativeShiftPx);\n          negativeSpaceAccum += negativeShiftPx;\n        } // Move center aligned tickables to middle\n\n\n        context.getCenterAlignedTickables().forEach(tickable => {\n          // eslint-disable-line\n          tickable.center_x_shift = centerX - context.getX();\n        });\n      });\n      return lastContext.getX() - firstContext.getX();\n    }\n\n    const adjustedJustifyWidth = justifyWidth - lastContext.getMetrics().notePx - lastContext.getMetrics().totalRightPx - firstContext.getMetrics().totalLeftPx;\n    let targetWidth = adjustedJustifyWidth;\n    let actualWidth = shiftToIdealDistances(calculateIdealDistances(targetWidth));\n    let iterations = this.options.maxIterations;\n\n    while (actualWidth > adjustedJustifyWidth + lastContext.getMetrics().notePx && iterations > 0) {\n      // If we couldn't fit all the notes into the jusification width, it's because the softmax-scaled\n      // widths between different durations differ across stave (e.g., 1 quarter note is not the same pixel-width\n      // as 4 16th-notes). Run another pass, now that we know how much to justify.\n      targetWidth -= actualWidth - targetWidth;\n      actualWidth = shiftToIdealDistances(calculateIdealDistances(targetWidth));\n      iterations--;\n    } // Just one context. Done formatting.\n\n\n    if (contextList.length === 1) return null;\n    this.justifyWidth = justifyWidth;\n    return this.evaluate();\n  } // Calculate the total cost of this formatting decision.\n\n\n  evaluate() {\n    const justifyWidth = this.justifyWidth; // Calculate available slack per tick context. This works out how much freedom\n    // to move a context has in either direction, without affecting other notes.\n\n    this.contextGaps = {\n      total: 0,\n      gaps: []\n    };\n    this.tickContexts.list.forEach((tick, index) => {\n      if (index === 0) return;\n      const prevTick = this.tickContexts.list[index - 1];\n      const prevContext = this.tickContexts.map[prevTick];\n      const context = this.tickContexts.map[tick];\n      const prevMetrics = prevContext.getMetrics();\n      const currMetrics = context.getMetrics(); // Calculate X position of right edge of previous note\n\n      const insideRightEdge = prevContext.getX() + prevMetrics.notePx + prevMetrics.totalRightPx; // Calculate X position of left edge of current note\n\n      const insideLeftEdge = context.getX() - currMetrics.totalLeftPx;\n      const gap = insideLeftEdge - insideRightEdge;\n      this.contextGaps.total += gap;\n      this.contextGaps.gaps.push({\n        x1: insideRightEdge,\n        x2: insideLeftEdge\n      }); // Tell the tick contexts how much they can reposition themselves.\n\n      context.getFormatterMetrics().freedom.left = gap;\n      prevContext.getFormatterMetrics().freedom.right = gap;\n    }); // Calculate mean distance in each voice for each duration type, then calculate\n    // how far each note is from the mean.\n\n    const durationStats = this.durationStats = {};\n\n    function updateStats(duration, space) {\n      const stats = durationStats[duration];\n\n      if (stats === undefined) {\n        durationStats[duration] = {\n          mean: space,\n          count: 1\n        };\n      } else {\n        stats.count += 1;\n        stats.mean = (stats.mean + space) / 2;\n      }\n    }\n\n    this.voices.forEach(voice => {\n      voice.getTickables().forEach((note, i, notes) => {\n        const duration = note.getTicks().clone().simplify().toString();\n        const metrics = note.getMetrics();\n        const formatterMetrics = note.getFormatterMetrics();\n        const leftNoteEdge = note.getX() + metrics.notePx + metrics.totalRightPx;\n        let space = 0;\n\n        if (i < notes.length - 1) {\n          const rightNote = notes[i + 1];\n          const rightMetrics = rightNote.getMetrics();\n          const rightNoteEdge = rightNote.getX() - rightMetrics.totalLeftPx;\n          space = rightNoteEdge - leftNoteEdge;\n          formatterMetrics.space.used = rightNote.getX() - note.getX();\n          rightNote.getFormatterMetrics().freedom.left = space;\n        } else {\n          space = justifyWidth - leftNoteEdge;\n          formatterMetrics.space.used = justifyWidth - note.getX();\n        }\n\n        formatterMetrics.freedom.right = space;\n        updateStats(duration, formatterMetrics.space.used);\n      });\n    }); // Calculate how much each note deviates from the mean. Loss function is square\n    // root of the sum of squared deviations.\n\n    let totalDeviation = 0;\n    this.voices.forEach(voice => {\n      voice.getTickables().forEach(note => {\n        const duration = note.getTicks().clone().simplify().toString();\n        const metrics = note.getFormatterMetrics();\n        metrics.space.mean = durationStats[duration].mean;\n        metrics.duration = duration;\n        metrics.iterations += 1;\n        metrics.space.deviation = metrics.space.used - metrics.space.mean;\n        totalDeviation += Math.pow(metrics.space.deviation, 2);\n      });\n    });\n    this.totalCost = Math.sqrt(totalDeviation);\n    this.lossHistory.push(this.totalCost);\n    return this.totalCost;\n  } // Run a single iteration of rejustification. At a high level, this method calculates\n  // the overall \"loss\" (or cost) of this layout, and repositions tickcontexts in an\n  // attempt to reduce the cost. You can call this method multiple times until it finds\n  // and oscillates around a global minimum.\n  //\n  // Alpha is the \"learning rate\" for the formatter. It determines how much of a shift\n  // the formatter should make based on its cost function.\n\n\n  tune(options) {\n    options = {\n      alpha: 0.5,\n      ...options\n    };\n\n    const sum = arr => arr.reduce((a, b) => a + b); // Move `current` tickcontext by `shift` pixels, and adjust the freedom\n    // on adjacent tickcontexts.\n\n\n    function move(current, prev, next, shift) {\n      current.setX(current.getX() + shift);\n      current.getFormatterMetrics().freedom.left += shift;\n      current.getFormatterMetrics().freedom.right -= shift;\n      if (prev) prev.getFormatterMetrics().freedom.right += shift;\n      if (next) next.getFormatterMetrics().freedom.left -= shift;\n    }\n\n    let shift = 0;\n    this.totalShift = 0;\n    this.tickContexts.list.forEach((tick, index, list) => {\n      const context = this.tickContexts.map[tick];\n      const prevContext = index > 0 ? this.tickContexts.map[list[index - 1]] : null;\n      const nextContext = index < list.length - 1 ? this.tickContexts.map[list[index + 1]] : null;\n      move(context, prevContext, nextContext, shift);\n      const cost = -sum(context.getTickables().map(t => t.getFormatterMetrics().space.deviation));\n\n      if (cost > 0) {\n        shift = -Math.min(context.getFormatterMetrics().freedom.right, Math.abs(cost));\n      } else if (cost < 0) {\n        if (nextContext) {\n          shift = Math.min(nextContext.getFormatterMetrics().freedom.right, Math.abs(cost));\n        } else {\n          shift = 0;\n        }\n      }\n\n      shift *= options.alpha;\n      this.totalShift += shift;\n    });\n    this.iterationsCompleted++;\n    return this.evaluate();\n  } // This is the top-level call for all formatting logic completed\n  // after `x` *and* `y` values have been computed for the notes\n  // in the voices.\n\n\n  postFormat() {\n    const postFormatContexts = contexts => contexts.list.forEach(tick => contexts.map[tick].postFormat());\n\n    postFormatContexts(this.modiferContexts);\n    postFormatContexts(this.tickContexts);\n    return this;\n  } // Take all `voices` and create `ModifierContext`s out of them. This tells\n  // the formatters that the voices belong on a single stave.\n\n\n  joinVoices(voices) {\n    this.createModifierContexts(voices);\n    this.hasMinTotalWidth = false;\n    return this;\n  } // Align rests in voices, justify the contexts, and position the notes\n  // so voices are aligned and ready to render onto the stave. This method\n  // mutates the `x` positions of all tickables in `voices`.\n  //\n  // Voices are full justified to fit in `justifyWidth` pixels.\n  //\n  // Set `options.context` to the rendering context. Set `options.align_rests`\n  // to true to enable rest alignment.\n\n\n  format(voices, justifyWidth, options) {\n    const opts = {\n      align_rests: false,\n      context: null,\n      stave: null,\n      ...options\n    };\n    this.voices = voices;\n\n    if (this.options.softmaxFactor) {\n      this.voices.forEach(v => v.setSoftmaxFactor(this.options.softmaxFactor));\n    }\n\n    this.alignRests(voices, opts.align_rests);\n    this.createTickContexts(voices);\n    this.preFormat(justifyWidth, opts.context, voices, opts.stave); // Only postFormat if a stave was supplied for y value formatting\n\n    if (opts.stave) this.postFormat();\n    return this;\n  } // This method is just like `format` except that the `justifyWidth` is inferred\n  // from the `stave`.\n\n\n  formatToStave(voices, stave, options) {\n    options = {\n      padding: 10,\n      ...options\n    };\n    const justifyWidth = stave.getNoteEndX() - stave.getNoteStartX() - options.padding;\n    L('Formatting voices to width: ', justifyWidth);\n    return this.format(voices, justifyWidth, {\n      context: stave.getContext(),\n      ...options\n    });\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/formatter.js"],"names":["Vex","Beam","Flow","Fraction","Voice","StaveConnector","StaveNote","ModifierContext","TickContext","L","args","Formatter","DEBUG","lookAhead","notes","restLine","i","compare","nextRestLine","length","note","isRest","shouldIgnoreTicks","getLineForRest","top","Math","max","bot","min","MidLine","createContexts","voices","ContextType","addToContext","RERR","totalTicks","getTotalTicks","resolutionMultiplier","reduce","voice","equals","getMode","Mode","STRICT","isComplete","LCM","getResolutionMultiplier","tickToContextMap","tickList","contexts","forEach","voiceIndex","ticksUsed","getTickables","tickable","integerTicks","numerator","newContext","tickID","push","add","getTicks","map","array","list","SortAndUnique","a","b","SimpleFormat","x","paddingBetween","addToModifierContext","tick","addTickable","preFormat","metrics","getMetrics","setX","totalLeftPx","getWidth","totalRightPx","plotDebugging","ctx","formatter","xPos","y1","y2","options","stavePadding","DEFAULT_FONT_STACK","lookupMetric","contextGaps","stroke","x1","x2","color","beginPath","setStrokeStyle","setFillStyle","setLineWidth","fillRect","save","setFont","gaps","gap","fillText","round","totalCost","toFixed","totalShift","total","restore","FormatAndDraw","stave","params","auto_beam","align_rests","Merge","TIME4_4","setMode","SOFT","addTickables","beams","applyAndGetBeams","joinVoices","formatToStave","setStave","draw","beam","setContext","getBoundingBox","FormatAndDrawTab","tabstave","tabnotes","autobeam","opts","notevoice","tabvoice","AlignRestsToNotes","alignAllNotes","alignTuplets","index","tuplet","position","getGlyph","toUpperCase","props","getKeyProps","line","setKeyLine","constructor","softmaxFactor","maxIterations","minTotalWidth","hasMinTotalWidth","tickContexts","modiferContexts","iterationsCompleted","lossHistory","alignRests","preCalculateMinTotalWidth","createTickContexts","contextList","contextMap","context","getMinTotalWidth","createModifierContexts","tContexts","getTicksUsed","clone","justifyWidth","renderingContext","shift","width","evaluate","firstContext","lastContext","calculateIdealDistances","adjustedJustifyWidth","getTickablesByVoice","backTickable","prevContext","j","backTick","backVoices","matchingVoices","Object","keys","v","maxTicks","maxNegativeShiftPx","Infinity","expectedDistance","ticks","value","thisTickable","insideLeftEdge","getX","modLeftPx","leftDisplacedHeadPx","backMetrics","insideRightEdge","notePx","modRightPx","rightDisplacedHeadPx","getVoice","softmax","fromTickable","errorPx","fromTickablePx","shiftToIdealDistances","idealDistances","centerX","spaceAccum","negativeSpaceAccum","ideal","negativeShiftPx","abs","getCenterAlignedTickables","center_x_shift","targetWidth","actualWidth","iterations","prevTick","prevMetrics","currMetrics","getFormatterMetrics","freedom","left","right","durationStats","updateStats","duration","space","stats","undefined","mean","count","simplify","toString","formatterMetrics","leftNoteEdge","rightNote","rightMetrics","rightNoteEdge","used","totalDeviation","deviation","pow","sqrt","tune","alpha","sum","arr","move","current","prev","next","nextContext","cost","t","postFormat","postFormatContexts","format","setSoftmaxFactor","padding","getNoteEndX","getNoteStartX","getContext"],"mappings":"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","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n//\n// This file implements the formatting and layout algorithms that are used\n// to position notes in a voice. The algorithm can align multiple voices both\n// within a stave, and across multiple staves.\n//\n// To do this, the formatter breaks up voices into a grid of rational-valued\n// `ticks`, to which each note is assigned. Then, minimum widths are assigned\n// to each tick based on the widths of the notes and modifiers in that tick. This\n// establishes the smallest amount of space required for each tick.\n//\n// Finally, the formatter distributes the left over space proportionally to\n// all the ticks, setting the `x` values of the notes in each tick.\n//\n// See `tests/formatter_tests.js` for usage examples. The helper functions included\n// here (`FormatAndDraw`, `FormatAndDrawTab`) also serve as useful usage examples.\n\nimport { Vex } from './vex';\nimport { Beam } from './beam';\nimport { Flow } from './tables';\nimport { Fraction } from './fraction';\nimport { Voice } from './voice';\nimport { StaveConnector } from './staveconnector';\nimport { StaveNote } from './stavenote';\nimport { ModifierContext } from './modifiercontext';\nimport { TickContext } from './tickcontext';\n\n// To enable logging for this class. Set `Vex.Flow.Formatter.DEBUG` to `true`.\nfunction L(...args) { if (Formatter.DEBUG) Vex.L('Vex.Flow.Formatter', args); }\n\n// Helper function to locate the next non-rest note(s).\nfunction lookAhead(notes, restLine, i, compare) {\n  // If no valid next note group, nextRestLine is same as current.\n  let nextRestLine = restLine;\n\n  // Get the rest line for next valid non-rest note group.\n  for (i += 1; i < notes.length; i += 1) {\n    const note = notes[i];\n    if (!note.isRest() && !note.shouldIgnoreTicks()) {\n      nextRestLine = note.getLineForRest();\n      break;\n    }\n  }\n\n  // Locate the mid point between two lines.\n  if (compare && restLine !== nextRestLine) {\n    const top = Math.max(restLine, nextRestLine);\n    const bot = Math.min(restLine, nextRestLine);\n    nextRestLine = Vex.MidLine(top, bot);\n  }\n  return nextRestLine;\n}\n\n// Take an array of `voices` and place aligned tickables in the same context. Returns\n// a mapping from `tick` to `ContextType`, a list of `tick`s, and the resolution\n// multiplier.\n//\n// Params:\n// * `voices`: Array of `Voice` instances.\n// * `ContextType`: A context class (e.g., `ModifierContext`, `TickContext`)\n// * `addToContext`: Function to add tickable to context.\nfunction createContexts(voices, ContextType, addToContext) {\n  if (!voices || !voices.length) {\n    throw new Vex.RERR('BadArgument', 'No voices to format');\n  }\n\n  // Find out highest common multiple of resolution multipliers.\n  // The purpose of this is to find out a common denominator\n  // for all fractional tick values in all tickables of all voices,\n  // so that the values can be expanded and the numerator used\n  // as an integer tick value.\n  const totalTicks = voices[0].getTotalTicks();\n  const resolutionMultiplier = voices.reduce((resolutionMultiplier, voice) => {\n    if (!voice.getTotalTicks().equals(totalTicks)) {\n      throw new Vex.RERR(\n        'TickMismatch', 'Voices should have same total note duration in ticks.'\n      );\n    }\n\n    if (voice.getMode() === Voice.Mode.STRICT && !voice.isComplete()) {\n      throw new Vex.RERR(\n        'IncompleteVoice', 'Voice does not have enough notes.'\n      );\n    }\n\n    return Math.max(\n      resolutionMultiplier,\n      Fraction.LCM(resolutionMultiplier, voice.getResolutionMultiplier())\n    );\n  }, 1);\n\n  // Initialize tick maps.\n  const tickToContextMap = {};\n  const tickList = [];\n  const contexts = [];\n\n  // For each voice, extract notes and create a context for every\n  // new tick that hasn't been seen before.\n  voices.forEach((voice, voiceIndex) => {\n    // Use resolution multiplier as denominator to expand ticks\n    // to suitable integer values, so that no additional expansion\n    // of fractional tick values is needed.\n    const ticksUsed = new Fraction(0, resolutionMultiplier);\n\n    voice.getTickables().forEach(tickable => {\n      const integerTicks = ticksUsed.numerator;\n\n      // If we have no tick context for this tick, create one.\n      if (!tickToContextMap[integerTicks]) {\n        const newContext = new ContextType({ tickID: integerTicks });\n        contexts.push(newContext);\n        tickToContextMap[integerTicks] = newContext;\n      }\n\n      // Add this tickable to the TickContext.\n      addToContext(tickable, tickToContextMap[integerTicks], voiceIndex);\n\n      // Maintain a sorted list of tick contexts.\n      tickList.push(integerTicks);\n      ticksUsed.add(tickable.getTicks());\n    });\n  });\n\n  return {\n    map: tickToContextMap,\n    array: contexts,\n    list: Vex.SortAndUnique(tickList, (a, b) => a - b, (a, b) => a === b),\n    resolutionMultiplier,\n  };\n}\n\nexport class Formatter {\n  // Helper function to layout \"notes\" one after the other without\n  // regard for proportions. Useful for tests and debugging.\n  static SimpleFormat(notes, x = 0, { paddingBetween = 10 } = {}) {\n    notes.reduce((x, note) => {\n      note.addToModifierContext(new ModifierContext());\n      const tick = new TickContext().addTickable(note).preFormat();\n      const metrics = tick.getMetrics();\n      tick.setX(x + metrics.totalLeftPx);\n\n      return x + tick.getWidth() + metrics.totalRightPx + paddingBetween;\n    }, x);\n  }\n\n  // Helper function to plot formatter debug info.\n  static plotDebugging(ctx, formatter, xPos, y1, y2, options) {\n    options = {\n      stavePadding: Vex.Flow.DEFAULT_FONT_STACK[0].lookupMetric('stave.padding'),\n      ...options,\n    };\n\n    const x = xPos + options.stavePadding;\n    const contextGaps = formatter.contextGaps;\n    function stroke(x1, x2, color) {\n      ctx.beginPath();\n      ctx.setStrokeStyle(color);\n      ctx.setFillStyle(color);\n      ctx.setLineWidth(1);\n      ctx.fillRect(x1, y1, Math.max(x2 - x1, 0), y2 - y1);\n    }\n\n    ctx.save();\n    ctx.setFont('Arial', 8, '');\n\n    contextGaps.gaps.forEach(gap => {\n      stroke(x + gap.x1, x + gap.x2, 'rgba(100,200,100,0.4)');\n      ctx.setFillStyle('green');\n      ctx.fillText(Math.round(gap.x2 - gap.x1), x + gap.x1, y2 + 12);\n    });\n\n    ctx.setFillStyle('red');\n    ctx.fillText(`Loss: ${(formatter.totalCost || 0).toFixed(2)} Shift: ${(formatter.totalShift || 0).toFixed(2)} Gap: ${contextGaps.total.toFixed(2)}`, x - 20, y2 + 27);\n    ctx.restore();\n  }\n\n  // Helper function to format and draw a single voice. Returns a bounding\n  // box for the notation.\n  //\n  // Parameters:\n  // * `ctx` - The rendering context\n  // * `stave` - The stave to which to draw (`Stave` or `TabStave`)\n  // * `notes` - Array of `Note` instances (`StaveNote`, `TextNote`, `TabNote`, etc.)\n  // * `params` - One of below:\n  //    * Setting `autobeam` only `(context, stave, notes, true)` or\n  //      `(ctx, stave, notes, {autobeam: true})`\n  //    * Setting `align_rests` a struct is needed `(context, stave, notes, {align_rests: true})`\n  //    * Setting both a struct is needed `(context, stave, notes, {\n  //      autobeam: true, align_rests: true})`\n  //\n  // `autobeam` automatically generates beams for the notes.\n  // `align_rests` aligns rests with nearby notes.\n  static FormatAndDraw(ctx, stave, notes, params) {\n    const options = {\n      auto_beam: false,\n      align_rests: false,\n    };\n\n    if (typeof params === 'object') {\n      Vex.Merge(options, params);\n    } else if (typeof params === 'boolean') {\n      options.auto_beam = params;\n    }\n\n    // Start by creating a voice and adding all the notes to it.\n    const voice = new Voice(Flow.TIME4_4)\n      .setMode(Voice.Mode.SOFT)\n      .addTickables(notes);\n\n    // Then create beams, if requested.\n    const beams = options.auto_beam ? Beam.applyAndGetBeams(voice) : [];\n\n    // Instantiate a `Formatter` and format the notes.\n    new Formatter()\n      .joinVoices([voice], { align_rests: options.align_rests })\n      .formatToStave([voice], stave, { align_rests: options.align_rests, stave });\n\n    // Render the voice and beams to the stave.\n    voice.setStave(stave).draw(ctx, stave);\n    beams.forEach(beam => beam.setContext(ctx).draw());\n\n    // Return the bounding box of the voice.\n    return voice.getBoundingBox();\n  }\n\n  // Helper function to format and draw aligned tab and stave notes in two\n  // separate staves.\n  //\n  // Parameters:\n  // * `ctx` - The rendering context\n  // * `tabstave` - A `TabStave` instance on which to render `TabNote`s.\n  // * `stave` - A `Stave` instance on which to render `Note`s.\n  // * `notes` - Array of `Note` instances for the stave (`StaveNote`, `BarNote`, etc.)\n  // * `tabnotes` - Array of `Note` instances for the tab stave (`TabNote`, `BarNote`, etc.)\n  // * `autobeam` - Automatically generate beams.\n  // * `params` - A configuration object:\n  //    * `autobeam` automatically generates beams for the notes.\n  //    * `align_rests` aligns rests with nearby notes.\n  static FormatAndDrawTab(ctx, tabstave, stave, tabnotes, notes, autobeam, params) {\n    const opts = {\n      auto_beam: autobeam,\n      align_rests: false,\n    };\n\n    if (typeof params === 'object') {\n      Vex.Merge(opts, params);\n    } else if (typeof params === 'boolean') {\n      opts.auto_beam = params;\n    }\n\n    // Create a `4/4` voice for `notes`.\n    const notevoice = new Voice(Flow.TIME4_4)\n      .setMode(Voice.Mode.SOFT)\n      .addTickables(notes);\n\n    // Create a `4/4` voice for `tabnotes`.\n    const tabvoice = new Voice(Flow.TIME4_4)\n      .setMode(Voice.Mode.SOFT)\n      .addTickables(tabnotes);\n\n    // Then create beams, if requested.\n    const beams = opts.auto_beam ? Beam.applyAndGetBeams(notevoice) : [];\n\n    // Instantiate a `Formatter` and align tab and stave notes.\n    new Formatter()\n      .joinVoices([notevoice], { align_rests: opts.align_rests })\n      .joinVoices([tabvoice])\n      .formatToStave([notevoice, tabvoice], stave, { align_rests: opts.align_rests });\n\n    // Render voices and beams to staves.\n    notevoice.draw(ctx, stave);\n    tabvoice.draw(ctx, tabstave);\n    beams.forEach(beam => beam.setContext(ctx).draw());\n\n    // Draw a connector between tab and note staves.\n    new StaveConnector(stave, tabstave).setContext(ctx).draw();\n  }\n\n  // Auto position rests based on previous/next note positions.\n  //\n  // Params:\n  // * `notes`: An array of notes.\n  // * `alignAllNotes`: If set to false, only aligns non-beamed notes.\n  // * `alignTuplets`: If set to false, ignores tuplets.\n  static AlignRestsToNotes(notes, alignAllNotes, alignTuplets) {\n    notes.forEach((note, index) => {\n      if (note instanceof StaveNote && note.isRest()) {\n        if (note.tuplet && !alignTuplets) return;\n\n        // If activated rests not on default can be rendered as specified.\n        const position = note.getGlyph().position.toUpperCase();\n        if (position !== 'R/4' && position !== 'B/4') return;\n\n        if (alignAllNotes || note.beam != null) {\n          // Align rests with previous/next notes.\n          const props = note.getKeyProps()[0];\n          if (index === 0) {\n            props.line = lookAhead(notes, props.line, index, false);\n            note.setKeyLine(0, props.line);\n          } else if (index > 0 && index < notes.length) {\n            // If previous note is a rest, use its line number.\n            let restLine;\n            if (notes[index - 1].isRest()) {\n              restLine = notes[index - 1].getKeyProps()[0].line;\n              props.line = restLine;\n            } else {\n              restLine = notes[index - 1].getLineForRest();\n              // Get the rest line for next valid non-rest note group.\n              props.line = lookAhead(notes, restLine, index, true);\n            }\n            note.setKeyLine(0, props.line);\n          }\n        }\n      }\n    });\n\n    return this;\n  }\n\n  constructor(options) {\n    this.options = {\n      softmaxFactor: null,\n      maxIterations: 2,\n      ...options\n    };\n\n    // Minimum width required to render all the notes in the voices.\n    this.minTotalWidth = 0;\n\n    // This is set to `true` after `minTotalWidth` is calculated.\n    this.hasMinTotalWidth = false;\n\n    // Total number of ticks in the voice.\n    this.totalTicks = new Fraction(0, 1);\n\n    // Arrays of tick and modifier contexts.\n    this.tickContexts = null;\n    this.modiferContexts = null;\n\n    // Gaps between contexts, for free movement of notes post\n    // formatting.\n    this.contextGaps = {\n      total: 0,\n      gaps: [],\n    };\n\n    this.voices = [];\n    this.iterationsCompleted = 0;\n    this.lossHistory = [];\n  }\n\n  // Find all the rests in each of the `voices` and align them\n  // to neighboring notes. If `alignAllNotes` is `false`, then only\n  // align non-beamed notes.\n  alignRests(voices, alignAllNotes) {\n    if (!voices || !voices.length) {\n      throw new Vex.RERR('BadArgument', 'No voices to format rests');\n    }\n\n    voices.forEach(voice =>\n      Formatter.AlignRestsToNotes(voice.getTickables(), alignAllNotes));\n  }\n\n  // Calculate the minimum width required to align and format `voices`.\n  preCalculateMinTotalWidth(voices) {\n    // Cache results.\n    if (this.hasMinTotalWidth) return this.minTotalWidth;\n\n    // Create tick contexts if not already created.\n    if (!this.tickContexts) {\n      if (!voices) {\n        throw new Vex.RERR(\n          'BadArgument', \"'voices' required to run preCalculateMinTotalWidth\"\n        );\n      }\n\n      this.createTickContexts(voices);\n    }\n\n    const { list: contextList, map: contextMap } = this.tickContexts;\n\n    // Go through each tick context and calculate total width.\n    this.minTotalWidth = contextList\n      .map(tick => {\n        const context = contextMap[tick];\n        context.preFormat();\n        return context.getWidth();\n      })\n      .reduce((a, b) => a + b, 0);\n\n    this.hasMinTotalWidth = true;\n\n    return this.minTotalWidth;\n  }\n\n  // Get minimum width required to render all voices. Either `format` or\n  // `preCalculateMinTotalWidth` must be called before this method.\n  getMinTotalWidth() {\n    if (!this.hasMinTotalWidth) {\n      throw new Vex.RERR(\n        'NoMinTotalWidth',\n        \"Call 'preCalculateMinTotalWidth' or 'preFormat' before calling 'getMinTotalWidth'\"\n      );\n    }\n\n    return this.minTotalWidth;\n  }\n\n  // Create `ModifierContext`s for each tick in `voices`.\n  createModifierContexts(voices) {\n    const contexts = createContexts(\n      voices,\n      ModifierContext,\n      (tickable, context) => tickable.addToModifierContext(context)\n    );\n\n    this.modiferContexts = contexts;\n    return contexts;\n  }\n\n  // Create `TickContext`s for each tick in `voices`. Also calculate the\n  // total number of ticks in voices.\n  createTickContexts(voices) {\n    const contexts = createContexts(\n      voices,\n      TickContext,\n      (tickable, context, voiceIndex) => context.addTickable(tickable, voiceIndex)\n    );\n\n    contexts.array.forEach(context => {\n      context.tContexts = contexts.array;\n    });\n\n    this.totalTicks = voices[0].getTicksUsed().clone();\n    this.tickContexts = contexts;\n    return contexts;\n  }\n\n  // This is the core formatter logic. Format voices and justify them\n  // to `justifyWidth` pixels. `renderingContext` is required to justify elements\n  // that can't retreive widths without a canvas. This method sets the `x` positions\n  // of all the tickables/notes in the formatter.\n  preFormat(justifyWidth = 0, renderingContext, voices, stave) {\n    // Initialize context maps.\n    const contexts = this.tickContexts;\n    const { list: contextList, map: contextMap } = contexts;\n\n    // Reset loss history for evaluator.\n    this.lossHistory = [];\n\n    // If voices and a stave were provided, set the Stave for each voice\n    // and preFormat to apply Y values to the notes;\n    if (voices && stave) {\n      voices.forEach(voice => voice.setStave(stave).preFormat());\n    }\n\n    // Now distribute the ticks to each tick context, and assign them their\n    // own X positions.\n    let x = 0;\n    let shift = 0;\n    this.minTotalWidth = 0;\n\n    // Pass 1: Give each note maximum width requested by context.\n    contextList.forEach((tick) => {\n      const context = contextMap[tick];\n      if (renderingContext) context.setContext(renderingContext);\n\n      // Make sure that all tickables in this context have calculated their\n      // space requirements.\n      context.preFormat();\n\n      const width = context.getWidth();\n      this.minTotalWidth += width;\n\n      const metrics = context.getMetrics();\n      x = x + shift + metrics.totalLeftPx;\n      context.setX(x);\n\n      // Calculate shift for the next tick.\n      shift = width - metrics.totalLeftPx;\n    });\n\n    this.minTotalWidth = x + shift;\n    this.hasMinTotalWidth = true;\n\n    // No justification needed. End formatting.\n    if (justifyWidth <= 0) return this.evaluate();\n\n\n    // Start justification. Subtract the right extra pixels of the final context because the formatter\n    // justifies based on the context's X position, which is the left-most part of the note head.\n    const firstContext = contextMap[contextList[0]];\n    const lastContext = contextMap[contextList[contextList.length - 1]];\n\n    // Calculate the \"distance error\" between the tick contexts. The expected distance is the spacing proportional to\n    // the softmax of the ticks.\n    function calculateIdealDistances(adjustedJustifyWidth) {\n      return contextList.map((tick, i) => {\n        const context = contextMap[tick];\n        const voices = context.getTickablesByVoice();\n        let backTickable = null;\n        if (i > 0) {\n          const prevContext = contextMap[contextList[i - 1]];\n          // Go through each tickable and search backwards for another tickable\n          // in the same voice. If found, use that duration (ticks) to calculate\n          // the expected distance.\n          for (let j = i - 1; j >= 0; j--) {\n            const backTick = contextMap[contextList[j]];\n            const backVoices = backTick.getTickablesByVoice();\n\n            // Look for matching voices between tick contexts.\n            const matchingVoices = [];\n            Object.keys(voices).forEach(v => {\n              if (backVoices[v]) {\n                matchingVoices.push(v);\n              }\n            });\n\n            if (matchingVoices.length > 0) {\n              // Found matching voices, get largest duration\n              let maxTicks = 0;\n              let maxNegativeShiftPx = Infinity;\n              let expectedDistance = 0;\n\n              // eslint-disable-next-line\n              matchingVoices.forEach(v => {\n                const ticks = backVoices[v].getTicks().value();\n                if (ticks > maxTicks) {\n                  backTickable = backVoices[v];\n                  maxTicks = ticks;\n                }\n\n                // Calculate the limits of the shift based on modifiers, etc.\n                const thisTickable = voices[v];\n                const insideLeftEdge = thisTickable.getX() - (thisTickable.getMetrics().modLeftPx + thisTickable.getMetrics().leftDisplacedHeadPx);\n\n                const backMetrics = backVoices[v].getMetrics();\n                const insideRightEdge = backVoices[v].getX() + backMetrics.notePx + backMetrics.modRightPx + backMetrics.rightDisplacedHeadPx;\n\n                // Don't allow shifting if notes in the same voice can collide\n                maxNegativeShiftPx = Math.min(maxNegativeShiftPx, insideLeftEdge - insideRightEdge);\n              });\n\n              // Don't shift further left than the notehead of the last context\n              maxNegativeShiftPx = Math.min(maxNegativeShiftPx, context.getX() - prevContext.getX());\n\n              // Calculate the expected distance of the current context from the last matching tickable. The\n              // distance is scaled down by the softmax for the voice.\n              expectedDistance = backTickable.getVoice().softmax(maxTicks) * adjustedJustifyWidth;\n\n              return {\n                expectedDistance,\n                maxNegativeShiftPx,\n                fromTickable: backTickable,\n              };\n            }\n          }\n        }\n\n        return { errorPx: 0, fromTickablePx: 0, maxNegativeShiftPx: 0 };\n      });\n    }\n\n\n    function shiftToIdealDistances(idealDistances) {\n      // Distribute ticks to the contexts based on the calculated distance error.\n      const centerX = adjustedJustifyWidth / 2;\n      let spaceAccum = 0;\n      let negativeSpaceAccum = 0;\n\n      contextList.forEach((tick, index) => {\n        const context = contextMap[tick];\n        if (index > 0) {\n          const x = context.getX();\n          const ideal = idealDistances[index];\n          const errorPx = (ideal.fromTickable.getX() + ideal.expectedDistance) - (x + spaceAccum);\n\n          let negativeShiftPx = 0;\n          if (errorPx > 0) {\n            spaceAccum += errorPx;\n          } else if (errorPx < 0) {\n            negativeShiftPx = Math.min(ideal.maxNegativeShiftPx + negativeSpaceAccum, Math.abs(errorPx));\n          }\n\n          context.setX(x + spaceAccum - negativeShiftPx);\n          negativeSpaceAccum += negativeShiftPx;\n        }\n\n        // Move center aligned tickables to middle\n        context.getCenterAlignedTickables().forEach(tickable => { // eslint-disable-line\n          tickable.center_x_shift = centerX - context.getX();\n        });\n      });\n\n      return lastContext.getX() - firstContext.getX();\n    }\n\n\n    const adjustedJustifyWidth = justifyWidth -\n      lastContext.getMetrics().notePx -\n      lastContext.getMetrics().totalRightPx -\n      firstContext.getMetrics().totalLeftPx;\n    let targetWidth = adjustedJustifyWidth;\n    let actualWidth = shiftToIdealDistances(calculateIdealDistances(targetWidth));\n\n    let iterations = this.options.maxIterations;\n    while (actualWidth > (adjustedJustifyWidth + lastContext.getMetrics().notePx) && iterations > 0) {\n      // If we couldn't fit all the notes into the jusification width, it's because the softmax-scaled\n      // widths between different durations differ across stave (e.g., 1 quarter note is not the same pixel-width\n      // as 4 16th-notes). Run another pass, now that we know how much to justify.\n      targetWidth -= (actualWidth - targetWidth);\n      actualWidth = shiftToIdealDistances(calculateIdealDistances(targetWidth));\n      iterations--;\n    }\n\n    // Just one context. Done formatting.\n    if (contextList.length === 1) return null;\n\n    this.justifyWidth = justifyWidth;\n    return this.evaluate();\n  }\n\n  // Calculate the total cost of this formatting decision.\n  evaluate() {\n    const justifyWidth = this.justifyWidth;\n    // Calculate available slack per tick context. This works out how much freedom\n    // to move a context has in either direction, without affecting other notes.\n    this.contextGaps = { total: 0, gaps: [] };\n    this.tickContexts.list.forEach((tick, index) => {\n      if (index === 0) return;\n      const prevTick = this.tickContexts.list[index - 1];\n      const prevContext = this.tickContexts.map[prevTick];\n      const context = this.tickContexts.map[tick];\n      const prevMetrics = prevContext.getMetrics();\n      const currMetrics = context.getMetrics();\n\n      // Calculate X position of right edge of previous note\n      const insideRightEdge = prevContext.getX() + prevMetrics.notePx + prevMetrics.totalRightPx;\n      // Calculate X position of left edge of current note\n      const insideLeftEdge = context.getX() - (currMetrics.totalLeftPx);\n      const gap = insideLeftEdge - insideRightEdge;\n      this.contextGaps.total += gap;\n      this.contextGaps.gaps.push({ x1: insideRightEdge, x2: insideLeftEdge });\n\n      // Tell the tick contexts how much they can reposition themselves.\n      context.getFormatterMetrics().freedom.left = gap;\n      prevContext.getFormatterMetrics().freedom.right = gap;\n    });\n\n    // Calculate mean distance in each voice for each duration type, then calculate\n    // how far each note is from the mean.\n    const durationStats = this.durationStats = {};\n\n    function updateStats(duration, space) {\n      const stats = durationStats[duration];\n      if (stats === undefined) {\n        durationStats[duration] = { mean: space, count: 1 };\n      } else {\n        stats.count += 1;\n        stats.mean = (stats.mean + space) / 2;\n      }\n    }\n\n    this.voices.forEach(voice => {\n      voice.getTickables().forEach((note, i, notes) => {\n        const duration = note.getTicks().clone().simplify().toString();\n        const metrics = note.getMetrics();\n        const formatterMetrics = note.getFormatterMetrics();\n        const leftNoteEdge = note.getX() + metrics.notePx + metrics.totalRightPx;\n        let space = 0;\n\n        if (i < (notes.length - 1)) {\n          const rightNote = notes[i + 1];\n          const rightMetrics = rightNote.getMetrics();\n          const rightNoteEdge = rightNote.getX() - rightMetrics.totalLeftPx;\n\n          space = rightNoteEdge - leftNoteEdge;\n          formatterMetrics.space.used = rightNote.getX() - note.getX();\n          rightNote.getFormatterMetrics().freedom.left = space;\n        } else {\n          space = justifyWidth - leftNoteEdge;\n          formatterMetrics.space.used = justifyWidth - note.getX();\n        }\n\n        formatterMetrics.freedom.right = space;\n        updateStats(duration, formatterMetrics.space.used);\n      });\n    });\n\n    // Calculate how much each note deviates from the mean. Loss function is square\n    // root of the sum of squared deviations.\n    let totalDeviation = 0;\n    this.voices.forEach(voice => {\n      voice.getTickables().forEach((note) => {\n        const duration = note.getTicks().clone().simplify().toString();\n        const metrics = note.getFormatterMetrics();\n\n        metrics.space.mean = durationStats[duration].mean;\n        metrics.duration = duration;\n        metrics.iterations += 1;\n        metrics.space.deviation = metrics.space.used - metrics.space.mean;\n\n        totalDeviation += Math.pow(metrics.space.deviation, 2);\n      });\n    });\n\n    this.totalCost = Math.sqrt(totalDeviation);\n    this.lossHistory.push(this.totalCost);\n    return this.totalCost;\n  }\n\n  // Run a single iteration of rejustification. At a high level, this method calculates\n  // the overall \"loss\" (or cost) of this layout, and repositions tickcontexts in an\n  // attempt to reduce the cost. You can call this method multiple times until it finds\n  // and oscillates around a global minimum.\n  //\n  // Alpha is the \"learning rate\" for the formatter. It determines how much of a shift\n  // the formatter should make based on its cost function.\n  tune(options) {\n    options = {\n      alpha: 0.5,\n      ...options,\n    };\n\n    const sum = (arr) => arr.reduce((a, b) => a + b);\n\n    // Move `current` tickcontext by `shift` pixels, and adjust the freedom\n    // on adjacent tickcontexts.\n    function move(current, prev, next, shift) {\n      current.setX(current.getX() + shift);\n      current.getFormatterMetrics().freedom.left += shift;\n      current.getFormatterMetrics().freedom.right -= shift;\n\n      if (prev) prev.getFormatterMetrics().freedom.right += shift;\n      if (next) next.getFormatterMetrics().freedom.left -= shift;\n    }\n\n    let shift = 0;\n    this.totalShift = 0;\n    this.tickContexts.list.forEach((tick, index, list) => {\n      const context = this.tickContexts.map[tick];\n      const prevContext = (index > 0) ? this.tickContexts.map[list[index - 1]] : null;\n      const nextContext = (index < list.length - 1) ? this.tickContexts.map[list[index + 1]] : null;\n\n      move(context, prevContext, nextContext, shift);\n\n      const cost = -sum(\n        context.getTickables().map(t => t.getFormatterMetrics().space.deviation));\n\n      if (cost > 0) {\n        shift = -Math.min(context.getFormatterMetrics().freedom.right, Math.abs(cost));\n      } else if (cost < 0) {\n        if (nextContext) {\n          shift = Math.min(nextContext.getFormatterMetrics().freedom.right, Math.abs(cost));\n        } else {\n          shift = 0;\n        }\n      }\n\n      shift *= options.alpha;\n      this.totalShift += shift;\n    });\n\n    this.iterationsCompleted++;\n    return this.evaluate();\n  }\n\n  // This is the top-level call for all formatting logic completed\n  // after `x` *and* `y` values have been computed for the notes\n  // in the voices.\n  postFormat() {\n    const postFormatContexts = (contexts) =>\n      contexts.list.forEach(tick => contexts.map[tick].postFormat());\n\n    postFormatContexts(this.modiferContexts);\n    postFormatContexts(this.tickContexts);\n\n    return this;\n  }\n\n  // Take all `voices` and create `ModifierContext`s out of them. This tells\n  // the formatters that the voices belong on a single stave.\n  joinVoices(voices) {\n    this.createModifierContexts(voices);\n    this.hasMinTotalWidth = false;\n    return this;\n  }\n\n  // Align rests in voices, justify the contexts, and position the notes\n  // so voices are aligned and ready to render onto the stave. This method\n  // mutates the `x` positions of all tickables in `voices`.\n  //\n  // Voices are full justified to fit in `justifyWidth` pixels.\n  //\n  // Set `options.context` to the rendering context. Set `options.align_rests`\n  // to true to enable rest alignment.\n  format(voices, justifyWidth, options) {\n    const opts = {\n      align_rests: false,\n      context: null,\n      stave: null,\n      ...options,\n    };\n\n    this.voices = voices;\n    if (this.options.softmaxFactor) {\n      this.voices.forEach(v => v.setSoftmaxFactor(this.options.softmaxFactor));\n    }\n\n    this.alignRests(voices, opts.align_rests);\n    this.createTickContexts(voices);\n    this.preFormat(justifyWidth, opts.context, voices, opts.stave);\n\n    // Only postFormat if a stave was supplied for y value formatting\n    if (opts.stave) this.postFormat();\n\n    return this;\n  }\n\n  // This method is just like `format` except that the `justifyWidth` is inferred\n  // from the `stave`.\n  formatToStave(voices, stave, options) {\n    options = {\n      padding: 10,\n      ...options\n    };\n\n    const justifyWidth = stave.getNoteEndX() - stave.getNoteStartX() - options.padding;\n    L('Formatting voices to width: ', justifyWidth);\n    return this.format(voices, justifyWidth, { context: stave.getContext(), ...options });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}