{"ast":null,"code":"// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n\n/**\n * ## Description\n *\n * Create a new tuplet from the specified notes. The notes must\n * be part of the same voice. If they are of different rhythmic\n * values, then options.num_notes must be set.\n *\n * @constructor\n * @param {Array.<Vex.Flow.StaveNote>} A set of notes: staveNotes,\n *   notes, etc... any class that inherits stemmableNote at some\n *   point in its prototype chain.\n * @param options: object {\n *\n *   num_notes: fit this many notes into...\n *   notes_occupied: ...the space of this many notes\n *\n *       Together, these two properties make up the tuplet ratio\n *     in the form of num_notes : notes_occupied.\n *       num_notes defaults to the number of notes passed in, so\n *     it is important that if you omit this property, all of\n *     the notes passed should be of the same note value.\n *       notes_occupied defaults to 2 -- so you should almost\n *     certainly pass this parameter for anything other than\n *     a basic triplet.\n *\n *   location:\n *     default 1, which is above the notes: ┌─── 3 ───┐\n *      -1 is below the notes └─── 3 ───┘\n *\n *   bracketed: boolean, draw a bracket around the tuplet number\n *     when true: ┌─── 3 ───┐   when false: 3\n *     defaults to true if notes are not beamed, false otherwise\n *\n *   ratioed: boolean\n *     when true: ┌─── 7:8 ───┐, when false: ┌─── 7 ───┐\n *     defaults to true if the difference between num_notes and\n *     notes_occupied is greater than 1.\n *\n *   y_offset: int, default 0\n *     manually offset a tuplet, for instance to avoid collisions\n *     with articulations, etc...\n * }\n */\nimport { Vex } from './vex';\nimport { Element } from './element';\nimport { Formatter } from './formatter';\nimport { Glyph } from './glyph';\nimport { Stem } from './stem';\nexport class Tuplet extends Element {\n  static get LOCATION_TOP() {\n    return 1;\n  }\n\n  static get LOCATION_BOTTOM() {\n    return -1;\n  }\n\n  static get NESTING_OFFSET() {\n    return 15;\n  }\n\n  constructor(notes, options) {\n    super();\n    this.setAttribute('type', 'Tuplet');\n\n    if (!notes || !notes.length) {\n      throw new Vex.RuntimeError('BadArguments', 'No notes provided for tuplet.');\n    }\n\n    this.options = Vex.Merge({}, options);\n    this.notes = notes;\n    this.num_notes = 'num_notes' in this.options ? this.options.num_notes : notes.length; // We accept beats_occupied, but warn that it's deprecated:\n    // the preferred property name is now notes_occupied.\n\n    if (this.options.beats_occupied) {\n      this.beatsOccupiedDeprecationWarning();\n    }\n\n    this.notes_occupied = this.options.notes_occupied || this.options.beats_occupied || 2;\n\n    if ('bracketed' in this.options) {\n      this.bracketed = this.options.bracketed;\n    } else {\n      this.bracketed = notes.some(note => note.beam === null);\n    }\n\n    this.ratioed = 'ratioed' in this.options ? this.options.ratioed : Math.abs(this.notes_occupied - this.num_notes) > 1;\n    this.point = this.musicFont.lookupMetric('digits.tupletPoint');\n    this.y_pos = 16;\n    this.x_pos = 100;\n    this.width = 200;\n    this.location = this.options.location || Tuplet.LOCATION_TOP;\n    Formatter.AlignRestsToNotes(notes, true, true);\n    this.resolveGlyphs();\n    this.attach();\n  }\n\n  attach() {\n    for (let i = 0; i < this.notes.length; i++) {\n      const note = this.notes[i];\n      note.setTuplet(this);\n    }\n  }\n\n  detach() {\n    for (let i = 0; i < this.notes.length; i++) {\n      const note = this.notes[i];\n      note.resetTuplet(this);\n    }\n  }\n  /**\n   * Set whether or not the bracket is drawn.\n   */\n\n\n  setBracketed(bracketed) {\n    this.bracketed = !!bracketed;\n    return this;\n  }\n  /**\n   * Set whether or not the ratio is shown.\n   */\n\n\n  setRatioed(ratioed) {\n    this.ratioed = !!ratioed;\n    return this;\n  }\n  /**\n   * Set the tuplet to be displayed either on the top or bottom of the stave\n   */\n\n\n  setTupletLocation(location) {\n    if (!location) {\n      location = Tuplet.LOCATION_TOP;\n    } else if (location !== Tuplet.LOCATION_TOP && location !== Tuplet.LOCATION_BOTTOM) {\n      throw new Vex.RERR('BadArgument', 'Invalid tuplet location: ' + location);\n    }\n\n    this.location = location;\n    return this;\n  }\n\n  getNotes() {\n    return this.notes;\n  }\n\n  getNoteCount() {\n    return this.num_notes;\n  }\n\n  beatsOccupiedDeprecationWarning() {\n    const msg = ['beats_occupied has been deprecated as an ', 'option for tuplets. Please use notes_occupied ', 'instead. Calls to getBeatsOccupied and ', 'setBeatsOccupied should now be routed to ', 'getNotesOccupied and setNotesOccupied instead'].join('');\n\n    if (console && console.warn) {\n      // eslint-disable-line no-console\n      console.warn(msg); // eslint-disable-line no-console\n    } else if (console) {\n      console.log(msg); // eslint-disable-line no-console\n    }\n  }\n\n  getBeatsOccupied() {\n    this.beatsOccupiedDeprecationWarning();\n    return this.getNotesOccupied();\n  }\n\n  setBeatsOccupied(beats) {\n    this.beatsOccupiedDeprecationWarning();\n    return this.setNotesOccupied(beats);\n  }\n\n  getNotesOccupied() {\n    return this.notes_occupied;\n  }\n\n  setNotesOccupied(notes) {\n    this.detach();\n    this.notes_occupied = notes;\n    this.resolveGlyphs();\n    this.attach();\n  }\n\n  resolveGlyphs() {\n    this.numerator_glyphs = [];\n    let n = this.num_notes;\n\n    while (n >= 1) {\n      this.numerator_glyphs.unshift(new Glyph('timeSig' + n % 10, this.point));\n      n = parseInt(n / 10, 10);\n    }\n\n    this.denom_glyphs = [];\n    n = this.notes_occupied;\n\n    while (n >= 1) {\n      this.denom_glyphs.unshift(new Glyph('timeSig' + n % 10, this.point));\n      n = parseInt(n / 10, 10);\n    }\n  } // determine how many tuplets are nested within this tuplet\n  // on the same side (above/below), to calculate a y\n  // offset for this tuplet:\n\n\n  getNestedTupletCount() {\n    const location = this.location;\n    const first_note = this.notes[0];\n    let maxTupletCount = countTuplets(first_note, location);\n    let minTupletCount = countTuplets(first_note, location); // Count the tuplets that are on the same side (above/below)\n    // as this tuplet:\n\n    function countTuplets(note, location) {\n      return note.tupletStack.filter(tuplet => tuplet.location === location).length;\n    }\n\n    this.notes.forEach(note => {\n      const tupletCount = countTuplets(note, location);\n      maxTupletCount = tupletCount > maxTupletCount ? tupletCount : maxTupletCount;\n      minTupletCount = tupletCount < minTupletCount ? tupletCount : minTupletCount;\n    });\n    return maxTupletCount - minTupletCount;\n  } // determine the y position of the tuplet:\n\n\n  getYPosition() {\n    // offset the tuplet for any nested tuplets between\n    // it and the notes:\n    const nested_tuplet_y_offset = this.getNestedTupletCount() * Tuplet.NESTING_OFFSET * -this.location; // offset the tuplet for any manual y_offset:\n\n    const y_offset = this.options.y_offset || 0; // now iterate through the notes and find our highest\n    // or lowest locations, to form a base y_pos\n\n    const first_note = this.notes[0];\n    let y_pos;\n\n    if (this.location === Tuplet.LOCATION_TOP) {\n      y_pos = first_note.getStave().getYForLine(0) - 15; // y_pos = first_note.getStemExtents().topY - 10;\n\n      for (let i = 0; i < this.notes.length; ++i) {\n        const top_y = this.notes[i].getStemDirection() === Stem.UP ? this.notes[i].getStemExtents().topY - 10 : this.notes[i].getStemExtents().baseY - 20;\n\n        if (top_y < y_pos) {\n          y_pos = top_y;\n        }\n      }\n    } else {\n      y_pos = first_note.getStave().getYForLine(4) + 20;\n\n      for (let i = 0; i < this.notes.length; ++i) {\n        const bottom_y = this.notes[i].getStemDirection() === Stem.UP ? this.notes[i].getStemExtents().baseY + 20 : this.notes[i].getStemExtents().topY + 10;\n\n        if (bottom_y > y_pos) {\n          y_pos = bottom_y;\n        }\n      }\n    }\n\n    return y_pos + nested_tuplet_y_offset + y_offset;\n  }\n\n  draw() {\n    this.checkContext();\n    this.setRendered(); // determine x value of left bound of tuplet\n\n    const first_note = this.notes[0];\n    const last_note = this.notes[this.notes.length - 1];\n\n    if (!this.bracketed) {\n      this.x_pos = first_note.getStemX();\n      this.width = last_note.getStemX() - this.x_pos;\n    } else {\n      this.x_pos = first_note.getTieLeftX() - 5;\n      this.width = last_note.getTieRightX() - this.x_pos + 5;\n    } // determine y value for tuplet\n\n\n    this.y_pos = this.getYPosition();\n\n    const addGlyphWidth = (width, glyph) => width + glyph.getMetrics().width; // calculate total width of tuplet notation\n\n\n    let width = this.numerator_glyphs.reduce(addGlyphWidth, 0);\n\n    if (this.ratioed) {\n      width = this.denom_glyphs.reduce(addGlyphWidth, width);\n      width += this.point * 0.32;\n    }\n\n    const notation_center_x = this.x_pos + this.width / 2;\n    const notation_start_x = notation_center_x - width / 2; // draw bracket if the tuplet is not beamed\n\n    if (this.bracketed) {\n      const line_width = this.width / 2 - width / 2 - 5; // only draw the bracket if it has positive length\n\n      if (line_width > 0) {\n        this.context.fillRect(this.x_pos, this.y_pos, line_width, 1);\n        this.context.fillRect(this.x_pos + this.width / 2 + width / 2 + 5, this.y_pos, line_width, 1);\n        this.context.fillRect(this.x_pos, this.y_pos + (this.location === Tuplet.LOCATION_BOTTOM), 1, this.location * 10);\n        this.context.fillRect(this.x_pos + this.width, this.y_pos + (this.location === Tuplet.LOCATION_BOTTOM), 1, this.location * 10);\n      }\n    } // draw numerator glyphs\n\n\n    const shiftY = this.musicFont.lookupMetric('digits.shiftY', 0);\n    let x_offset = 0;\n    this.numerator_glyphs.forEach(glyph => {\n      glyph.render(this.context, notation_start_x + x_offset, this.y_pos + this.point / 3 - 2 + shiftY);\n      x_offset += glyph.getMetrics().width;\n    }); // display colon and denominator if the ratio is to be shown\n\n    if (this.ratioed) {\n      const colon_x = notation_start_x + x_offset + this.point * 0.16;\n      const colon_radius = this.point * 0.06;\n      this.context.beginPath();\n      this.context.arc(colon_x, this.y_pos - this.point * 0.08, colon_radius, 0, Math.PI * 2, true);\n      this.context.closePath();\n      this.context.fill();\n      this.context.beginPath();\n      this.context.arc(colon_x, this.y_pos + this.point * 0.12, colon_radius, 0, Math.PI * 2, true);\n      this.context.closePath();\n      this.context.fill();\n      x_offset += this.point * 0.32;\n      this.denom_glyphs.forEach(glyph => {\n        glyph.render(this.context, notation_start_x + x_offset, this.y_pos + this.point / 3 - 2 + shiftY);\n        x_offset += glyph.getMetrics().width;\n      });\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/tuplet.js"],"names":["Vex","Element","Formatter","Glyph","Stem","Tuplet","LOCATION_TOP","LOCATION_BOTTOM","NESTING_OFFSET","constructor","notes","options","setAttribute","length","RuntimeError","Merge","num_notes","beats_occupied","beatsOccupiedDeprecationWarning","notes_occupied","bracketed","some","note","beam","ratioed","Math","abs","point","musicFont","lookupMetric","y_pos","x_pos","width","location","AlignRestsToNotes","resolveGlyphs","attach","i","setTuplet","detach","resetTuplet","setBracketed","setRatioed","setTupletLocation","RERR","getNotes","getNoteCount","msg","join","console","warn","log","getBeatsOccupied","getNotesOccupied","setBeatsOccupied","beats","setNotesOccupied","numerator_glyphs","n","unshift","parseInt","denom_glyphs","getNestedTupletCount","first_note","maxTupletCount","countTuplets","minTupletCount","tupletStack","filter","tuplet","forEach","tupletCount","getYPosition","nested_tuplet_y_offset","y_offset","getStave","getYForLine","top_y","getStemDirection","UP","getStemExtents","topY","baseY","bottom_y","draw","checkContext","setRendered","last_note","getStemX","getTieLeftX","getTieRightX","addGlyphWidth","glyph","getMetrics","reduce","notation_center_x","notation_start_x","line_width","context","fillRect","shiftY","x_offset","render","colon_x","colon_radius","beginPath","arc","PI","closePath","fill"],"mappings":"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","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n\n/**\n * ## Description\n *\n * Create a new tuplet from the specified notes. The notes must\n * be part of the same voice. If they are of different rhythmic\n * values, then options.num_notes must be set.\n *\n * @constructor\n * @param {Array.<Vex.Flow.StaveNote>} A set of notes: staveNotes,\n *   notes, etc... any class that inherits stemmableNote at some\n *   point in its prototype chain.\n * @param options: object {\n *\n *   num_notes: fit this many notes into...\n *   notes_occupied: ...the space of this many notes\n *\n *       Together, these two properties make up the tuplet ratio\n *     in the form of num_notes : notes_occupied.\n *       num_notes defaults to the number of notes passed in, so\n *     it is important that if you omit this property, all of\n *     the notes passed should be of the same note value.\n *       notes_occupied defaults to 2 -- so you should almost\n *     certainly pass this parameter for anything other than\n *     a basic triplet.\n *\n *   location:\n *     default 1, which is above the notes: ┌─── 3 ───┐\n *      -1 is below the notes └─── 3 ───┘\n *\n *   bracketed: boolean, draw a bracket around the tuplet number\n *     when true: ┌─── 3 ───┐   when false: 3\n *     defaults to true if notes are not beamed, false otherwise\n *\n *   ratioed: boolean\n *     when true: ┌─── 7:8 ───┐, when false: ┌─── 7 ───┐\n *     defaults to true if the difference between num_notes and\n *     notes_occupied is greater than 1.\n *\n *   y_offset: int, default 0\n *     manually offset a tuplet, for instance to avoid collisions\n *     with articulations, etc...\n * }\n */\n\nimport { Vex } from './vex';\nimport { Element } from './element';\nimport { Formatter } from './formatter';\nimport { Glyph } from './glyph';\nimport { Stem } from './stem';\n\nexport class Tuplet extends Element {\n  static get LOCATION_TOP() {\n    return 1;\n  }\n  static get LOCATION_BOTTOM() {\n    return -1;\n  }\n  static get NESTING_OFFSET() {\n    return 15;\n  }\n\n  constructor(notes, options) {\n    super();\n    this.setAttribute('type', 'Tuplet');\n    if (!notes || !notes.length) {\n      throw new Vex.RuntimeError('BadArguments', 'No notes provided for tuplet.');\n    }\n\n    this.options = Vex.Merge({}, options);\n    this.notes = notes;\n    this.num_notes = 'num_notes' in this.options ?\n      this.options.num_notes : notes.length;\n\n    // We accept beats_occupied, but warn that it's deprecated:\n    // the preferred property name is now notes_occupied.\n    if (this.options.beats_occupied) {\n      this.beatsOccupiedDeprecationWarning();\n    }\n    this.notes_occupied = this.options.notes_occupied ||\n      this.options.beats_occupied ||\n      2;\n    if ('bracketed' in this.options) {\n      this.bracketed = this.options.bracketed;\n    } else {\n      this.bracketed =\n        notes.some(note => note.beam === null);\n    }\n\n    this.ratioed = 'ratioed' in this.options ?\n      this.options.ratioed :\n      (Math.abs(this.notes_occupied - this.num_notes) > 1);\n    this.point = this.musicFont.lookupMetric('digits.tupletPoint');\n    this.y_pos = 16;\n    this.x_pos = 100;\n    this.width = 200;\n    this.location = this.options.location || Tuplet.LOCATION_TOP;\n\n    Formatter.AlignRestsToNotes(notes, true, true);\n    this.resolveGlyphs();\n    this.attach();\n  }\n\n  attach() {\n    for (let i = 0; i < this.notes.length; i++) {\n      const note = this.notes[i];\n      note.setTuplet(this);\n    }\n  }\n\n  detach() {\n    for (let i = 0; i < this.notes.length; i++) {\n      const note = this.notes[i];\n      note.resetTuplet(this);\n    }\n  }\n\n  /**\n   * Set whether or not the bracket is drawn.\n   */\n  setBracketed(bracketed) {\n    this.bracketed = !!bracketed;\n    return this;\n  }\n\n  /**\n   * Set whether or not the ratio is shown.\n   */\n  setRatioed(ratioed) {\n    this.ratioed = !!ratioed;\n    return this;\n  }\n\n  /**\n   * Set the tuplet to be displayed either on the top or bottom of the stave\n   */\n  setTupletLocation(location) {\n    if (!location) {\n      location = Tuplet.LOCATION_TOP;\n    } else if (location !== Tuplet.LOCATION_TOP && location !== Tuplet.LOCATION_BOTTOM) {\n      throw new Vex.RERR('BadArgument', 'Invalid tuplet location: ' + location);\n    }\n\n    this.location = location;\n    return this;\n  }\n\n  getNotes() {\n    return this.notes;\n  }\n\n  getNoteCount() {\n    return this.num_notes;\n  }\n\n  beatsOccupiedDeprecationWarning() {\n    const msg = [\n      'beats_occupied has been deprecated as an ',\n      'option for tuplets. Please use notes_occupied ',\n      'instead. Calls to getBeatsOccupied and ',\n      'setBeatsOccupied should now be routed to ',\n      'getNotesOccupied and setNotesOccupied instead',\n    ].join('');\n\n    if (console && console.warn) { // eslint-disable-line no-console\n      console.warn(msg); // eslint-disable-line no-console\n    } else if (console) {\n      console.log(msg); // eslint-disable-line no-console\n    }\n  }\n\n  getBeatsOccupied() {\n    this.beatsOccupiedDeprecationWarning();\n    return this.getNotesOccupied();\n  }\n\n  setBeatsOccupied(beats) {\n    this.beatsOccupiedDeprecationWarning();\n    return this.setNotesOccupied(beats);\n  }\n\n  getNotesOccupied() {\n    return this.notes_occupied;\n  }\n\n  setNotesOccupied(notes) {\n    this.detach();\n    this.notes_occupied = notes;\n    this.resolveGlyphs();\n    this.attach();\n  }\n\n  resolveGlyphs() {\n    this.numerator_glyphs = [];\n    let n = this.num_notes;\n    while (n >= 1) {\n      this.numerator_glyphs.unshift(new Glyph('timeSig' + (n % 10), this.point));\n      n = parseInt(n / 10, 10);\n    }\n\n    this.denom_glyphs = [];\n    n = this.notes_occupied;\n    while (n >= 1) {\n      this.denom_glyphs.unshift(new Glyph('timeSig' + (n % 10), this.point));\n      n = parseInt(n / 10, 10);\n    }\n  }\n\n  // determine how many tuplets are nested within this tuplet\n  // on the same side (above/below), to calculate a y\n  // offset for this tuplet:\n  getNestedTupletCount() {\n    const location = this.location;\n    const first_note = this.notes[0];\n    let maxTupletCount = countTuplets(first_note, location);\n    let minTupletCount = countTuplets(first_note, location);\n\n    // Count the tuplets that are on the same side (above/below)\n    // as this tuplet:\n    function countTuplets(note, location) {\n      return note.tupletStack.filter(tuplet => tuplet.location === location).length;\n    }\n\n    this.notes.forEach(note => {\n      const tupletCount = countTuplets(note, location);\n      maxTupletCount = tupletCount > maxTupletCount ? tupletCount : maxTupletCount;\n      minTupletCount = tupletCount < minTupletCount ? tupletCount : minTupletCount;\n    });\n\n    return maxTupletCount - minTupletCount;\n  }\n\n  // determine the y position of the tuplet:\n  getYPosition() {\n    // offset the tuplet for any nested tuplets between\n    // it and the notes:\n    const nested_tuplet_y_offset =\n      this.getNestedTupletCount() *\n      Tuplet.NESTING_OFFSET *\n      -this.location;\n\n    // offset the tuplet for any manual y_offset:\n    const y_offset = this.options.y_offset || 0;\n\n    // now iterate through the notes and find our highest\n    // or lowest locations, to form a base y_pos\n    const first_note = this.notes[0];\n    let y_pos;\n    if (this.location === Tuplet.LOCATION_TOP) {\n      y_pos = first_note.getStave().getYForLine(0) - 15;\n      // y_pos = first_note.getStemExtents().topY - 10;\n\n      for (let i = 0; i < this.notes.length; ++i) {\n        const top_y = this.notes[i].getStemDirection() === Stem.UP\n          ? this.notes[i].getStemExtents().topY - 10\n          : this.notes[i].getStemExtents().baseY - 20;\n\n        if (top_y < y_pos) {\n          y_pos = top_y;\n        }\n      }\n    } else {\n      y_pos = first_note.getStave().getYForLine(4) + 20;\n\n      for (let i = 0; i < this.notes.length; ++i) {\n        const bottom_y = this.notes[i].getStemDirection() === Stem.UP\n          ? this.notes[i].getStemExtents().baseY + 20\n          : this.notes[i].getStemExtents().topY + 10;\n        if (bottom_y > y_pos) {\n          y_pos = bottom_y;\n        }\n      }\n    }\n\n    return y_pos + nested_tuplet_y_offset + y_offset;\n  }\n\n  draw() {\n    this.checkContext();\n    this.setRendered();\n\n    // determine x value of left bound of tuplet\n    const first_note = this.notes[0];\n    const last_note = this.notes[this.notes.length - 1];\n\n    if (!this.bracketed) {\n      this.x_pos = first_note.getStemX();\n      this.width = last_note.getStemX() - this.x_pos;\n    } else {\n      this.x_pos = first_note.getTieLeftX() - 5;\n      this.width = last_note.getTieRightX() - this.x_pos + 5;\n    }\n\n    // determine y value for tuplet\n    this.y_pos = this.getYPosition();\n\n    const addGlyphWidth = (width, glyph) => width + glyph.getMetrics().width;\n\n    // calculate total width of tuplet notation\n    let width = this.numerator_glyphs.reduce(addGlyphWidth, 0);\n    if (this.ratioed) {\n      width = this.denom_glyphs.reduce(addGlyphWidth, width);\n      width += this.point * 0.32;\n    }\n\n    const notation_center_x = this.x_pos + (this.width / 2);\n    const notation_start_x = notation_center_x - (width / 2);\n\n    // draw bracket if the tuplet is not beamed\n    if (this.bracketed) {\n      const line_width = this.width / 2 - width / 2 - 5;\n\n      // only draw the bracket if it has positive length\n      if (line_width > 0) {\n        this.context.fillRect(this.x_pos, this.y_pos, line_width, 1);\n        this.context.fillRect(\n          this.x_pos + this.width / 2 + width / 2 + 5,\n          this.y_pos,\n          line_width,\n          1\n        );\n        this.context.fillRect(\n          this.x_pos,\n          this.y_pos + (this.location === Tuplet.LOCATION_BOTTOM),\n          1,\n          this.location * 10\n        );\n        this.context.fillRect(\n          this.x_pos + this.width,\n          this.y_pos + (this.location === Tuplet.LOCATION_BOTTOM),\n          1,\n          this.location * 10\n        );\n      }\n    }\n\n    // draw numerator glyphs\n    const shiftY = this.musicFont.lookupMetric('digits.shiftY', 0);\n\n    let x_offset = 0;\n    this.numerator_glyphs.forEach(glyph => {\n      glyph.render(this.context, notation_start_x + x_offset, this.y_pos + (this.point / 3) - 2 + shiftY);\n      x_offset += glyph.getMetrics().width;\n    });\n\n    // display colon and denominator if the ratio is to be shown\n    if (this.ratioed) {\n      const colon_x = notation_start_x + x_offset + this.point * 0.16;\n      const colon_radius = this.point * 0.06;\n      this.context.beginPath();\n      this.context.arc(colon_x, this.y_pos - this.point * 0.08, colon_radius, 0, Math.PI * 2, true);\n      this.context.closePath();\n      this.context.fill();\n      this.context.beginPath();\n      this.context.arc(colon_x, this.y_pos + this.point * 0.12, colon_radius, 0, Math.PI * 2, true);\n      this.context.closePath();\n      this.context.fill();\n      x_offset += this.point * 0.32;\n      this.denom_glyphs.forEach(glyph => {\n        glyph.render(this.context, notation_start_x + x_offset, this.y_pos + (this.point / 3) - 2 + shiftY);\n        x_offset += glyph.getMetrics().width;\n      });\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}