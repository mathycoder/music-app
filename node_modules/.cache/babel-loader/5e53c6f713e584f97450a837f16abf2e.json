{"ast":null,"code":"// VexFlow - Music Engraving for HTML5\n// Copyright Mohit Muthanna 2010\n//\n// This class implements curves (for slurs)\nimport { Vex } from './vex';\nimport { Element } from './element';\nexport class Curve extends Element {\n  static get Position() {\n    return {\n      NEAR_HEAD: 1,\n      NEAR_TOP: 2\n    };\n  }\n\n  static get PositionString() {\n    return {\n      nearHead: Curve.Position.NEAR_HEAD,\n      nearTop: Curve.Position.NEAR_TOP\n    };\n  } // from: Start note\n  // to: End note\n  // options:\n  //    cps: List of control points\n  //    x_shift: pixels to shift\n  //    y_shift: pixels to shift\n\n\n  constructor(from, to, options) {\n    super();\n    this.setAttribute('type', 'Curve');\n    this.render_options = {\n      spacing: 2,\n      thickness: 2,\n      x_shift: 0,\n      y_shift: 10,\n      position: Curve.Position.NEAR_HEAD,\n      position_end: Curve.Position.NEAR_HEAD,\n      invert: false,\n      cps: [{\n        x: 0,\n        y: 10\n      }, {\n        x: 0,\n        y: 10\n      }]\n    };\n    Vex.Merge(this.render_options, options);\n    this.setNotes(from, to);\n  }\n\n  setNotes(from, to) {\n    if (!from && !to) {\n      throw new Vex.RuntimeError('BadArguments', 'Curve needs to have either first_note or last_note set.');\n    }\n\n    this.from = from;\n    this.to = to;\n    return this;\n  }\n  /**\n   * @return {boolean} Returns true if this is a partial bar.\n   */\n\n\n  isPartial() {\n    return !this.from || !this.to;\n  }\n\n  renderCurve(params) {\n    const ctx = this.context;\n    const cps = this.render_options.cps;\n    const x_shift = this.render_options.x_shift;\n    const y_shift = this.render_options.y_shift * params.direction;\n    const first_x = params.first_x + x_shift;\n    const first_y = params.first_y + y_shift;\n    const last_x = params.last_x - x_shift;\n    const last_y = params.last_y + y_shift;\n    const thickness = this.render_options.thickness;\n    const cp_spacing = (last_x - first_x) / (cps.length + 2);\n    ctx.beginPath();\n    ctx.moveTo(first_x, first_y);\n    ctx.bezierCurveTo(first_x + cp_spacing + cps[0].x, first_y + cps[0].y * params.direction, last_x - cp_spacing + cps[1].x, last_y + cps[1].y * params.direction, last_x, last_y);\n    ctx.bezierCurveTo(last_x - cp_spacing + cps[1].x, last_y + (cps[1].y + thickness) * params.direction, first_x + cp_spacing + cps[0].x, first_y + (cps[0].y + thickness) * params.direction, first_x, first_y);\n    ctx.stroke();\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  draw() {\n    this.checkContext();\n    this.setRendered();\n    const first_note = this.from;\n    const last_note = this.to;\n    let first_x;\n    let last_x;\n    let first_y;\n    let last_y;\n    let stem_direction;\n    let metric = 'baseY';\n    let end_metric = 'baseY';\n\n    function getPosition(position) {\n      return typeof position === 'string' ? Curve.PositionString[position] : position;\n    }\n\n    const position = getPosition(this.render_options.position);\n    const position_end = getPosition(this.render_options.position_end);\n\n    if (position === Curve.Position.NEAR_TOP) {\n      metric = 'topY';\n      end_metric = 'topY';\n    }\n\n    if (position_end === Curve.Position.NEAR_HEAD) {\n      end_metric = 'baseY';\n    } else if (position_end === Curve.Position.NEAR_TOP) {\n      end_metric = 'topY';\n    }\n\n    if (first_note) {\n      first_x = first_note.getTieRightX();\n      stem_direction = first_note.getStemDirection();\n      first_y = first_note.getStemExtents()[metric];\n    } else {\n      first_x = last_note.getStave().getTieStartX();\n      first_y = last_note.getStemExtents()[metric];\n    }\n\n    if (last_note) {\n      last_x = last_note.getTieLeftX();\n      stem_direction = last_note.getStemDirection();\n      last_y = last_note.getStemExtents()[end_metric];\n    } else {\n      last_x = first_note.getStave().getTieEndX();\n      last_y = first_note.getStemExtents()[end_metric];\n    }\n\n    this.renderCurve({\n      first_x,\n      last_x,\n      first_y,\n      last_y,\n      direction: stem_direction * (this.render_options.invert === true ? -1 : 1)\n    });\n    return true;\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/curve.js"],"names":["Vex","Element","Curve","Position","NEAR_HEAD","NEAR_TOP","PositionString","nearHead","nearTop","constructor","from","to","options","setAttribute","render_options","spacing","thickness","x_shift","y_shift","position","position_end","invert","cps","x","y","Merge","setNotes","RuntimeError","isPartial","renderCurve","params","ctx","context","direction","first_x","first_y","last_x","last_y","cp_spacing","length","beginPath","moveTo","bezierCurveTo","stroke","closePath","fill","draw","checkContext","setRendered","first_note","last_note","stem_direction","metric","end_metric","getPosition","getTieRightX","getStemDirection","getStemExtents","getStave","getTieStartX","getTieLeftX","getTieEndX"],"mappings":"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","sourcesContent":["// VexFlow - Music Engraving for HTML5\n// Copyright Mohit Muthanna 2010\n//\n// This class implements curves (for slurs)\n\nimport { Vex } from './vex';\nimport { Element } from './element';\n\nexport class Curve extends Element {\n  static get Position() {\n    return {\n      NEAR_HEAD: 1,\n      NEAR_TOP: 2,\n    };\n  }\n\n  static get PositionString() {\n    return {\n      nearHead: Curve.Position.NEAR_HEAD,\n      nearTop: Curve.Position.NEAR_TOP,\n    };\n  }\n\n  // from: Start note\n  // to: End note\n  // options:\n  //    cps: List of control points\n  //    x_shift: pixels to shift\n  //    y_shift: pixels to shift\n  constructor(from, to, options) {\n    super();\n    this.setAttribute('type', 'Curve');\n\n    this.render_options = {\n      spacing: 2,\n      thickness: 2,\n      x_shift: 0,\n      y_shift: 10,\n      position: Curve.Position.NEAR_HEAD,\n      position_end: Curve.Position.NEAR_HEAD,\n      invert: false,\n      cps: [{ x: 0, y: 10 }, { x: 0, y: 10 }],\n    };\n\n    Vex.Merge(this.render_options, options);\n    this.setNotes(from, to);\n  }\n\n  setNotes(from, to) {\n    if (!from && !to) {\n      throw new Vex.RuntimeError(\n        'BadArguments', 'Curve needs to have either first_note or last_note set.'\n      );\n    }\n\n    this.from = from;\n    this.to = to;\n    return this;\n  }\n\n  /**\n   * @return {boolean} Returns true if this is a partial bar.\n   */\n  isPartial() {\n    return (!this.from || !this.to);\n  }\n\n  renderCurve(params) {\n    const ctx = this.context;\n    const cps = this.render_options.cps;\n\n    const x_shift = this.render_options.x_shift;\n    const y_shift = this.render_options.y_shift * params.direction;\n\n    const first_x = params.first_x + x_shift;\n    const first_y = params.first_y + y_shift;\n    const last_x = params.last_x - x_shift;\n    const last_y = params.last_y + y_shift;\n    const thickness = this.render_options.thickness;\n\n    const cp_spacing = (last_x - first_x) / (cps.length + 2);\n\n    ctx.beginPath();\n    ctx.moveTo(first_x, first_y);\n    ctx.bezierCurveTo(\n      first_x + cp_spacing + cps[0].x,\n      first_y + (cps[0].y * params.direction),\n      last_x - cp_spacing + cps[1].x,\n      last_y + (cps[1].y * params.direction),\n      last_x,\n      last_y\n    );\n    ctx.bezierCurveTo(\n      last_x - cp_spacing + cps[1].x,\n      last_y + ((cps[1].y + thickness) * params.direction),\n      first_x + cp_spacing + cps[0].x,\n      first_y + ((cps[0].y + thickness) * params.direction),\n      first_x,\n      first_y\n    );\n    ctx.stroke();\n    ctx.closePath();\n    ctx.fill();\n  }\n\n  draw() {\n    this.checkContext();\n    this.setRendered();\n\n    const first_note = this.from;\n    const last_note = this.to;\n    let first_x;\n    let last_x;\n    let first_y;\n    let last_y;\n    let stem_direction;\n\n    let metric = 'baseY';\n    let end_metric = 'baseY';\n\n    function getPosition(position) {\n      return typeof(position) === 'string'\n        ? Curve.PositionString[position]\n        : position;\n    }\n    const position = getPosition(this.render_options.position);\n    const position_end = getPosition(this.render_options.position_end);\n\n    if (position === Curve.Position.NEAR_TOP) {\n      metric = 'topY';\n      end_metric = 'topY';\n    }\n\n    if (position_end === Curve.Position.NEAR_HEAD) {\n      end_metric = 'baseY';\n    } else if (position_end === Curve.Position.NEAR_TOP) {\n      end_metric = 'topY';\n    }\n\n    if (first_note) {\n      first_x = first_note.getTieRightX();\n      stem_direction = first_note.getStemDirection();\n      first_y = first_note.getStemExtents()[metric];\n    } else {\n      first_x = last_note.getStave().getTieStartX();\n      first_y = last_note.getStemExtents()[metric];\n    }\n\n    if (last_note) {\n      last_x = last_note.getTieLeftX();\n      stem_direction = last_note.getStemDirection();\n      last_y = last_note.getStemExtents()[end_metric];\n    } else {\n      last_x = first_note.getStave().getTieEndX();\n      last_y = first_note.getStemExtents()[end_metric];\n    }\n\n    this.renderCurve({\n      first_x,\n      last_x,\n      first_y,\n      last_y,\n      direction: stem_direction * (this.render_options.invert === true ? -1 : 1),\n    });\n    return true;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}