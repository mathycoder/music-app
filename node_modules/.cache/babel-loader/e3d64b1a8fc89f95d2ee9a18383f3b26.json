{"ast":null,"code":"// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n// `TextNote` is a notation element that is positioned in time. Generally\n// meant for objects that sit above/below the staff and inline with each other.\n// Examples of this would be such as dynamics, lyrics, chord changes, etc.\nimport { Vex } from './vex';\nimport { Note } from './note';\nimport { Glyph } from './glyph';\nexport class TextNote extends Note {\n  static get Justification() {\n    return {\n      LEFT: 1,\n      CENTER: 2,\n      RIGHT: 3\n    };\n  } // Glyph data\n\n\n  static get GLYPHS() {\n    return {\n      'segno': {\n        code: 'segno'\n      },\n      'tr': {\n        code: 'ornamentTrill'\n      },\n      'mordent': {\n        code: 'ornamentMordent'\n      },\n      'mordent_upper': {\n        code: 'ornamentShortTrill'\n      },\n      'mordent_lower': {\n        code: 'ornamentMordent'\n      },\n      'f': {\n        code: 'dynamicForte'\n      },\n      'p': {\n        code: 'dynamicPiano'\n      },\n      'm': {\n        code: 'dynamicMezzo'\n      },\n      's': {\n        code: 'dynamicSforzando'\n      },\n      'z': {\n        code: 'dynamicZ'\n      },\n      'coda': {\n        code: 'coda'\n      },\n      'pedal_open': {\n        code: 'keyboardPedalPed'\n      },\n      'pedal_close': {\n        code: 'keyboardPedalUp'\n      },\n      'caesura_straight': {\n        code: 'caesura'\n      },\n      'caesura_curved': {\n        code: 'caesuraCurved'\n      },\n      'breath': {\n        code: 'breathMarkComma'\n      },\n      'tick': {\n        code: 'breathMarkTick'\n      },\n      'turn': {\n        code: 'ornamentTurn'\n      },\n      'turn_inverted': {\n        code: 'ornamentTurnSlash'\n      }\n    };\n  }\n\n  constructor(options) {\n    super(options);\n    this.setAttribute('type', 'TextNote'); // Note properties\n\n    this.text = options.text;\n    this.superscript = options.superscript;\n    this.subscript = options.subscript;\n    this.glyph = null;\n    this.font = {\n      family: 'Arial',\n      size: 12,\n      weight: '',\n      ...options.font\n    }; // Determine and set initial note width. Note that the text width is\n    // an approximation and isn't very accurate. The only way to accurately\n    // measure the length of text is with `canvasmeasureText()`\n\n    if (options.glyph) {\n      const struct = TextNote.GLYPHS[options.glyph];\n      if (!struct) throw new Vex.RERR('Invalid glyph type: ' + options.glyph);\n      this.glyph = new Glyph(struct.code, 40, {\n        category: 'textNote'\n      });\n      this.setWidth(this.glyph.getMetrics().width);\n    }\n\n    this.line = options.line || 0;\n    this.smooth = options.smooth || false;\n    this.ignore_ticks = options.ignore_ticks || false;\n    this.justification = TextNote.Justification.LEFT;\n  } // Set the horizontal justification of the TextNote\n\n\n  setJustification(just) {\n    this.justification = just;\n    return this;\n  } // Set the Stave line on which the note should be placed\n\n\n  setLine(line) {\n    this.line = line;\n    return this;\n  } // Pre-render formatting\n\n\n  preFormat() {\n    this.checkContext();\n    if (this.preFormatted) return;\n\n    if (this.smooth) {\n      this.setWidth(0);\n    } else {\n      if (this.glyph) {// Width already set.\n      } else {\n        this.context.setFont(this.font.family, this.font.size, this.font.weight);\n        this.setWidth(this.context.measureText(this.text).width);\n      }\n    }\n\n    if (this.justification === TextNote.Justification.CENTER) {\n      this.leftDisplacedHeadPx = this.width / 2;\n    } else if (this.justification === TextNote.Justification.RIGHT) {\n      this.leftDisplacedHeadPx = this.width;\n    } // We reposition to the center of the note head\n\n\n    this.rightDisplacedHeadPx = this.tickContext.getMetrics().glyphPx / 2;\n    this.setPreFormatted(true);\n  } // Renders the TextNote\n\n\n  draw() {\n    this.checkContext();\n\n    if (!this.stave) {\n      throw new Vex.RERR('NoStave', \"Can't draw without a stave.\");\n    }\n\n    this.setRendered();\n    const ctx = this.context; // Reposition to center of note head\n\n    let x = this.getAbsoluteX() + this.tickContext.getMetrics().glyphPx / 2; // Align based on tick-context width.\n\n    const width = this.getWidth();\n\n    if (this.justification === TextNote.Justification.CENTER) {\n      x -= width / 2;\n    } else if (this.justification === TextNote.Justification.RIGHT) {\n      x -= width;\n    }\n\n    let y;\n\n    if (this.glyph) {\n      y = this.stave.getYForLine(this.line + -3);\n      this.glyph.render(this.context, x, y);\n    } else {\n      y = this.stave.getYForLine(this.line + -3);\n      this.applyStyle(ctx);\n      ctx.setFont(this.font.family, this.font.size, this.font.weight);\n      ctx.fillText(this.text, x, y);\n      const height = ctx.measureText(this.text).height; // Write superscript\n\n      if (this.superscript) {\n        ctx.setFont(this.font.family, this.font.size / 1.3, this.font.weight);\n        ctx.fillText(this.superscript, x + width + 2, y - height / 2.2);\n      } // Write subscript\n\n\n      if (this.subscript) {\n        ctx.setFont(this.font.family, this.font.size / 1.3, this.font.weight);\n        ctx.fillText(this.subscript, x + width + 2, y + height / 2.2 - 1);\n      }\n\n      this.restoreStyle(ctx);\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/textnote.js"],"names":["Vex","Note","Glyph","TextNote","Justification","LEFT","CENTER","RIGHT","GLYPHS","code","constructor","options","setAttribute","text","superscript","subscript","glyph","font","family","size","weight","struct","RERR","category","setWidth","getMetrics","width","line","smooth","ignore_ticks","justification","setJustification","just","setLine","preFormat","checkContext","preFormatted","context","setFont","measureText","leftDisplacedHeadPx","rightDisplacedHeadPx","tickContext","glyphPx","setPreFormatted","draw","stave","setRendered","ctx","x","getAbsoluteX","getWidth","y","getYForLine","render","applyStyle","fillText","height","restoreStyle"],"mappings":"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","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n// `TextNote` is a notation element that is positioned in time. Generally\n// meant for objects that sit above/below the staff and inline with each other.\n// Examples of this would be such as dynamics, lyrics, chord changes, etc.\n\nimport { Vex } from './vex';\nimport { Note } from './note';\nimport { Glyph } from './glyph';\n\nexport class TextNote extends Note {\n  static get Justification() {\n    return {\n      LEFT: 1,\n      CENTER: 2,\n      RIGHT: 3,\n    };\n  }\n\n  // Glyph data\n  static get GLYPHS() {\n    return {\n      'segno': {\n        code: 'segno',\n      },\n      'tr': {\n        code: 'ornamentTrill',\n      },\n      'mordent': {\n        code: 'ornamentMordent',\n      },\n      'mordent_upper': {\n        code: 'ornamentShortTrill',\n      },\n      'mordent_lower': {\n        code: 'ornamentMordent',\n      },\n      'f': {\n        code: 'dynamicForte',\n      },\n      'p': {\n        code: 'dynamicPiano',\n      },\n      'm': {\n        code: 'dynamicMezzo',\n      },\n      's': {\n        code: 'dynamicSforzando',\n      },\n      'z': {\n        code: 'dynamicZ',\n      },\n      'coda': {\n        code: 'coda',\n      },\n      'pedal_open': {\n        code: 'keyboardPedalPed',\n      },\n      'pedal_close': {\n        code: 'keyboardPedalUp',\n      },\n      'caesura_straight': {\n        code: 'caesura',\n      },\n      'caesura_curved': {\n        code: 'caesuraCurved',\n      },\n      'breath': {\n        code: 'breathMarkComma',\n      },\n      'tick': {\n        code: 'breathMarkTick',\n      },\n      'turn': {\n        code: 'ornamentTurn',\n      },\n      'turn_inverted': {\n        code: 'ornamentTurnSlash',\n      },\n    };\n  }\n\n  constructor(options) {\n    super(options);\n    this.setAttribute('type', 'TextNote');\n\n    // Note properties\n    this.text = options.text;\n    this.superscript = options.superscript;\n    this.subscript = options.subscript;\n    this.glyph = null;\n    this.font = {\n      family: 'Arial',\n      size: 12,\n      weight: '',\n      ...options.font\n    };\n\n    // Determine and set initial note width. Note that the text width is\n    // an approximation and isn't very accurate. The only way to accurately\n    // measure the length of text is with `canvasmeasureText()`\n    if (options.glyph) {\n      const struct = TextNote.GLYPHS[options.glyph];\n      if (!struct) throw new Vex.RERR('Invalid glyph type: ' + options.glyph);\n\n      this.glyph = new Glyph(struct.code, 40, { category: 'textNote' });\n      this.setWidth(this.glyph.getMetrics().width);\n    }\n\n    this.line = options.line || 0;\n    this.smooth = options.smooth || false;\n    this.ignore_ticks = options.ignore_ticks || false;\n    this.justification = TextNote.Justification.LEFT;\n  }\n\n  // Set the horizontal justification of the TextNote\n  setJustification(just) {\n    this.justification = just;\n    return this;\n  }\n\n  // Set the Stave line on which the note should be placed\n  setLine(line) {\n    this.line = line;\n    return this;\n  }\n\n  // Pre-render formatting\n  preFormat() {\n    this.checkContext();\n\n    if (this.preFormatted) return;\n\n    if (this.smooth) {\n      this.setWidth(0);\n    } else {\n      if (this.glyph) {\n        // Width already set.\n      } else {\n        this.context.setFont(this.font.family, this.font.size, this.font.weight);\n        this.setWidth(this.context.measureText(this.text).width);\n      }\n    }\n\n    if (this.justification === TextNote.Justification.CENTER) {\n      this.leftDisplacedHeadPx = this.width / 2;\n    } else if (this.justification === TextNote.Justification.RIGHT) {\n      this.leftDisplacedHeadPx = this.width;\n    }\n\n    // We reposition to the center of the note head\n    this.rightDisplacedHeadPx = this.tickContext.getMetrics().glyphPx / 2;\n    this.setPreFormatted(true);\n  }\n\n  // Renders the TextNote\n  draw() {\n    this.checkContext();\n\n    if (!this.stave) {\n      throw new Vex.RERR('NoStave', \"Can't draw without a stave.\");\n    }\n\n    this.setRendered();\n    const ctx = this.context;\n\n    // Reposition to center of note head\n    let x = this.getAbsoluteX() + (this.tickContext.getMetrics().glyphPx / 2);\n\n    // Align based on tick-context width.\n    const width = this.getWidth();\n\n    if (this.justification === TextNote.Justification.CENTER) {\n      x -= width / 2;\n    } else if (this.justification === TextNote.Justification.RIGHT) {\n      x -= width;\n    }\n\n    let y;\n    if (this.glyph) {\n      y = this.stave.getYForLine(this.line + -3);\n      this.glyph.render(this.context, x, y);\n    } else {\n      y = this.stave.getYForLine(this.line + -3);\n      this.applyStyle(ctx);\n      ctx.setFont(this.font.family, this.font.size, this.font.weight);\n      ctx.fillText(this.text, x, y);\n\n      const height = ctx.measureText(this.text).height;\n\n      // Write superscript\n      if (this.superscript) {\n        ctx.setFont(this.font.family, this.font.size / 1.3, this.font.weight);\n        ctx.fillText(this.superscript, x + width + 2, y - (height / 2.2));\n      }\n\n      // Write subscript\n      if (this.subscript) {\n        ctx.setFont(this.font.family, this.font.size / 1.3, this.font.weight);\n        ctx.fillText(this.subscript, x + width + 2, y + (height / 2.2) - 1);\n      }\n\n      this.restoreStyle(ctx);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}