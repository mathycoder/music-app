{"ast":null,"code":"// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// This class implements a musical system, which is a collection of staves,\n// each which can have one or more voices. All voices across all staves in\n// the system are formatted together.\nimport { Element } from './element';\nimport { Factory } from './factory';\nimport { Formatter } from './formatter';\nimport { Note } from './note';\nexport class System extends Element {\n  constructor(params = {}) {\n    super();\n    this.setAttribute('type', 'System');\n    this.setOptions(params);\n    this.parts = [];\n  }\n\n  setOptions(options = {}) {\n    this.options = {\n      x: 10,\n      y: 10,\n      width: 500,\n      connector: null,\n      spaceBetweenStaves: 12,\n      // stave spaces\n      factory: null,\n      noJustification: false,\n      debugFormatter: false,\n      formatIterations: 0,\n      // number of formatter tuning steps\n      noPadding: false,\n      ...options,\n      details: {\n        alpha: 0.5,\n        // formatter tuner learning/shifting rate\n        ...options.details\n      }\n    };\n    this.factory = this.options.factory || new Factory({\n      renderer: {\n        el: null\n      }\n    });\n  }\n\n  setContext(context) {\n    super.setContext(context);\n    this.factory.setContext(context);\n    return this;\n  }\n\n  addConnector(type = 'double') {\n    this.connector = this.factory.StaveConnector({\n      top_stave: this.parts[0].stave,\n      bottom_stave: this.parts[this.parts.length - 1].stave,\n      type\n    });\n    return this.connector;\n  }\n\n  addStave(params) {\n    params = {\n      stave: null,\n      voices: [],\n      spaceAbove: 0,\n      // stave spaces\n      spaceBelow: 0,\n      // stave spaces\n      debugNoteMetrics: false,\n      ...params,\n      options: {\n        left_bar: false,\n        ...params.options\n      }\n    };\n\n    if (!params.stave) {\n      params.stave = this.factory.Stave({\n        x: this.options.x,\n        y: this.options.y,\n        width: this.options.width,\n        options: params.options\n      });\n    }\n\n    params.voices.forEach(voice => voice.setContext(this.context).setStave(params.stave).getTickables().forEach(tickable => tickable.setStave(params.stave)));\n    this.parts.push(params);\n    return params.stave;\n  }\n\n  format() {\n    const formatter = new Formatter({ ...this.options.details\n    });\n    this.formatter = formatter;\n    let y = this.options.y;\n    let startX = 0;\n    let allVoices = [];\n    const debugNoteMetricsYs = []; // Join the voices for each stave.\n\n    this.parts.forEach(part => {\n      y = y + part.stave.space(part.spaceAbove);\n      part.stave.setY(y);\n      formatter.joinVoices(part.voices);\n      y = y + part.stave.space(part.spaceBelow);\n      y = y + part.stave.space(this.options.spaceBetweenStaves);\n\n      if (part.debugNoteMetrics) {\n        debugNoteMetricsYs.push({\n          y,\n          voice: part.voices[0]\n        });\n        y += 15;\n      }\n\n      allVoices = allVoices.concat(part.voices);\n      startX = Math.max(startX, part.stave.getNoteStartX());\n    }); // Update the start position of all staves.\n\n    this.parts.forEach(part => part.stave.setNoteStartX(startX));\n    const justifyWidth = this.options.noPadding ? this.options.width - this.options.x : this.options.width - (startX - this.options.x) - this.musicFont.lookupMetric('stave.padding');\n    formatter.format(allVoices, this.options.noJustification ? 0 : justifyWidth);\n\n    for (let i = 0; i < this.options.formatIterations; i++) {\n      formatter.tune({\n        alpha: this.options.details.alpha\n      });\n    }\n\n    this.startX = startX;\n    this.debugNoteMetricsYs = debugNoteMetricsYs;\n    this.lastY = y;\n  }\n\n  draw() {\n    // Render debugging information, if requested.\n    const ctx = this.checkContext();\n    this.setRendered();\n\n    if (this.options.debugFormatter) {\n      Formatter.plotDebugging(ctx, this.formatter, this.startX, this.options.y, this.lastY);\n    }\n\n    this.debugNoteMetricsYs.forEach(d => {\n      d.voice.getTickables().forEach(note => Note.plotMetrics(ctx, note, d.y));\n    });\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/system.js"],"names":["Element","Factory","Formatter","Note","System","constructor","params","setAttribute","setOptions","parts","options","x","y","width","connector","spaceBetweenStaves","factory","noJustification","debugFormatter","formatIterations","noPadding","details","alpha","renderer","el","setContext","context","addConnector","type","StaveConnector","top_stave","stave","bottom_stave","length","addStave","voices","spaceAbove","spaceBelow","debugNoteMetrics","left_bar","Stave","forEach","voice","setStave","getTickables","tickable","push","format","formatter","startX","allVoices","debugNoteMetricsYs","part","space","setY","joinVoices","concat","Math","max","getNoteStartX","setNoteStartX","justifyWidth","musicFont","lookupMetric","i","tune","lastY","draw","ctx","checkContext","setRendered","plotDebugging","d","note","plotMetrics"],"mappings":"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","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// This class implements a musical system, which is a collection of staves,\n// each which can have one or more voices. All voices across all staves in\n// the system are formatted together.\n\nimport { Element } from './element';\nimport { Factory } from './factory';\nimport { Formatter } from './formatter';\nimport { Note } from './note';\n\nexport class System extends Element {\n  constructor(params = {}) {\n    super();\n    this.setAttribute('type', 'System');\n    this.setOptions(params);\n    this.parts = [];\n  }\n\n  setOptions(options = {}) {\n    this.options = {\n      x: 10,\n      y: 10,\n      width: 500,\n      connector: null,\n      spaceBetweenStaves: 12, // stave spaces\n      factory: null,\n      noJustification: false,\n      debugFormatter: false,\n      formatIterations: 0,   // number of formatter tuning steps\n      noPadding: false,\n      ...options,\n      details: {\n        alpha: 0.5,          // formatter tuner learning/shifting rate\n        ...options.details,\n      },\n    };\n\n    this.factory = this.options.factory || new Factory({ renderer: { el: null } });\n  }\n\n  setContext(context) {\n    super.setContext(context);\n    this.factory.setContext(context);\n    return this;\n  }\n\n  addConnector(type = 'double') {\n    this.connector = this.factory.StaveConnector({\n      top_stave: this.parts[0].stave,\n      bottom_stave: this.parts[this.parts.length - 1].stave,\n      type,\n    });\n    return this.connector;\n  }\n\n  addStave(params) {\n    params = {\n      stave: null,\n      voices: [],\n      spaceAbove: 0, // stave spaces\n      spaceBelow: 0, // stave spaces\n      debugNoteMetrics: false,\n      ...params,\n      options: {\n        left_bar: false,\n        ...params.options,\n      },\n    };\n\n    if (!params.stave) {\n      params.stave = this.factory.Stave({\n        x: this.options.x,\n        y: this.options.y,\n        width: this.options.width,\n        options: params.options,\n      });\n    }\n\n    params.voices.forEach(voice =>\n      voice\n        .setContext(this.context)\n        .setStave(params.stave)\n        .getTickables()\n        .forEach(tickable => tickable.setStave(params.stave))\n    );\n\n    this.parts.push(params);\n    return params.stave;\n  }\n\n  format() {\n    const formatter = new Formatter({ ...this.options.details });\n    this.formatter = formatter;\n\n    let y = this.options.y;\n    let startX = 0;\n    let allVoices = [];\n    const debugNoteMetricsYs = [];\n\n    // Join the voices for each stave.\n    this.parts.forEach(part => {\n      y = y + part.stave.space(part.spaceAbove);\n      part.stave.setY(y);\n      formatter.joinVoices(part.voices);\n      y = y + part.stave.space(part.spaceBelow);\n      y = y + part.stave.space(this.options.spaceBetweenStaves);\n      if (part.debugNoteMetrics) {\n        debugNoteMetricsYs.push({ y, voice: part.voices[0] });\n        y += 15;\n      }\n      allVoices = allVoices.concat(part.voices);\n\n      startX = Math.max(startX, part.stave.getNoteStartX());\n    });\n\n    // Update the start position of all staves.\n    this.parts.forEach(part => part.stave.setNoteStartX(startX));\n    const justifyWidth = this.options.noPadding ?\n      this.options.width - this.options.x :\n      this.options.width - (startX - this.options.x) - this.musicFont.lookupMetric('stave.padding');\n\n    formatter.format(allVoices, this.options.noJustification ? 0 : justifyWidth);\n\n    for (let i = 0; i < this.options.formatIterations; i++) {\n      formatter.tune({ alpha: this.options.details.alpha });\n    }\n\n    this.startX = startX;\n    this.debugNoteMetricsYs = debugNoteMetricsYs;\n    this.lastY = y;\n  }\n\n  draw() {\n    // Render debugging information, if requested.\n    const ctx = this.checkContext();\n    this.setRendered();\n\n    if (this.options.debugFormatter) {\n      Formatter.plotDebugging(ctx, this.formatter, this.startX, this.options.y, this.lastY);\n    }\n\n    this.debugNoteMetricsYs.forEach(d => {\n      d.voice.getTickables().forEach(note => Note.plotMetrics(ctx, note, d.y));\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}