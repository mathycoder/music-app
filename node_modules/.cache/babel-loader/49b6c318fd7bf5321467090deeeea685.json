{"ast":null,"code":"// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n// Author: Cyril Silverman\n//\n// ## Description\n//\n// This file implements ornaments as modifiers that can be\n// attached to notes. The complete list of ornaments is available in\n// `tables.js` under `Vex.Flow.ornamentCodes`.\n//\n// See `tests/ornament_tests.js` for usage examples.\nimport { Vex } from './vex';\nimport { Flow } from './tables';\nimport { Modifier } from './modifier';\nimport { TickContext } from './tickcontext';\nimport { StaveNote } from './stavenote';\nimport { Glyph } from './glyph'; // To enable logging for this class. Set `Vex.Flow.Ornament.DEBUG` to `true`.\n\nfunction L(...args) {\n  if (Ornament.DEBUG) Vex.L('Vex.Flow.Ornament', args);\n}\n\nexport class Ornament extends Modifier {\n  static get CATEGORY() {\n    return 'ornaments';\n  } // ## Static Methods\n  // Arrange ornaments inside `ModifierContext`\n\n\n  static format(ornaments, state) {\n    if (!ornaments || ornaments.length === 0) return false;\n    let width = 0;\n\n    for (let i = 0; i < ornaments.length; ++i) {\n      const ornament = ornaments[i];\n      const increment = 2;\n      width = Math.max(ornament.getWidth(), width);\n\n      if (ornament.getPosition() === Modifier.Position.ABOVE) {\n        ornament.setTextLine(state.top_text_line);\n        state.top_text_line += increment;\n      } else {\n        ornament.setTextLine(state.text_line);\n        state.text_line += increment;\n      }\n    }\n\n    state.left_shift += width / 2;\n    state.right_shift += width / 2;\n    return true;\n  } // Create a new ornament of type `type`, which is an entry in\n  // `Vex.Flow.ornamentCodes` in `tables.js`.\n\n\n  constructor(type) {\n    super();\n    this.setAttribute('type', 'Ornament');\n    this.note = null;\n    this.index = null;\n    this.type = type;\n    this.position = Modifier.Position.ABOVE;\n    this.delayed = false;\n    this.accidentalUpper = null;\n    this.accidentalLower = null;\n    this.render_options = {\n      font_scale: 38,\n      accidentalLowerPadding: 3,\n      accidentalUpperPadding: 3\n    };\n    this.ornament = Flow.ornamentCodes(this.type);\n\n    if (!this.ornament) {\n      throw new Vex.RERR('ArgumentError', `Ornament not found: '${this.type}'`);\n    }\n\n    this.glyph = new Glyph(this.ornament.code, this.render_options.font_scale, {\n      category: `ornament.${this.ornament.code}`\n    });\n    this.glyph.setOrigin(0.5, 1.0); // FIXME: SMuFL won't require a vertical origin shift\n  }\n\n  getCategory() {\n    return Ornament.CATEGORY;\n  } // Set whether the ornament is to be delayed\n\n\n  setDelayed(delayed) {\n    this.delayed = delayed;\n    return this;\n  } // Set the upper accidental for the ornament\n\n\n  setUpperAccidental(accid) {\n    const scale = this.render_options.font_scale / 1.3;\n    this.accidentalUpper = new Glyph(Flow.accidentalCodes(accid).code, scale);\n    this.accidentalUpper.setOrigin(0.5, 1.0);\n    return this;\n  } // Set the lower accidental for the ornament\n\n\n  setLowerAccidental(accid) {\n    const scale = this.render_options.font_scale / 1.3;\n    this.accidentalLower = new Glyph(Flow.accidentalCodes(accid).code, scale);\n    this.accidentalLower.setOrigin(0.5, 1.0);\n    return this;\n  } // Render ornament in position next to note.\n\n\n  draw() {\n    this.checkContext();\n\n    if (!this.note || this.index == null) {\n      throw new Vex.RERR('NoAttachedNote', \"Can't draw Ornament without a note and index.\");\n    }\n\n    this.setRendered();\n    const ctx = this.context;\n    const stemDir = this.note.getStemDirection();\n    const stave = this.note.getStave(); // Get stem extents\n\n    const stemExtents = this.note.getStem().getExtents();\n    let y = stemDir === StaveNote.STEM_DOWN ? stemExtents.baseY : stemExtents.topY; // TabNotes don't have stems attached to them. Tab stems are rendered\n    // outside the stave.\n\n    if (this.note.getCategory() === 'tabnotes') {\n      if (this.note.hasStem()) {\n        if (stemDir === StaveNote.STEM_DOWN) {\n          y = stave.getYForTopText(this.text_line);\n        }\n      } else {\n        // Without a stem\n        y = stave.getYForTopText(this.text_line);\n      }\n    }\n\n    const isPlacedOnNoteheadSide = stemDir === StaveNote.STEM_DOWN;\n    const spacing = stave.getSpacingBetweenLines();\n    let lineSpacing = 1; // Beamed stems are longer than quarter note stems, adjust accordingly\n\n    if (!isPlacedOnNoteheadSide && this.note.beam) {\n      lineSpacing += 0.5;\n    }\n\n    const totalSpacing = spacing * (this.text_line + lineSpacing);\n    const glyphYBetweenLines = y - totalSpacing; // Get initial coordinates for the modifier position\n\n    const start = this.note.getModifierStartXY(this.position, this.index);\n    let glyphX = start.x;\n    let glyphY = Math.min(stave.getYForTopText(this.text_line), glyphYBetweenLines);\n    glyphY += this.y_shift; // Ajdust x position if ornament is delayed\n\n    if (this.delayed) {\n      let delayXShift = 0;\n\n      if (this.delayXShift !== undefined) {\n        delayXShift = this.delayXShift;\n      } else {\n        delayXShift += this.glyph.getMetrics().width / 2;\n        const nextContext = TickContext.getNextContext(this.note.getTickContext());\n\n        if (nextContext) {\n          delayXShift += (nextContext.getX() - glyphX) * 0.5;\n        } else {\n          delayXShift += (stave.x + stave.width - glyphX) * 0.5;\n        }\n\n        this.delayXShift = delayXShift;\n      }\n\n      glyphX += delayXShift;\n    }\n\n    L('Rendering ornament: ', this.ornament, glyphX, glyphY);\n\n    if (this.accidentalLower) {\n      this.accidentalLower.render(ctx, glyphX, glyphY);\n      glyphY -= this.accidentalLower.getMetrics().height;\n      glyphY -= this.render_options.accidentalLowerPadding;\n    }\n\n    this.glyph.render(ctx, glyphX, glyphY);\n    glyphY -= this.glyph.getMetrics().height;\n\n    if (this.accidentalUpper) {\n      glyphY -= this.render_options.accidentalUpperPadding;\n      this.accidentalUpper.render(ctx, glyphX, glyphY);\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/ornament.js"],"names":["Vex","Flow","Modifier","TickContext","StaveNote","Glyph","L","args","Ornament","DEBUG","CATEGORY","format","ornaments","state","length","width","i","ornament","increment","Math","max","getWidth","getPosition","Position","ABOVE","setTextLine","top_text_line","text_line","left_shift","right_shift","constructor","type","setAttribute","note","index","position","delayed","accidentalUpper","accidentalLower","render_options","font_scale","accidentalLowerPadding","accidentalUpperPadding","ornamentCodes","RERR","glyph","code","category","setOrigin","getCategory","setDelayed","setUpperAccidental","accid","scale","accidentalCodes","setLowerAccidental","draw","checkContext","setRendered","ctx","context","stemDir","getStemDirection","stave","getStave","stemExtents","getStem","getExtents","y","STEM_DOWN","baseY","topY","hasStem","getYForTopText","isPlacedOnNoteheadSide","spacing","getSpacingBetweenLines","lineSpacing","beam","totalSpacing","glyphYBetweenLines","start","getModifierStartXY","glyphX","x","glyphY","min","y_shift","delayXShift","undefined","getMetrics","nextContext","getNextContext","getTickContext","getX","render","height"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,SAASA,GAAT,QAAoB,OAApB;AACA,SAASC,IAAT,QAAqB,UAArB;AACA,SAASC,QAAT,QAAyB,YAAzB;AACA,SAASC,WAAT,QAA4B,eAA5B;AACA,SAASC,SAAT,QAA0B,aAA1B;AACA,SAASC,KAAT,QAAsB,SAAtB,C,CAEA;;AACA,SAASC,CAAT,CAAW,GAAGC,IAAd,EAAoB;AAAE,MAAIC,QAAQ,CAACC,KAAb,EAAoBT,GAAG,CAACM,CAAJ,CAAM,mBAAN,EAA2BC,IAA3B;AAAmC;;AAE7E,OAAO,MAAMC,QAAN,SAAuBN,QAAvB,CAAgC;AACrC,aAAWQ,QAAX,GAAsB;AAAE,WAAO,WAAP;AAAqB,GADR,CAGrC;AACA;;;AACA,SAAOC,MAAP,CAAcC,SAAd,EAAyBC,KAAzB,EAAgC;AAC9B,QAAI,CAACD,SAAD,IAAcA,SAAS,CAACE,MAAV,KAAqB,CAAvC,EAA0C,OAAO,KAAP;AAE1C,QAAIC,KAAK,GAAG,CAAZ;;AACA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGJ,SAAS,CAACE,MAA9B,EAAsC,EAAEE,CAAxC,EAA2C;AACzC,YAAMC,QAAQ,GAAGL,SAAS,CAACI,CAAD,CAA1B;AACA,YAAME,SAAS,GAAG,CAAlB;AAEAH,MAAAA,KAAK,GAAGI,IAAI,CAACC,GAAL,CAASH,QAAQ,CAACI,QAAT,EAAT,EAA8BN,KAA9B,CAAR;;AAEA,UAAIE,QAAQ,CAACK,WAAT,OAA2BpB,QAAQ,CAACqB,QAAT,CAAkBC,KAAjD,EAAwD;AACtDP,QAAAA,QAAQ,CAACQ,WAAT,CAAqBZ,KAAK,CAACa,aAA3B;AACAb,QAAAA,KAAK,CAACa,aAAN,IAAuBR,SAAvB;AACD,OAHD,MAGO;AACLD,QAAAA,QAAQ,CAACQ,WAAT,CAAqBZ,KAAK,CAACc,SAA3B;AACAd,QAAAA,KAAK,CAACc,SAAN,IAAmBT,SAAnB;AACD;AACF;;AAEDL,IAAAA,KAAK,CAACe,UAAN,IAAoBb,KAAK,GAAG,CAA5B;AACAF,IAAAA,KAAK,CAACgB,WAAN,IAAqBd,KAAK,GAAG,CAA7B;AACA,WAAO,IAAP;AACD,GA3BoC,CA6BrC;AACA;;;AACAe,EAAAA,WAAW,CAACC,IAAD,EAAO;AAChB;AACA,SAAKC,YAAL,CAAkB,MAAlB,EAA0B,UAA1B;AAEA,SAAKC,IAAL,GAAY,IAAZ;AACA,SAAKC,KAAL,GAAa,IAAb;AACA,SAAKH,IAAL,GAAYA,IAAZ;AACA,SAAKI,QAAL,GAAgBjC,QAAQ,CAACqB,QAAT,CAAkBC,KAAlC;AACA,SAAKY,OAAL,GAAe,KAAf;AAEA,SAAKC,eAAL,GAAuB,IAAvB;AACA,SAAKC,eAAL,GAAuB,IAAvB;AAEA,SAAKC,cAAL,GAAsB;AACpBC,MAAAA,UAAU,EAAE,EADQ;AAEpBC,MAAAA,sBAAsB,EAAE,CAFJ;AAGpBC,MAAAA,sBAAsB,EAAE;AAHJ,KAAtB;AAMA,SAAKzB,QAAL,GAAgBhB,IAAI,CAAC0C,aAAL,CAAmB,KAAKZ,IAAxB,CAAhB;;AACA,QAAI,CAAC,KAAKd,QAAV,EAAoB;AAClB,YAAM,IAAIjB,GAAG,CAAC4C,IAAR,CAAa,eAAb,EAA+B,wBAAuB,KAAKb,IAAK,GAAhE,CAAN;AACD;;AAED,SAAKc,KAAL,GAAa,IAAIxC,KAAJ,CAAU,KAAKY,QAAL,CAAc6B,IAAxB,EAA8B,KAAKP,cAAL,CAAoBC,UAAlD,EAA8D;AAAEO,MAAAA,QAAQ,EAAG,YAAW,KAAK9B,QAAL,CAAc6B,IAAK;AAA3C,KAA9D,CAAb;AACA,SAAKD,KAAL,CAAWG,SAAX,CAAqB,GAArB,EAA0B,GAA1B,EAzBgB,CAyBgB;AACjC;;AAEDC,EAAAA,WAAW,GAAG;AAAE,WAAOzC,QAAQ,CAACE,QAAhB;AAA2B,GA3DN,CA6DrC;;;AACAwC,EAAAA,UAAU,CAACd,OAAD,EAAU;AAAE,SAAKA,OAAL,GAAeA,OAAf;AAAwB,WAAO,IAAP;AAAc,GA9DvB,CAgErC;;;AACAe,EAAAA,kBAAkB,CAACC,KAAD,EAAQ;AACxB,UAAMC,KAAK,GAAG,KAAKd,cAAL,CAAoBC,UAApB,GAAiC,GAA/C;AACA,SAAKH,eAAL,GAAuB,IAAIhC,KAAJ,CAAUJ,IAAI,CAACqD,eAAL,CAAqBF,KAArB,EAA4BN,IAAtC,EAA4CO,KAA5C,CAAvB;AACA,SAAKhB,eAAL,CAAqBW,SAArB,CAA+B,GAA/B,EAAoC,GAApC;AACA,WAAO,IAAP;AACD,GAtEoC,CAwErC;;;AACAO,EAAAA,kBAAkB,CAACH,KAAD,EAAQ;AACxB,UAAMC,KAAK,GAAG,KAAKd,cAAL,CAAoBC,UAApB,GAAiC,GAA/C;AACA,SAAKF,eAAL,GAAuB,IAAIjC,KAAJ,CAAUJ,IAAI,CAACqD,eAAL,CAAqBF,KAArB,EAA4BN,IAAtC,EAA4CO,KAA5C,CAAvB;AACA,SAAKf,eAAL,CAAqBU,SAArB,CAA+B,GAA/B,EAAoC,GAApC;AACA,WAAO,IAAP;AACD,GA9EoC,CAgFrC;;;AACAQ,EAAAA,IAAI,GAAG;AACL,SAAKC,YAAL;;AAEA,QAAI,CAAC,KAAKxB,IAAN,IAAc,KAAKC,KAAL,IAAc,IAAhC,EAAsC;AACpC,YAAM,IAAIlC,GAAG,CAAC4C,IAAR,CAAa,gBAAb,EAA+B,+CAA/B,CAAN;AACD;;AAED,SAAKc,WAAL;AAEA,UAAMC,GAAG,GAAG,KAAKC,OAAjB;AACA,UAAMC,OAAO,GAAG,KAAK5B,IAAL,CAAU6B,gBAAV,EAAhB;AACA,UAAMC,KAAK,GAAG,KAAK9B,IAAL,CAAU+B,QAAV,EAAd,CAXK,CAaL;;AACA,UAAMC,WAAW,GAAG,KAAKhC,IAAL,CAAUiC,OAAV,GAAoBC,UAApB,EAApB;AACA,QAAIC,CAAC,GAAGP,OAAO,KAAKzD,SAAS,CAACiE,SAAtB,GAAkCJ,WAAW,CAACK,KAA9C,GAAsDL,WAAW,CAACM,IAA1E,CAfK,CAiBL;AACA;;AACA,QAAI,KAAKtC,IAAL,CAAUgB,WAAV,OAA4B,UAAhC,EAA4C;AAC1C,UAAI,KAAKhB,IAAL,CAAUuC,OAAV,EAAJ,EAAyB;AACvB,YAAIX,OAAO,KAAKzD,SAAS,CAACiE,SAA1B,EAAqC;AACnCD,UAAAA,CAAC,GAAGL,KAAK,CAACU,cAAN,CAAqB,KAAK9C,SAA1B,CAAJ;AACD;AACF,OAJD,MAIO;AAAE;AACPyC,QAAAA,CAAC,GAAGL,KAAK,CAACU,cAAN,CAAqB,KAAK9C,SAA1B,CAAJ;AACD;AACF;;AAED,UAAM+C,sBAAsB,GAAGb,OAAO,KAAKzD,SAAS,CAACiE,SAArD;AACA,UAAMM,OAAO,GAAGZ,KAAK,CAACa,sBAAN,EAAhB;AACA,QAAIC,WAAW,GAAG,CAAlB,CA/BK,CAiCL;;AACA,QAAI,CAACH,sBAAD,IAA2B,KAAKzC,IAAL,CAAU6C,IAAzC,EAA+C;AAC7CD,MAAAA,WAAW,IAAI,GAAf;AACD;;AAED,UAAME,YAAY,GAAGJ,OAAO,IAAI,KAAKhD,SAAL,GAAiBkD,WAArB,CAA5B;AACA,UAAMG,kBAAkB,GAAGZ,CAAC,GAAGW,YAA/B,CAvCK,CAyCL;;AACA,UAAME,KAAK,GAAG,KAAKhD,IAAL,CAAUiD,kBAAV,CAA6B,KAAK/C,QAAlC,EAA4C,KAAKD,KAAjD,CAAd;AACA,QAAIiD,MAAM,GAAGF,KAAK,CAACG,CAAnB;AACA,QAAIC,MAAM,GAAGlE,IAAI,CAACmE,GAAL,CAASvB,KAAK,CAACU,cAAN,CAAqB,KAAK9C,SAA1B,CAAT,EAA+CqD,kBAA/C,CAAb;AACAK,IAAAA,MAAM,IAAI,KAAKE,OAAf,CA7CK,CA+CL;;AACA,QAAI,KAAKnD,OAAT,EAAkB;AAChB,UAAIoD,WAAW,GAAG,CAAlB;;AACA,UAAI,KAAKA,WAAL,KAAqBC,SAAzB,EAAoC;AAClCD,QAAAA,WAAW,GAAG,KAAKA,WAAnB;AACD,OAFD,MAEO;AACLA,QAAAA,WAAW,IAAI,KAAK3C,KAAL,CAAW6C,UAAX,GAAwB3E,KAAxB,GAAgC,CAA/C;AACA,cAAM4E,WAAW,GAAGxF,WAAW,CAACyF,cAAZ,CAA2B,KAAK3D,IAAL,CAAU4D,cAAV,EAA3B,CAApB;;AACA,YAAIF,WAAJ,EAAiB;AACfH,UAAAA,WAAW,IAAI,CAACG,WAAW,CAACG,IAAZ,KAAqBX,MAAtB,IAAgC,GAA/C;AACD,SAFD,MAEO;AACLK,UAAAA,WAAW,IAAI,CAACzB,KAAK,CAACqB,CAAN,GAAUrB,KAAK,CAAChD,KAAhB,GAAwBoE,MAAzB,IAAmC,GAAlD;AACD;;AACD,aAAKK,WAAL,GAAmBA,WAAnB;AACD;;AACDL,MAAAA,MAAM,IAAIK,WAAV;AACD;;AAEDlF,IAAAA,CAAC,CAAC,sBAAD,EAAyB,KAAKW,QAA9B,EAAwCkE,MAAxC,EAAgDE,MAAhD,CAAD;;AAEA,QAAI,KAAK/C,eAAT,EAA0B;AACxB,WAAKA,eAAL,CAAqByD,MAArB,CAA4BpC,GAA5B,EAAiCwB,MAAjC,EAAyCE,MAAzC;AACAA,MAAAA,MAAM,IAAI,KAAK/C,eAAL,CAAqBoD,UAArB,GAAkCM,MAA5C;AACAX,MAAAA,MAAM,IAAI,KAAK9C,cAAL,CAAoBE,sBAA9B;AACD;;AAED,SAAKI,KAAL,CAAWkD,MAAX,CAAkBpC,GAAlB,EAAuBwB,MAAvB,EAA+BE,MAA/B;AACAA,IAAAA,MAAM,IAAI,KAAKxC,KAAL,CAAW6C,UAAX,GAAwBM,MAAlC;;AAEA,QAAI,KAAK3D,eAAT,EAA0B;AACxBgD,MAAAA,MAAM,IAAI,KAAK9C,cAAL,CAAoBG,sBAA9B;AACA,WAAKL,eAAL,CAAqB0D,MAArB,CAA4BpC,GAA5B,EAAiCwB,MAAjC,EAAyCE,MAAzC;AACD;AACF;;AAjKoC","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n// Author: Cyril Silverman\n//\n// ## Description\n//\n// This file implements ornaments as modifiers that can be\n// attached to notes. The complete list of ornaments is available in\n// `tables.js` under `Vex.Flow.ornamentCodes`.\n//\n// See `tests/ornament_tests.js` for usage examples.\n\nimport { Vex } from './vex';\nimport { Flow } from './tables';\nimport { Modifier } from './modifier';\nimport { TickContext } from './tickcontext';\nimport { StaveNote } from './stavenote';\nimport { Glyph } from './glyph';\n\n// To enable logging for this class. Set `Vex.Flow.Ornament.DEBUG` to `true`.\nfunction L(...args) { if (Ornament.DEBUG) Vex.L('Vex.Flow.Ornament', args); }\n\nexport class Ornament extends Modifier {\n  static get CATEGORY() { return 'ornaments'; }\n\n  // ## Static Methods\n  // Arrange ornaments inside `ModifierContext`\n  static format(ornaments, state) {\n    if (!ornaments || ornaments.length === 0) return false;\n\n    let width = 0;\n    for (let i = 0; i < ornaments.length; ++i) {\n      const ornament = ornaments[i];\n      const increment = 2;\n\n      width = Math.max(ornament.getWidth(), width);\n\n      if (ornament.getPosition() === Modifier.Position.ABOVE) {\n        ornament.setTextLine(state.top_text_line);\n        state.top_text_line += increment;\n      } else {\n        ornament.setTextLine(state.text_line);\n        state.text_line += increment;\n      }\n    }\n\n    state.left_shift += width / 2;\n    state.right_shift += width / 2;\n    return true;\n  }\n\n  // Create a new ornament of type `type`, which is an entry in\n  // `Vex.Flow.ornamentCodes` in `tables.js`.\n  constructor(type) {\n    super();\n    this.setAttribute('type', 'Ornament');\n\n    this.note = null;\n    this.index = null;\n    this.type = type;\n    this.position = Modifier.Position.ABOVE;\n    this.delayed = false;\n\n    this.accidentalUpper = null;\n    this.accidentalLower = null;\n\n    this.render_options = {\n      font_scale: 38,\n      accidentalLowerPadding: 3,\n      accidentalUpperPadding: 3,\n    };\n\n    this.ornament = Flow.ornamentCodes(this.type);\n    if (!this.ornament) {\n      throw new Vex.RERR('ArgumentError', `Ornament not found: '${this.type}'`);\n    }\n\n    this.glyph = new Glyph(this.ornament.code, this.render_options.font_scale, { category: `ornament.${this.ornament.code}` });\n    this.glyph.setOrigin(0.5, 1.0); // FIXME: SMuFL won't require a vertical origin shift\n  }\n\n  getCategory() { return Ornament.CATEGORY; }\n\n  // Set whether the ornament is to be delayed\n  setDelayed(delayed) { this.delayed = delayed; return this; }\n\n  // Set the upper accidental for the ornament\n  setUpperAccidental(accid) {\n    const scale = this.render_options.font_scale / 1.3;\n    this.accidentalUpper = new Glyph(Flow.accidentalCodes(accid).code, scale);\n    this.accidentalUpper.setOrigin(0.5, 1.0);\n    return this;\n  }\n\n  // Set the lower accidental for the ornament\n  setLowerAccidental(accid) {\n    const scale = this.render_options.font_scale / 1.3;\n    this.accidentalLower = new Glyph(Flow.accidentalCodes(accid).code, scale);\n    this.accidentalLower.setOrigin(0.5, 1.0);\n    return this;\n  }\n\n  // Render ornament in position next to note.\n  draw() {\n    this.checkContext();\n\n    if (!this.note || this.index == null) {\n      throw new Vex.RERR('NoAttachedNote', \"Can't draw Ornament without a note and index.\");\n    }\n\n    this.setRendered();\n\n    const ctx = this.context;\n    const stemDir = this.note.getStemDirection();\n    const stave = this.note.getStave();\n\n    // Get stem extents\n    const stemExtents = this.note.getStem().getExtents();\n    let y = stemDir === StaveNote.STEM_DOWN ? stemExtents.baseY : stemExtents.topY;\n\n    // TabNotes don't have stems attached to them. Tab stems are rendered\n    // outside the stave.\n    if (this.note.getCategory() === 'tabnotes') {\n      if (this.note.hasStem()) {\n        if (stemDir === StaveNote.STEM_DOWN) {\n          y = stave.getYForTopText(this.text_line);\n        }\n      } else { // Without a stem\n        y = stave.getYForTopText(this.text_line);\n      }\n    }\n\n    const isPlacedOnNoteheadSide = stemDir === StaveNote.STEM_DOWN;\n    const spacing = stave.getSpacingBetweenLines();\n    let lineSpacing = 1;\n\n    // Beamed stems are longer than quarter note stems, adjust accordingly\n    if (!isPlacedOnNoteheadSide && this.note.beam) {\n      lineSpacing += 0.5;\n    }\n\n    const totalSpacing = spacing * (this.text_line + lineSpacing);\n    const glyphYBetweenLines = y - totalSpacing;\n\n    // Get initial coordinates for the modifier position\n    const start = this.note.getModifierStartXY(this.position, this.index);\n    let glyphX = start.x;\n    let glyphY = Math.min(stave.getYForTopText(this.text_line), glyphYBetweenLines);\n    glyphY += this.y_shift;\n\n    // Ajdust x position if ornament is delayed\n    if (this.delayed) {\n      let delayXShift = 0;\n      if (this.delayXShift !== undefined) {\n        delayXShift = this.delayXShift;\n      } else {\n        delayXShift += this.glyph.getMetrics().width / 2;\n        const nextContext = TickContext.getNextContext(this.note.getTickContext());\n        if (nextContext) {\n          delayXShift += (nextContext.getX() - glyphX) * 0.5;\n        } else {\n          delayXShift += (stave.x + stave.width - glyphX) * 0.5;\n        }\n        this.delayXShift = delayXShift;\n      }\n      glyphX += delayXShift;\n    }\n\n    L('Rendering ornament: ', this.ornament, glyphX, glyphY);\n\n    if (this.accidentalLower) {\n      this.accidentalLower.render(ctx, glyphX, glyphY);\n      glyphY -= this.accidentalLower.getMetrics().height;\n      glyphY -= this.render_options.accidentalLowerPadding;\n    }\n\n    this.glyph.render(ctx, glyphX, glyphY);\n    glyphY -= this.glyph.getMetrics().height;\n\n    if (this.accidentalUpper) {\n      glyphY -= this.render_options.accidentalUpperPadding;\n      this.accidentalUpper.render(ctx, glyphX, glyphY);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}