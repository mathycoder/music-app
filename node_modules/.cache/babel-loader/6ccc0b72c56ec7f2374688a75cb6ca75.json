{"ast":null,"code":"// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n//\n// This file implements `NoteHeads`. `NoteHeads` are typically not manipulated\n// directly, but used internally in `StaveNote`.\n//\n// See `tests/notehead_tests.js` for usage examples.\nimport { Vex } from './vex';\nimport { Flow } from './tables';\nimport { Note } from './note';\nimport { Stem } from './stem';\nimport { StaveNote } from './stavenote';\nimport { Glyph } from './glyph'; // To enable logging for this class. Set `Vex.Flow.NoteHead.DEBUG` to `true`.\n\nfunction L(...args) {\n  if (NoteHead.DEBUG) Vex.L('Vex.Flow.NoteHead', args);\n} // Draw slashnote head manually. No glyph exists for this.\n//\n// Parameters:\n// * `ctx`: the Canvas context\n// * `duration`: the duration of the note. ex: \"4\"\n// * `x`: the x coordinate to draw at\n// * `y`: the y coordinate to draw at\n// * `stem_direction`: the direction of the stem\n\n\nfunction drawSlashNoteHead(ctx, duration, x, y, stem_direction, staveSpace) {\n  const width = Flow.SLASH_NOTEHEAD_WIDTH;\n  ctx.save();\n  ctx.setLineWidth(Flow.STEM_WIDTH);\n  let fill = false;\n\n  if (Flow.durationToNumber(duration) > 2) {\n    fill = true;\n  }\n\n  if (!fill) x -= Flow.STEM_WIDTH / 2 * stem_direction;\n  ctx.beginPath();\n  ctx.moveTo(x, y + staveSpace);\n  ctx.lineTo(x, y + 1);\n  ctx.lineTo(x + width, y - staveSpace);\n  ctx.lineTo(x + width, y);\n  ctx.lineTo(x, y + staveSpace);\n  ctx.closePath();\n\n  if (fill) {\n    ctx.fill();\n  } else {\n    ctx.stroke();\n  }\n\n  if (Flow.durationToFraction(duration).equals(0.5)) {\n    const breve_lines = [-3, -1, width + 1, width + 3];\n\n    for (let i = 0; i < breve_lines.length; i++) {\n      ctx.beginPath();\n      ctx.moveTo(x + breve_lines[i], y - 10);\n      ctx.lineTo(x + breve_lines[i], y + 11);\n      ctx.stroke();\n    }\n  }\n\n  ctx.restore();\n}\n\nexport class NoteHead extends Note {\n  static get CATEGORY() {\n    return 'notehead';\n  }\n\n  constructor(head_options) {\n    super(head_options);\n    this.setAttribute('type', 'NoteHead');\n    this.index = head_options.index;\n    this.x = head_options.x || 0;\n    this.y = head_options.y || 0;\n    this.note_type = head_options.note_type;\n    this.duration = head_options.duration;\n    this.displaced = head_options.displaced || false;\n    this.stem_direction = head_options.stem_direction || StaveNote.STEM_UP;\n    this.line = head_options.line; // Get glyph code based on duration and note type. This could be\n    // regular notes, rests, or other custom codes.\n\n    this.glyph = Flow.getGlyphProps(this.duration, this.note_type);\n\n    if (!this.glyph) {\n      throw new Vex.RuntimeError('BadArguments', `No glyph found for duration '${this.duration}' and type '${this.note_type}'`);\n    }\n\n    this.glyph_code = this.glyph.code_head;\n    this.x_shift = head_options.x_shift || 0;\n\n    if (head_options.custom_glyph_code) {\n      this.custom_glyph = true;\n      this.glyph_code = head_options.custom_glyph_code;\n      this.stem_up_x_offset = head_options.stem_up_x_offset || 0;\n      this.stem_down_x_offset = head_options.stem_down_x_offset || 0;\n    }\n\n    this.style = head_options.style;\n    this.slashed = head_options.slashed;\n    Vex.Merge(this.render_options, {\n      // font size for note heads\n      glyph_font_scale: head_options.glyph_font_scale || Flow.DEFAULT_NOTATION_FONT_SCALE,\n      // number of stroke px to the left and right of head\n      stroke_px: 3\n    });\n    this.setWidth(this.glyph.getWidth(this.render_options.glyph_font_scale));\n  }\n\n  getCategory() {\n    return NoteHead.CATEGORY;\n  } // Get the width of the notehead\n\n\n  getWidth() {\n    return this.width;\n  } // Determine if the notehead is displaced\n\n\n  isDisplaced() {\n    return this.displaced === true;\n  } // Get the glyph data\n\n\n  getGlyph() {\n    return this.glyph;\n  } // Set the X coordinate\n\n\n  setX(x) {\n    this.x = x;\n    return this;\n  } // get/set the Y coordinate\n\n\n  getY() {\n    return this.y;\n  }\n\n  setY(y) {\n    this.y = y;\n    return this;\n  } // Get/set the stave line the notehead is placed on\n\n\n  getLine() {\n    return this.line;\n  }\n\n  setLine(line) {\n    this.line = line;\n    return this;\n  } // Get the canvas `x` coordinate position of the notehead.\n\n\n  getAbsoluteX() {\n    // If the note has not been preformatted, then get the static x value\n    // Otherwise, it's been formatted and we should use it's x value relative\n    // to its tick context\n    const x = !this.preFormatted ? this.x : super.getAbsoluteX(); // For a more natural displaced notehead, we adjust the displacement amount\n    // by half the stem width in order to maintain a slight overlap with the stem\n\n    const displacementStemAdjustment = Stem.WIDTH / 2;\n    const fontShift = this.musicFont.lookupMetric('notehead.shiftX', 0) * this.stem_direction;\n    const displacedFontShift = this.musicFont.lookupMetric('noteHead.displaced.shiftX', 0) * this.stem_direction;\n    return x + fontShift + (this.displaced ? (this.width - displacementStemAdjustment) * this.stem_direction + displacedFontShift : 0);\n  } // Get the `BoundingBox` for the `NoteHead`\n\n\n  getBoundingBox() {\n    if (!this.preFormatted) {\n      throw new Vex.RERR('UnformattedNote', \"Can't call getBoundingBox on an unformatted note.\");\n    }\n\n    const spacing = this.stave.getSpacingBetweenLines();\n    const half_spacing = spacing / 2;\n    const min_y = this.y - half_spacing;\n    return new Flow.BoundingBox(this.getAbsoluteX(), min_y, this.width, spacing);\n  } // Set notehead to a provided `stave`\n\n\n  setStave(stave) {\n    const line = this.getLine();\n    this.stave = stave;\n    this.setY(stave.getYForNote(line));\n    this.context = this.stave.context;\n    return this;\n  } // Pre-render formatting\n\n\n  preFormat() {\n    if (this.preFormatted) return this;\n    const width = this.getWidth() + this.leftDisplacedHeadPx + this.rightDisplacedHeadPx;\n    this.setWidth(width);\n    this.setPreFormatted(true);\n    return this;\n  } // Draw the notehead\n\n\n  draw() {\n    this.checkContext();\n    this.setRendered();\n    const ctx = this.context;\n    let head_x = this.getAbsoluteX();\n\n    if (this.custom_glyph) {\n      // head_x += this.x_shift;\n      head_x += this.stem_direction === Stem.UP ? this.stem_up_x_offset : this.stem_down_x_offset;\n    }\n\n    const y = this.y;\n    L(\"Drawing note head '\", this.note_type, this.duration, \"' at\", head_x, y); // Begin and end positions for head.\n\n    const stem_direction = this.stem_direction;\n    const glyph_font_scale = this.render_options.glyph_font_scale;\n\n    if (this.style) {\n      this.applyStyle(ctx);\n    }\n\n    const categorySuffix = `${this.glyph_code}Stem${stem_direction === Stem.UP ? 'Up' : 'Down'}`;\n\n    if (this.note_type === 's') {\n      const staveSpace = this.stave.getSpacingBetweenLines();\n      drawSlashNoteHead(ctx, this.duration, head_x, y, stem_direction, staveSpace);\n    } else {\n      Glyph.renderGlyph(ctx, head_x, y, glyph_font_scale, this.glyph_code, {\n        font: this.musicFont,\n        category: this.custom_glyph ? `noteHead.custom.${categorySuffix}` : `noteHead.standard.${categorySuffix}`\n      });\n    }\n\n    if (this.style) {\n      this.restoreStyle(ctx);\n    }\n  }\n\n}","map":{"version":3,"sources":["/Users/adamsarli/Coding/music-app/node_modules/vexflow/src/notehead.js"],"names":["Vex","Flow","Note","Stem","StaveNote","Glyph","L","args","NoteHead","DEBUG","drawSlashNoteHead","ctx","duration","x","y","stem_direction","staveSpace","width","SLASH_NOTEHEAD_WIDTH","save","setLineWidth","STEM_WIDTH","fill","durationToNumber","beginPath","moveTo","lineTo","closePath","stroke","durationToFraction","equals","breve_lines","i","length","restore","CATEGORY","constructor","head_options","setAttribute","index","note_type","displaced","STEM_UP","line","glyph","getGlyphProps","RuntimeError","glyph_code","code_head","x_shift","custom_glyph_code","custom_glyph","stem_up_x_offset","stem_down_x_offset","style","slashed","Merge","render_options","glyph_font_scale","DEFAULT_NOTATION_FONT_SCALE","stroke_px","setWidth","getWidth","getCategory","isDisplaced","getGlyph","setX","getY","setY","getLine","setLine","getAbsoluteX","preFormatted","displacementStemAdjustment","WIDTH","fontShift","musicFont","lookupMetric","displacedFontShift","getBoundingBox","RERR","spacing","stave","getSpacingBetweenLines","half_spacing","min_y","BoundingBox","setStave","getYForNote","context","preFormat","leftDisplacedHeadPx","rightDisplacedHeadPx","setPreFormatted","draw","checkContext","setRendered","head_x","UP","applyStyle","categorySuffix","renderGlyph","font","category","restoreStyle"],"mappings":"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","sourcesContent":["// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.\n//\n// ## Description\n//\n// This file implements `NoteHeads`. `NoteHeads` are typically not manipulated\n// directly, but used internally in `StaveNote`.\n//\n// See `tests/notehead_tests.js` for usage examples.\n\nimport { Vex } from './vex';\nimport { Flow } from './tables';\nimport { Note } from './note';\nimport { Stem } from './stem';\nimport { StaveNote } from './stavenote';\nimport { Glyph } from './glyph';\n\n// To enable logging for this class. Set `Vex.Flow.NoteHead.DEBUG` to `true`.\nfunction L(...args) { if (NoteHead.DEBUG) Vex.L('Vex.Flow.NoteHead', args); }\n\n// Draw slashnote head manually. No glyph exists for this.\n//\n// Parameters:\n// * `ctx`: the Canvas context\n// * `duration`: the duration of the note. ex: \"4\"\n// * `x`: the x coordinate to draw at\n// * `y`: the y coordinate to draw at\n// * `stem_direction`: the direction of the stem\nfunction drawSlashNoteHead(ctx, duration, x, y, stem_direction, staveSpace) {\n  const width = Flow.SLASH_NOTEHEAD_WIDTH;\n  ctx.save();\n  ctx.setLineWidth(Flow.STEM_WIDTH);\n\n  let fill = false;\n\n  if (Flow.durationToNumber(duration) > 2) {\n    fill = true;\n  }\n\n  if (!fill) x -= (Flow.STEM_WIDTH / 2) * stem_direction;\n\n  ctx.beginPath();\n  ctx.moveTo(x, y + staveSpace);\n  ctx.lineTo(x, y + 1);\n  ctx.lineTo(x + width, y - staveSpace);\n  ctx.lineTo(x + width, y);\n  ctx.lineTo(x, y + staveSpace);\n  ctx.closePath();\n\n  if (fill) {\n    ctx.fill();\n  } else {\n    ctx.stroke();\n  }\n\n  if (Flow.durationToFraction(duration).equals(0.5)) {\n    const breve_lines = [-3, -1, width + 1, width + 3];\n    for (let i = 0; i < breve_lines.length; i++) {\n      ctx.beginPath();\n      ctx.moveTo(x + breve_lines[i], y - 10);\n      ctx.lineTo(x + breve_lines[i], y + 11);\n      ctx.stroke();\n    }\n  }\n\n  ctx.restore();\n}\n\nexport class NoteHead extends Note {\n  static get CATEGORY() { return 'notehead'; }\n\n  constructor(head_options) {\n    super(head_options);\n    this.setAttribute('type', 'NoteHead');\n\n    this.index = head_options.index;\n    this.x = head_options.x || 0;\n    this.y = head_options.y || 0;\n    this.note_type = head_options.note_type;\n    this.duration = head_options.duration;\n    this.displaced = head_options.displaced || false;\n    this.stem_direction = head_options.stem_direction || StaveNote.STEM_UP;\n    this.line = head_options.line;\n\n    // Get glyph code based on duration and note type. This could be\n    // regular notes, rests, or other custom codes.\n    this.glyph = Flow.getGlyphProps(this.duration, this.note_type);\n    if (!this.glyph) {\n      throw new Vex.RuntimeError(\n        'BadArguments',\n        `No glyph found for duration '${this.duration}' and type '${this.note_type}'`);\n    }\n\n    this.glyph_code = this.glyph.code_head;\n    this.x_shift = head_options.x_shift || 0;\n    if (head_options.custom_glyph_code) {\n      this.custom_glyph = true;\n      this.glyph_code = head_options.custom_glyph_code;\n      this.stem_up_x_offset = head_options.stem_up_x_offset || 0;\n      this.stem_down_x_offset = head_options.stem_down_x_offset || 0;\n    }\n\n    this.style = head_options.style;\n    this.slashed = head_options.slashed;\n\n    Vex.Merge(this.render_options, {\n      // font size for note heads\n      glyph_font_scale: head_options.glyph_font_scale || Flow.DEFAULT_NOTATION_FONT_SCALE,\n      // number of stroke px to the left and right of head\n      stroke_px: 3,\n    });\n\n    this.setWidth(this.glyph.getWidth(this.render_options.glyph_font_scale));\n  }\n\n  getCategory() { return NoteHead.CATEGORY; }\n\n  // Get the width of the notehead\n  getWidth() { return this.width; }\n\n  // Determine if the notehead is displaced\n  isDisplaced() { return this.displaced === true; }\n\n  // Get the glyph data\n  getGlyph() { return this.glyph; }\n\n  // Set the X coordinate\n  setX(x) { this.x = x; return this; }\n\n  // get/set the Y coordinate\n  getY() { return this.y; }\n  setY(y) { this.y = y;  return this; }\n\n  // Get/set the stave line the notehead is placed on\n  getLine() { return this.line; }\n  setLine(line) { this.line = line; return this; }\n\n  // Get the canvas `x` coordinate position of the notehead.\n  getAbsoluteX() {\n    // If the note has not been preformatted, then get the static x value\n    // Otherwise, it's been formatted and we should use it's x value relative\n    // to its tick context\n    const x = !this.preFormatted ? this.x : super.getAbsoluteX();\n\n    // For a more natural displaced notehead, we adjust the displacement amount\n    // by half the stem width in order to maintain a slight overlap with the stem\n    const displacementStemAdjustment = (Stem.WIDTH / 2);\n    const fontShift = this.musicFont.lookupMetric('notehead.shiftX', 0) * this.stem_direction;\n    const displacedFontShift = this.musicFont.lookupMetric('noteHead.displaced.shiftX', 0) * this.stem_direction;\n\n    return x + fontShift + (this.displaced\n      ? ((this.width - displacementStemAdjustment) * this.stem_direction) + displacedFontShift\n      : 0\n    );\n  }\n\n  // Get the `BoundingBox` for the `NoteHead`\n  getBoundingBox() {\n    if (!this.preFormatted) {\n      throw new Vex.RERR('UnformattedNote', \"Can't call getBoundingBox on an unformatted note.\");\n    }\n\n    const spacing = this.stave.getSpacingBetweenLines();\n    const half_spacing = spacing / 2;\n    const min_y = this.y - half_spacing;\n\n    return new Flow.BoundingBox(this.getAbsoluteX(), min_y, this.width, spacing);\n  }\n\n  // Set notehead to a provided `stave`\n  setStave(stave) {\n    const line = this.getLine();\n\n    this.stave = stave;\n    this.setY(stave.getYForNote(line));\n    this.context = this.stave.context;\n    return this;\n  }\n\n  // Pre-render formatting\n  preFormat() {\n    if (this.preFormatted) return this;\n\n    const width = this.getWidth() + this.leftDisplacedHeadPx + this.rightDisplacedHeadPx;\n\n    this.setWidth(width);\n    this.setPreFormatted(true);\n    return this;\n  }\n\n  // Draw the notehead\n  draw() {\n    this.checkContext();\n    this.setRendered();\n\n    const ctx = this.context;\n    let head_x = this.getAbsoluteX();\n    if (this.custom_glyph) {\n      // head_x += this.x_shift;\n      head_x += this.stem_direction === Stem.UP ? this.stem_up_x_offset : this.stem_down_x_offset;\n    }\n\n    const y = this.y;\n\n    L(\"Drawing note head '\", this.note_type, this.duration, \"' at\", head_x, y);\n\n    // Begin and end positions for head.\n    const stem_direction = this.stem_direction;\n    const glyph_font_scale = this.render_options.glyph_font_scale;\n\n    if (this.style) {\n      this.applyStyle(ctx);\n    }\n\n    const categorySuffix = `${this.glyph_code}Stem${stem_direction === Stem.UP ? 'Up' : 'Down'}`;\n    if (this.note_type === 's') {\n      const staveSpace = this.stave.getSpacingBetweenLines();\n      drawSlashNoteHead(ctx, this.duration, head_x, y, stem_direction, staveSpace);\n    } else {\n      Glyph.renderGlyph(ctx, head_x, y, glyph_font_scale, this.glyph_code, {\n        font: this.musicFont,\n        category: this.custom_glyph ? `noteHead.custom.${categorySuffix}` : `noteHead.standard.${categorySuffix}`\n      });\n    }\n\n    if (this.style) {\n      this.restoreStyle(ctx);\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}